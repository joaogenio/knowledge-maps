[
    {
        "doc_title": "Naprt expression regulation mechanisms: Novel functions predicted by a bioinformatics approach",
        "doc_scopus_id": "85121650571",
        "doc_doi": "10.3390/genes12122022",
        "doc_eid": "2-s2.0-85121650571",
        "doc_date": "2021-12-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Genetics",
                "area_abbreviation": "BIOC",
                "area_code": "1311"
            },
            {
                "area_name": "Genetics (clinical)",
                "area_abbreviation": "MEDI",
                "area_code": "2716"
            }
        ],
        "doc_keywords": [
            "Alternative Splicing",
            "Cell Differentiation",
            "Cell Line, Tumor",
            "Computational Biology",
            "Databases, Genetic",
            "Humans",
            "Pentosyltransferases",
            "Transcriptional Activation"
        ],
        "doc_abstract": "© 2021 by the authors. Licensee MDPI, Basel, Switzerland.The nicotinate phosphoribosyltransferase (NAPRT) gene has gained relevance in the research of cancer therapeutic strategies due to its main role as a NAD biosynthetic enzyme. NAD metabolism is an attractive target for the development of anti-cancer therapies, given the high energy requirements of proliferating cancer cells and NAD-dependent signaling. A few studies have shown that NAPRT expression varies in different cancer types, making it imperative to assess NAPRT expression and functionality status prior to the application of therapeutic strategies targeting NAD. In addition, the recent finding of NAPRT extracellular form (eNAPRT) suggested the involvement of NAPRT in inflammation and signaling. However, the mechanisms regulating NAPRT gene expression have never been thoroughly addressed. In this study, we searched for NAPRT gene expression regulatory mechanisms in transcription factors (TFs), RNA binding proteins (RBPs) and microRNA (miRNAs) databases. We identified several potential regulators of NAPRT transcription activation, downregulation and alternative splicing and performed GO and expression analyses. The results of the functional analysis of TFs, RBPs and miRNAs suggest new, unexpected functions for the NAPRT gene in cell differentiation, development and neuronal biology.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Merging microarray studies to identify a common gene expression signature to several structural heart diseases",
        "doc_scopus_id": "85087926456",
        "doc_doi": "10.1186/s13040-020-00217-8",
        "doc_eid": "2-s2.0-85087926456",
        "doc_date": "2020-07-08",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Biochemistry",
                "area_abbreviation": "BIOC",
                "area_code": "1303"
            },
            {
                "area_name": "Molecular Biology",
                "area_abbreviation": "BIOC",
                "area_code": "1312"
            },
            {
                "area_name": "Genetics",
                "area_abbreviation": "BIOC",
                "area_code": "1311"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computational Mathematics",
                "area_abbreviation": "MATH",
                "area_code": "2605"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2020 The Author(s).Background: Heart disease is the leading cause of death worldwide. Knowing a gene expression signature in heart disease can lead to the development of more efficient diagnosis and treatments that may prevent premature deaths. A large amount of microarray data is available in public repositories and can be used to identify differentially expressed genes. However, most of the microarray datasets are composed of a reduced number of samples and to obtain more reliable results, several datasets have to be merged, which is a challenging task. The identification of differentially expressed genes is commonly done using statistical methods. Nonetheless, these methods are based on the definition of an arbitrary threshold to select the differentially expressed genes and there is no consensus on the values that should be used. Results: Nine publicly available microarray datasets from studies of different heart diseases were merged to form a dataset composed of 689 samples and 8354 features. Subsequently, the adjusted p-value and fold change were determined and by combining a set of adjusted p-values cutoffs with a list of different fold change thresholds, 12 sets of differentially expressed genes were obtained. To select the set of differentially expressed genes that has the best accuracy in classifying samples from patients with heart diseases and samples from patients with no heart condition, the random forest algorithm was used. A set of 62 differentially expressed genes having a classification accuracy of approximately 95% was identified. Conclusions: We identified a gene expression signature common to different cardiac diseases and supported our findings by showing their involvement in the pathophysiology of the heart. The approach used in this study is suitable for the identification of gene expression signatures, and can be extended to different diseases.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "GTO: A toolkit to unify pipelines in genomic and proteomic research",
        "doc_scopus_id": "85086630979",
        "doc_doi": "10.1016/j.softx.2020.100535",
        "doc_eid": "2-s2.0-85086630979",
        "doc_date": "2020-07-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "C language",
            "Life-sciences",
            "Modular architectures",
            "Next-generation sequencing",
            "Proteomic"
        ],
        "doc_abstract": "© 2020 The AuthorsNext-generation sequencing triggered the production of a massive volume of publicly available data and the development of new specialised tools. These tools are dispersed over different frameworks, making the management and analyses of the data a challenging task. Additionally, new targeted tools are needed, given the dynamics and specificities of the field. We present GTO, a comprehensive toolkit designed to unify pipelines in genomic and proteomic research, which combines specialised tools for analysis, simulation, compression, development, visualisation, and transformation of the data. This toolkit combines novel tools with a modular architecture, being an excellent platform for experimental scientists, as well as a useful resource for teaching bioinformatics enquiry to students in life sciences. GTO is implemented in C language and is available, under the MIT license, at https://bioinformatics.ua.pt/gto.",
        "available": true,
        "clean_text": "serial JL 312019 291210 291690 291735 291791 291848 31 90 SoftwareX SOFTWAREX 2020-06-20 2020-06-20 2020-06-20 2020-06-20 2021-06-24T16:39:01 S2352-7110(20)30147-3 S2352711020301473 10.1016/j.softx.2020.100535 S300 S300.3 FULL-TEXT 2021-06-24T16:23:59.139745Z 0 0 20200701 20201231 2020 2020-06-20T23:10:09.350353Z articleinfo articlenumber articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids contenttype copyright crossmark dateloaded dateloadedtxt datesearch datesort dateupdated dco docsubtype doctype doi eid ewtransactionid fundingbodyid hubeid indexeddate issn issnnorm itemstage itemtransactionid itemweight oauserlicense openaccess openarchive pg pgfirst pii piinorm pubdateend pubdatestart pubdatetxt pubyr sortorder sponsoredaccesstype srctitle srctitlenorm srctype ssids alllist content oa subj subheadings suppl tomb volfirst volissue volumelist yearnav figure table body mmlmath acknowledge affil articletitle auth authfirstini authfull authkeywords authlast grantnumber grantsponsor grantsponsorid primabst pubtype ref 2352-7110 23527110 UNLIMITED NONE true 12 12 C Volume 12 21 100535 100535 100535 202007 202012 July–December 2020 2020-07-01 2020-12-31 2020 simple-article osp © 2020 The Authors. Published by Elsevier B.V. GTOATOOLKITUNIFYPIPELINESINGENOMICPROTEOMICRESEARCH ALMEIDA J 1 Motivation and significance 2 Software description 2.1 Software architecture 2.2 Software functionalities 2.2.1 Genomics 2.2.2 Proteomics 2.2.3 General purpose 2.2.4 External tools 3 Illustrative examples 3.1 Bi-directional complexity profiles 3.2 Rearrangements map generation 3.3 Viral metagenomic identification 4 Impact 5 Conclusions Acknowledgements References MARDIS 2017 213 E VANDERAUWERA 2013 G KESSNER 2008 2534 2536 D CHEN 2018 i884 i890 S LIU 2019 4560 4567 Y GRABOWSKI 2019 677 678 S MALYSA 2015 3122 3129 G LIU 2019 2066 2074 Y CHANDAK 2019 2674 2676 S PINHO 2013 e79922 A PINHO 2011 2024 2028 A 201119THEUROPEANSIGNALPROCESSINGCONFERENCE SYMBOLICNUMERICALCONVERSIONDNASEQUENCESUSINGFINITECONTEXTMODELS PRATAS 2019 137 145 D INTERNATIONALCONFERENCEPRACTICALAPPLICATIONSCOMPUTATIONALBIOLOGYBIOINFORMATICS GECO2OPTIMIZEDTOOLFORLOSSLESSCOMPRESSIONANALYSISDNASEQUENCES HOSSEINI 2019 68 76 M CARVALHO 2018 49 55 J HOSSEINI 2016 56 M AGUEROCHAPIN 2006 723 730 G PRATAS 2015 10203 D ZIELEZINSKI 2019 A BENCHMARKINGALIGNMENTFREESEQUENCECOMPARISONMETHODS FORSLUND 2019 469 504 S EVOLUTIONARYGENOMICS EVOLUTIONPROTEINDOMAINARCHITECTURES ROST 1999 85 94 B PRATAS 2018 D FALCONAMETHODINFERMETAGENOMICCOMPOSITIONANCIENTDNA PRATAS 2018 1177 1181 D 201826THEUROPEANSIGNALPROCESSINGCONFERENCEEUSIPCO METAGENOMICCOMPOSITIONANALYSISSEDIMENTARYANCIENTDNAISLEWIGHT HUANG 2011 593 594 W DROOP 2016 1883 1884 A AFGAN 2018 W537 W544 E SHEN 2016 e0163962 W DEPRISTO 2011 491 M GOECKS 2010 R86 J BLANKENBERG 2010 1783 1785 D LIU 2017 3364 3372 Y OCHOA 2014 626 633 I DEOROWICZ 2015 11565 S PRATAS 2018 105 113 D INTERNATIONALCONFERENCEPRACTICALAPPLICATIONSCOMPUTATIONALBIOLOGYBIOINFORMATICS COMPRESSIONAMINOACIDSEQUENCES PRATAS 2014 40 D ESCALONA 2016 459 M ALMEIDAX2020X100535 ALMEIDAX2020X100535XJ Full 2020-06-03T16:10:38Z Author This is an open access article under the CC BY license. © 2020 The Authors. Published by Elsevier B.V. 2021-06-03T16:43:35.966Z Foundation for Science and Technology SFRH/BD/147837/2019 UIDB/00127/2020 FCT Fundação para a Ciência e a Tecnologia Centro 2020 program NETDIAMOND POCI-01-0145-FEDER-016385 This work has received support from the NETDIAMOND, Portugal project ( POCI-01-0145-FEDER-016385 ), co-funded by Centro 2020 program, Portugal 2020, European Union , and from the FCT - Foundation for Science and Technology, Portugal , in the context of the project UIDB/00127/2020. João Almeida is supported by FCT - Foundation for Science and Technology, Portugal (national funds), grant SFRH/BD/147837/2019 . item S2352-7110(20)30147-3 S2352711020301473 10.1016/j.softx.2020.100535 312019 2021-06-24T16:23:59.139745Z 2020-07-01 2020-12-31 UNLIMITED NONE true 1061501 MAIN 6 51343 849 656 IMAGE-WEB-PDF 1 gr3 21082 116 376 gr1 51221 263 470 gr4 24493 141 376 fx1001 4519 27 817 gr2 16382 83 470 gr3 6347 68 219 gr1 10351 123 219 gr4 7605 82 219 fx1001 777 7 219 gr2 3191 39 219 gr3 155334 516 1668 gr1 436164 1166 2083 gr4 160054 624 1667 fx1001 16238 73 2171 gr2 128419 370 2083 si1 667 SOFTX 100535 100535 S2352-7110(20)30147-3 10.1016/j.softx.2020.100535 The Authors Fig. 1 Bi-directional complexity profiles of four types of human Herpesvirus (HHV2, HHV3, HHV4 and HHV7) generated with GTO using the pipeline: gto_complexity_profile_regions.sh. Complexity values below one are highlighted with blue colour while the others with green. Bps stands for bits per symbol where lower values represent redundancy. The length is in Kb (Kilobases) and all profiles use the same scale. (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.) Fig. 2 Bi-directional complexity profiles of human titin protein generated with GTO using the pipeline: gto_proteins_complexity_profile_regions.sh. Complexity values below three are highlighted with a red colour while the others with blue. Bps stands for bits per symbol where lower values represent redundancy. The length is in Ks (Kilosymbols). (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.) Fig. 3 Rearrangements map generated with GTO using the pipeline: gto_map_rearrangements.sh. The length of both sequences (A and B) is 5 MB. Wave pattern stands for inverted repeated regions. Fig. 4 Rearrangements map generated with GTO using the pipeline: gto_map_rearrangements_proteins.sh. Table 1 The eight most representative reference sequences according to the RS (Relative Similarity). ID stands for the order of the top output, length for the size of the reference genome, and GID for the sequence global identifier. ID Length RS (%) Reference GID Virus name 1 124884 97.767 X04370.1 HHV3 2 5596 96.603 AY386330.1 B19V 3 172764 94.143 DQ279927.1 HHV4 4 154675 81.400 JN561323.2 HHV2 5 154746 80.153 Z86099.2 HHV2 6 2785 78.300 AB041963.1 TTV 7 7372 71.445 MG921180.1 HPV 8 549 47.591 AY034056.1 PHV3-BALF1-gene Original software publication GTO: A toolkit to unify pipelines in genomic and proteomic research João R. Almeida a b ⁎ Armando J. Pinho a José L. Oliveira a Olga Fajarda a Diogo Pratas a c a Department of Electronics, Telecommunications and Informatics (DETI/IEETA), University of Aveiro, Aveiro, Portugal Department of Electronics, Telecommunications and Informatics (DETI/IEETA), University of Aveiro Aveiro Portugal Department of Electronics, Telecommunications and Informatics (DETI/IEETA), University of Aveiro, Aveiro, Portugal b Department of Information and Communications Technologies, University of A Coruña, A Coruña, Spain Department of Information and Communications Technologies, University of A Coruña, A Coruña Spain Department of Information and Communications Technologies, University of A Coruña, A Coruña, Spain c Department of Virology, University of Helsinki, Helsinki, Finland Department of Virology, University of Helsinki Helsinki Finland Department of Virology, University of Helsinki, Helsinki, Finland ⁎ Corresponding author at: Department of Electronics, Telecommunications and Informatics (DETI/IEETA), University of Aveiro, Aveiro, Portugal. Department of Electronics, Telecommunications and Informatics (DETI/IEETA), University of Aveiro Aveiro Portugal Next-generation sequencing triggered the production of a massive volume of publicly available data and the development of new specialised tools. These tools are dispersed over different frameworks, making the management and analyses of the data a challenging task. Additionally, new targeted tools are needed, given the dynamics and specificities of the field. We present GTO, a comprehensive toolkit designed to unify pipelines in genomic and proteomic research, which combines specialised tools for analysis, simulation, compression, development, visualisation, and transformation of the data. This toolkit combines novel tools with a modular architecture, being an excellent platform for experimental scientists, as well as a useful resource for teaching bioinformatics enquiry to students in life sciences. GTO is implemented in C language and is available, under the MIT license, at Keywords Genomic Toolkit Proteomic Toolkit Next-generation sequencing Code metadata Current code version v1.5 Permanent link to code/repository used for this code version Legal Code License MIT Code versioning system used GIT Software code languages, tools, and services used C Compilation requirements, operating environments & dependencies GCC and Make If available Link to developer documentation/manual Support email for questions pratas@ua.pt Software metadata Current software version v1.5 Permanent link to executables of this version Legal Software License MIT Computing platforms/Operating Systems Linux and Unix-like Installation requirements & dependencies GCC and Make If available, link to user manual - if formally published include a reference to the publication in the reference list Support email for questions pratas@ua.pt 1 Motivation and significance Next-generation sequencing (NGS) has become an essential tool in genetic and genomic analysis with a substantial impact in the fields of biomedicine and anthropology. The advantages of NGS over traditional methods include its multiplex capability and analytical resolution, making it a time and cost-efficient approach for fast clinical and forensic screening [1]. The development of efficient bioinformatics tools is essential to assess and analyse the large volumes of sequencing data produced by next-generation sequencers. However, more important than that are the computational methods that unify the existing tools, given the notable pace at which these tools become available. Toolkits are sets of tools that combine multiple features in a custom-based manner as some examples show, both in genomics [2] and proteomics [3]. Developing a toolkit requires a specific architecture, namely, taking into account the purpose and technologies, accessibility, compatibility, portability, interoperability, and usability. Moreover, implementation needs to consider efficiency, while maintaining affordable computational resources and the absence of dependencies (standalone use). We contribute with GTO (Genomic Toolkit), a set of tools to unify pipelines operating both at genomic and proteomic levels, with an open licence and free of any dependency. This toolkit includes information theory-based tools for reference-free and reference-based data compression applied to data analysis. Among many applications, this toolkit supports the creation of workflows for identification of metagenomic composition in FASTQ reads, detection and visualisation of genomic rearrangements, mapping and visualisation of variation, localisation of low complexity regions, or simulation of sequences with specific SNP and structural variant rates. The toolkit was designed for Unix/Linux-based systems, built for ultra-fast computations. It supports pipes for easy integration with the sub-programmes as well as external tools. GTO works as LEGOsTM , since it allows the construction of multiple pipelines with many combinations. We support the toolkit with a detailed manual and a website with several examples, including an online manual for fast learning. Due to the variety and distribution of the given tools and their tight interconnection using the command line with pipes, the toolkit is an excellent platform for scientists as well as for empowering students to progress to the scientific aspects of bioinformatics analysis efficiently. Therefore, without the need to install multiple programmes, dependencies, and read different manuals or licences, it is possible to maintain an easy-to-follow connection with all the phases of each pipeline application. 2 Software description GTO is a powerful toolkit composed of more than 75 tools with particular focus on genomics and proteomics, following an integrative and flexible design between the tools. GTO includes tools for information display, randomisation, edition, conversion, extraction, search, calculation, compression, simulation and visualisation. The toolkit can be used in common Linux distributions. We have been using GTO in common personal computers (e.g. a laptop with 8 GB RAM, 128 GB of SSD and an intel-i3 CPU from the 5th generation), but these characteristics can vary according to the data size and the execution requirements. 2.1 Software architecture The tools composing this toolkit aim for key features such as being easy to use, compile and improve and specially designed for work in Unix/Linux command line. These tools can be used in isolation, or combined as one, forming execution workflows. This is technically possible due to the two streams used for the computation, namely the standard input and output. Furthermore, the tools’ aggregation is possible with mechanisms for inter-process communication using message passing, provided by the Unix operating system. This creates a chain of processes in which the output of each process is passed directly as input to the subsequent one, as shown in the following example: In addition to the input/output standard streams, some of the tools accept parameterisation through the definition of arguments when executed. There is also a small set of tools in which the input or output does not make sense to be the standard streams and for those the argument definition is considered. 2.2 Software functionalities The toolkit contains three main groups of tools according to its characteristic: Genomics, Proteomics, and General purpose. The genomics group is subdivided in: FASTQ, FASTA, SEQ (genomic sequences); while the proteomics contains AA (amino acid); the general-purpose tools can be applied to any format sequence. 2.2.1 Genomics The toolkit allows data conversion between different formats namely FASTQ, FASTA and SEQ. It also provides features for filtering and randomising DNA sequences, as well as for analytic purposes followed by simulations of a generation and alteration nature. The SEQ cluster works directly with the DNA sequences without any standard format. These tools allow data extraction, summary, classification and mathematical operations in the field of information theory. Among many examples, which are better described in the supporting website and manual, the toolkit allows preparations of the reads, namely filtering and trimming, the automatic construction of nucleotide reference databases, and comparative genomics. 2.2.2 Proteomics The toolkit has a specific cluster of tools designed to group, compress, and analyse amino acid sequences. These tools allow proteomic analysis based on the amino acids properties, such as electric charge (positive and negative), uncharged side chains, hydrophobic side chains and special cases. The toolkit allows translation of codons into amino acids, permits finding approximate amino acid sequences and performing comparative proteomics analysis. 2.2.3 General purpose This set of tools is complementary to the genomics and proteomics tools, not being designed to work in a specific field, but to assist the pipelines composed of the previously described subsets. These tools provide operations in the symbolical domain, including reversion, segmentation, and permutation; while in the numerical domain they contain tools with low-pass filters (with multiple window types), sum, min and max operations over streams. 2.2.4 External tools External top-performing tools have been integrated in order to increase the variety of functionalities available. The tools integrated are the following: • fastp [4]: enables ultra-fast preprocessing and quality control of FASTQ files. • bfMEM [5]: detects maximal exact matches between a pair of genomes based on bloom filters and rolling hashs. • copMEM [6]: another tool for computing maximal exact matches in a pair of genomes. • qvz [7]: implements a lossy compression algorithm for storing quality scores associated with DNA sequencing. • minicom [8]: a compressor for short reads in FASTQ files that uses large k-minimisers to index the reads. • SPRING [9]: which is reference-free compression tool for FASTQ files. 3 Illustrative examples All the tools in the toolkit were tested with synthetic sequences aiming for individual validation. Therefore, the documented examples are easily replicable with the written tests. Besides applying these tools in controlled environments, the toolkit was also used in several research workflows both as a primary and auxiliary tool. Several complete workflows are available in the repository, under the pipelines folder while an extensive description of the tool can be found in the manual. Next, we include some pipeline examples. 3.1 Bi-directional complexity profiles A workflow example is the computation of bi-directional complexity profiles in any genomic or proteomic sequence [10]. These profiles can localise specific features in the sequences, namely low and high complexity sequences, inverted repeats regions, tandem duplications, among others. The construction of these profiles follows a pipeline formed of many transformations (e.g. reversing, segmenting, inverting) as well as the use of specific low-pass filters after data compression applications [11]. Fig. 1 depicts the complexity profiles of four human Herpesvirus whole genomes using the same scale, where redundant regions are highlighted in blue (below a Bps of one). GTO uses GeCo2 [12] and AC [13] compressors to estimate the local complexity of DNA and amino acid sequences, respectively. However, GTO is not limited to using these data compressors. For example, new models can be tested under this framework, namely with extended alphabets [14]. In general, any data compressor able to output local estimations can be used in the pipeline as an alternative [15]. Analogous to the complexity profiles for DNA sequences, an example using amino acid sequences is given in Fig. 2. This example depicts a bi-directional complexity profile for the largest human protein sequence, titin. Several regions with low complexity are usually associated with specific characteristics, namely loops [16]. 3.2 Rearrangements map generation Another example workflow is in the domain of comparative genomics, namely to map and visualise rearrangements. This workflow is completely automatic from the input of the sequences to the generation of an SVG image, with the associated and transformed regions corresponding to the rearrangements. The pipeline applies smash technology [17,18] for mapping the rearrangements using an alignment-free methodology [19]. To prove the efficiency of the mapping pipeline, we use another pipeline to generate two identical FASTA files with simulated rearrangements between them (gto_simulate_rearragements.sh). After, loading the two FASTA files into the mapping pipeline (gto_map_rearrangements.sh), the output is two files, one with the mapping positions and the other is an SVG image depicting the mapped positions as can be seen in Fig. 3. All the rearrangements have been efficiently mapped with GTO according to the ground truth ( < 1 s of computational time). Analogous to the rearrangements map pipeline, for mapping at proteomic level, we consider the NAV2 HUMAN Neuron navigator 2 and the neuron navigator 2 isoform X15 of Macaca mulatta proteins. Although there are many examples under the proteome evolution [20], these are protein sequences considering identical scale [21]. Additionally, we shuffled the Macaca mulatta proteins using a block size of 300 amino acids. Fig. 4 depicts the proteins map after running the pipeline (gto_map_rearrangements_proteins.sh). Despite a low level of dissimilarity of the sequences with an additional pseudo-random permutation of blocks of 300 symbols, all the regions have been efficiently mapped with GTO ( < 1 s of computational time). 3.3 Viral metagenomic identification A final workflow example is the full automatic metagenomic identification of viral (or any other) content in FASTQ reads. This includes the filtering and trimming of the reads, mapping, and sensitive identification of the most representative genomes, under a ranking of abundance. In this particular example, we generate a semi-synthetic viral dataset containing several real viruses with applied degrees of substitutions and block permutations shuffled with synthetic noisy DNA. This dataset is generated using the gto_create_viral_dataset.sh pipeline. The intention is to perform a metagenomic analysis on this dataset without informing the programme what organisms are contained in the sample since the programme needs to infer the results. Then, we compare the results with the ground truth. If the results are similar to the ground truth, then the methodology is validated. For the purpose, GTO uses falcon-meta technology [22,23] that relies on assembly-free and alignment-free comparison of each reference according to the whole reads. The dataset contains synthetic reads (uniform distribution) merged with the following viruses with the respective modifications: • B19V: two Parvovirus, one with 1% of editions and the other with permuted blocks of 500 bases (GID: AY386330.1); • HHV2: one human Herpesvirus 2 with permuted blocks of size 100 bases (GID: JN561323.2); • HHV3: one human Herpesvirus 3 (GID: X04370.1); • HHV4: two human Herpesvirus 4, one with permuted blocks of 300 bases (GID: DQ279927.1); • TTV: one human Torque teno virus with 5% of editions (GID: AB041963.1); • HPV: one human Papillomavirus with 5% of editions and permuted blocks of 300 bases (GID: MG921180.1). After merging all FASTA sequences, ART [24] was used to generate the paired end FASTQ reads. Meanwhile, another workflow example was used to create the viral database (gto_build_dbs.sh). Then, the pipeline (gto_metagenomics.sh) ran, obtaining the top output presented in Table 1. We can conclude that despite the noise, editions, and permutations applied to real data, all the viruses have been efficiently identified with GTO, including the exact genotype ( < 1.5 min of computational time). 4 Impact Many software application exist to analyse and manipulate sequencing data, namely fqtools [25], GALAXY [26], FASTX-Toolkit [27], SeqKit [28], GATK [29], among others. The fqtools is a suite of tools to view, manipulate and summarise FASTQ data [25]. This software was designed to work specifically with FASTQ files and can be easily integrated into our toolkit. However, the features existent in this software are similar to some of the ones that GTO has in the gto_fastq_* section. Both were written in C which in terms of performance could be similar. GALAXY, is an open and web-based scientific platform for analysing genomic data [30]. This platform integrates several specialised sets of tools, e.g. for manipulating FASTQ files [31]. In this web application, the FASTX-Toolkit was integrated, which is a collection of command-line tools to process FASTA and FASTQ files [27]. The available features in the FASTX-Toolkit are also similar to some of the GTO tools designed to preprocess the FASTA/FASTQ files, which are available in the gto_fastq_* and gto_fasta_* sections. As our goal always was to have an easy to use toolkit written in low-level programming languages and not a web interface, we cannot compare it with GALAXY. However, regarding the FASTX-Toolkit which was also written in C, it is possible to compare and combine it with some of the GTO’s features. The SeqKit is another toolkit used to process FASTA and FASTQ files and it is available for all major operating systems [28]. Comparing the performance and limitations of this toolkit with the fqtools and FASTX-Toolkit is easier than comparing them with GTO, mainly because these three toolkits were designed specifically to manipulate FASTA/FASTQ files. On the other hand, these functionalities are only a fraction of the features that we provide in GTO. The idea never was to create more tools to compete with the ones existing, but instead, aggregate them in order to obtain a more complete toolkit for genomics analysis. This idea of simplifying the development and aggregation of analysis tools for genomic manipulation and analysis is not new. Initially designed as a structured programming framework, the Genome Analysis Toolkit (GATK) is a set of bioinformatics tools for analysing high-throughput sequencing focused on variant discovering and genotyping [2]. The high performance of this toolkit is due to the required infrastructures that a personal computer cannot offer. This is an excellent toolkit that integrates Apache Spark for optimisation, but it is only possible to take advantage of this potential in cloud computing. The efficient performance from some of the presented tools as well as GTO’s tools is due to the use of low-level programming languages (e.g. C language). However, one limitation of this strategy, in which the performance is prioritised, is the lack of a graphical user interface. Moreover, to take full advantage from those tools, the end-users need to have basic shell script knowledge. Nevertheless, GTO combines specialised tools for analysis, simulation, compression, development, visualisation, and transformation of data. Therefore, we would like to highlight some important details that characterise this toolkit: • The toolkit aggregates different tools in order to build research pipelines to deal with very large data sets without losing performance due to its modular architecture. Adoption of standard streams to interconnect the tools improved data processing. Throughout this procedure, the disk read/write operations between tools have been removed by sending the output directly to the input of the next tool. • The toolkit can integrate external tools, besides the ones already available. As such, some specific tools that have already been evaluated and used outside this context were aggregated: – For compression purposes, the toolkit integrates GeCo2 [12], which along with HiRGC [32], iDoComp [33] and GDC2 [34] are considered to have some of the best performance for reference-free DNA compression [35]. Regarding the amino acid sequences, the toolkit uses the AC tool for lossless sequence compression. The performance of AC was compared in [36] to several general-purpose lossless compressors and several protein compressors using different proteomes and AC provides on average the best bit-rates. – Concernings simulation, GTO integrates XS [37] which is a FASTQ read simulation tool. Escalona et al. [38] reviewed 23 NGS simulation tools and XS stands out in relation to the others because it is the only one that does not need a reference sequence. – Additionally, we added a section in the toolkit specially designed for tools from other authors. This way, we simplify their integration and installation using GTO. Those were described in Section 2.2.4. • Finally, as briefly presented in Section 3, the toolkit can answer new genomics questions without the need to create new software. 5 Conclusions We contribute with GTO, a toolkit to unify research pipelines, composed of distinct tools aiming at efficient combinations of them towards specific workflows. GTO’s efficient performance is due to the use of low-level programming languages, which increases the processing speed and decreases the RAM of addressing genomics and proteomics data. The flexibility of this toolkit allows the end-user to quickly create new processing pipelines in the genomic and proteomic field as it was described in the examples provided in this manuscript. Declaration of Competing Interest The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper. Acknowledgements This work has received support from the NETDIAMOND, Portugal project (POCI-01-0145-FEDER-016385), co-funded by Centro 2020 program, Portugal 2020, European Union, and from the FCT - Foundation for Science and Technology, Portugal, in the context of the project UIDB/00127/2020. João Almeida is supported by FCT - Foundation for Science and Technology, Portugal (national funds), grant SFRH/BD/147837/2019. References [1] Mardis E.R. DNA sequencing technologies: 2006–2016 Nat Protoc 12 2 2017 213 E. R. Mardis, DNA sequencing technologies: 2006–2016, Nature Protocols 12 (2) (2017) 213. [2] Van der Auwera G.A. Carneiro M.O. Hartl C. Poplin R. Del Angel G. Levy-Moonshine A. From FASTQ data to high-confidence variant calls: the genome analysis toolkit best practices pipeline Curr Protoc Bioinform 43 1 2013 11.10.1-11.10.33 G. A. Van der Auwera, M. O. Carneiro, C. Hartl, R. Poplin, G. Del Angel, A. Levy-Moonshine, T. Jordan, K. Shakir, D. Roazen, J. Thibault, others,From FASTQ data to high-confidence variant calls: the genome analysis toolkit best practices pipeline, Current Protocols in Bioinformatics 43 (1) (2013) 11–10. [3] Kessner D. Chambers M. Burke R. Agus D. Mallick P. ProteoWizard: open source software for rapid proteomics tools development Bioinformatics 24 21 2008 2534 2536 D. Kessner, M. Chambers, R. Burke, D. Agus, P. Mallick, ProteoWizard: open source software for rapid proteomics tools development, Bioinformatics 24 (21) (2008) 2534–2536. [4] Chen S. Zhou Y. Chen Y. Gu J. Fastp: an ultra-fast all-in-one FASTQ preprocessor Bioinformatics 34 17 2018 i884 i890 S. Chen, Y. Zhou, Y. Chen, J. Gu, fastp: an ultra-fast all-in-one FASTQ preprocessor, Bioinformatics 34 (17) (2018) i884–i890. [5] Liu Y. Zhang L.Y. Li J. Fast detection of maximal exact matches via fixed sampling of query K-mers and Bloom filtering of index K-mers Bioinformatics 35 22 2019 4560 4567 Y. Liu, L. Y. Zhang, J. Li, Fast detection of maximal exact matches via fixed sampling of query K-mers and Bloom filtering of index K-mers, Bioinformatics 35 (22) (2019) 4560–4567. [6] Grabowski S. Bieniecki W. CopMEM: finding maximal exact matches via sampling both genomes Bioinformatics 35 4 2019 677 678 S. Grabowski, W. Bieniecki, copMEM: finding maximal exact matches via sampling both genomes, Bioinformatics 35 (4) (2019) 677–678. [7] Malysa G. Hernaez M. Ochoa I. Rao M. Ganesan K. Weissman T. QVZ: lossy compression of quality values Bioinformatics 31 19 2015 3122 3129 G. Malysa, M. Hernaez, I. Ochoa, M. Rao, K. Ganesan, T. Weissman, QVZ: lossy compression of quality values, Bioinformatics 31 (19) (2015) 3122–3129. [8] Liu Y. Yu Z. Dinger M.E. Li J. Index suffix–prefix overlaps by (w, k)-minimizer to generate long contigs for reads compression Bioinformatics 35 12 2019 2066 2074 Y. Liu, Z. Yu, M. E. Dinger, J. Li, Index suffix–prefix overlaps by (w, k)-minimizer to generate long contigs for reads compression, Bioinformatics 35 (12) (2019) 2066–2074. [9] Chandak S. Tatwawadi K. Ochoa I. Hernaez M. Weissman T. SPRING: a next-generation compressor for FASTQ data Bioinformatics 35 15 2019 2674 2676 S. Chandak, K. Tatwawadi, I. Ochoa, M. Hernaez, T. Weissman, SPRING: a next-generation compressor for FASTQ data, Bioinformatics 35 (15) (2019) 2674–2676. [10] Pinho A.J. Garcia S.P. Pratas D. Ferreira P.J. DNA sequences at a glance PLoS One 8 11 2013 e79922 A. J. Pinho, S. P. Garcia, D. Pratas, P. J. Ferreira, DNA sequences at a glance, PloS one 8 (11) (2013) e79922. [11] Pinho A.J. Pratas D. Ferreira P.J. Garcia S.P. Symbolic to numerical conversion of DNA sequences using finite-context models 2011 19th European signal processing conference 2011 IEEE 2024 2028 A. J. Pinho, D. Pratas, P. J. Ferreira, S. P. Garcia, Symbolic to numerical conversion of DNA sequences using finite-context models, in: 2011 19th European Signal Processing Conference, IEEE, 2011, 2024–2028. [12] Pratas D. Hosseini M. Pinho A.J. GeCo2: an optimized tool for lossless compression and analysis of DNA sequences International conference on practical applications of computational biology & bioinformatics 2019 Springer 137 145 D. Pratas, M. Hosseini, A. J. Pinho, GeCo2: an optimized tool for lossless compression and analysis of DNA sequences, in: International Conference on Practical Applications of Computational Biology & Bioinformatics, Springer, 2019, 137–145. [13] Hosseini M. Pratas D. Pinho A.J. AC: a compression tool for amino acid sequences Interdiscip Sci: Comput Life Sci 11 1 2019 68 76 M. Hosseini, D. Pratas, A. J. Pinho, AC: a compression tool for amino acid sequences, Interdisciplinary Sciences: Computational Life Sciences 11 (1) (2019) 68–76. [14] Carvalho J.M. Brás S. Pratas D. Ferreira J. Soares S.C. Pinho A.J. Extended-alphabet finite-context models Pattern Recognit Lett 112 2018 49 55 J. M. Carvalho, S. Brás, D. Pratas, J. Ferreira, S. C. Soares, A. J. Pinho, Extended-alphabet finite-context models, Pattern Recognition Letters 112 (2018) 49–55. [15] Hosseini M. Pratas D. Pinho A. A survey on data compression methods for biological sequences Information 7 4 2016 56 M. Hosseini, D. Pratas, A. Pinho, A survey on data compression methods for biological sequences, Information 7 (4) (2016) 56. [16] Agüero-Chapin G. González-Díaz H. Molina R. Varona-Santos J. Uriarte E. González-Díaz Y. Novel 2D maps and coupling numbers for protein sequences. The first QSAR study of polygalacturonases; isolation and prediction of a novel sequence from Psidium guajava L. FEBS Lett 580 3 2006 723 730 G. Agüero-Chapin, H. González-Díaz, R. Molina, J. Varona-Santos, E. Uriarte, Y. González-Díaz, Novel 2D maps and coupling numbers for protein sequences. The first QSAR study of polygalacturonases isolation and prediction of a novel sequence from Psidium guajava L., FEBS Letters 580 (3) (2006) 723–730. [17] Pratas D. Silva R.M. Pinho A.J. Ferreira P.J. An alignment-free method to find and visualise rearrangements between pairs of DNA sequences Sci Rep 5 2015 10203 D. Pratas, R. M. Silva, A. J. Pinho, P. J. Ferreira, An alignment-free method to find and visualise rearrangements between pairs of DNA sequences, Scientific Reports 5 (2015) 10203. [18] Hosseini M, Pratas D, Morgenstern B, Pinho AJ. Smash++: an alignment-free and memory-efficient tool to find genomic rearrangements. GigaScience 9(5). [19] Zielezinski A. Girgis H.Z. Bernard G. Leimeister C.-A. Tang K. Dencker T. Benchmarking of alignment-free sequence comparison methods 2019 BioRxiv A. Zielezinski, H. Z. Girgis, G. Bernard, C.-A. Leimeister, K. Tang, T. Dencker, A. K. Lau, S. Röhling, J. Choi, M. S. Waterman, others,Benchmarking of alignment-free sequence comparison methods, BioRxiv (2019) 611137. [20] Forslund S.K. Kaduk M. Sonnhammer E.L. Evolution of protein domain architectures Evolutionary genomics 2019 Springer 469 504 S. K. Forslund, M. Kaduk, E. L. Sonnhammer, Evolution of protein domain architectures, in: Evolutionary Genomics, Springer, 2019, 469–504. [21] Rost B. Twilight zone of protein sequence alignments Protein Eng 12 2 1999 85 94 B. Rost, Twilight zone of protein sequence alignments, Protein engineering 12 (2) (1999) 85–94. [22] Pratas D. Pinho A.J. Silva R.M. Rodrigues J.M. Hosseini M. Caetano T. FALCON: a method to infer metagenomic composition of ancient DNA 2018 BioRxiv D. Pratas, A. J. Pinho, R. M. Silva, J. M. Rodrigues, M. Hosseini, T. Caetano, P. J. Ferreira, FALCON: a method to infer metagenomic composition of ancient DNA, BioRxiv (2018) 267179. [23] Pratas D. Pinho A.J. Metagenomic composition analysis of sedimentary ancient DNA from the isle of wight 2018 26th european signal processing conference (EUSIPCO) 2018 IEEE 1177 1181 D. Pratas, A. J. Pinho, Metagenomic composition analysis of sedimentary ancient DNA from the Isle of Wight, in: 2018 26th European Signal Processing Conference (EUSIPCO), IEEE, 2018, 1177–1181. [24] Huang W. Li L. Myers J.R. Marth G.T. ART: a next-generation sequencing read simulator Bioinformatics 28 4 2011 593 594 W. Huang, L. Li, J. R. Myers, G. T. Marth, ART: a next-generation sequencing read simulator, Bioinformatics 28 (4) (2011) 593–594. [25] Droop A.P. Fqtools: an efficient software suite for modern FASTQ file manipulation Bioinformatics 32 12 2016 1883 1884 A. P. Droop, fqtools: an efficient software suite for modern FASTQ file manipulation, Bioinformatics 32 (12) (2016) 1883–1884. [26] Afgan E. Baker D. Batut B. Van Den Beek M. Bouvier D. Čech M. The galaxy platform for accessible, reproducible and collaborative biomedical analyses: 2018 update Nucleic Acids Res 46 W1 2018 W537 W544 E. Afgan, D. Baker, B. Batut, M. Van Den Beek, D. Bouvier, M. Čech, J. Chilton, D. Clements, N. Coraor, B. A. Grüning, others,The Galaxy platform for accessible, reproducible and collaborative biomedical analyses: 2018 update, Nucleic acids research 46 (W1) (2018) W537–W544. [27] Gordon A, Hannon G et al. Fastx-toolkit, FASTQ/A short-reads preprocessing tools Accessed: 2020-06-17. [28] Shen W. Le S. Li Y. Hu F. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation PLoS One 11 10 2016 e0163962 W. Shen, S. Le, Y. Li, F. Hu, SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation, PLoS One 11 (10) (2016) e0163962. [29] DePristo M.A. Banks E. Poplin R. Garimella K.V. Maguire J.R. Hartl C. A framework for variation discovery and genotyping using next-generation DNA sequencing data Nature Genet 43 5 2011 491 M. A. DePristo, E. Banks, R. Poplin, K. V. Garimella, J. R. Maguire, C. Hartl, A. A. Philippakis, G. Del Angel, M. A. Rivas, M. Hanna, others,A framework for variation discovery and genotyping using next-generation DNA sequencing data, Nature Genetics 43 (5) (2011) 491. [30] Goecks J. Nekrutenko A. Taylor J. Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences Genome Biol 11 8 2010 R86 J. Goecks, A. Nekrutenko, J. Taylor, Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences, Genome Biology 11 (8) (2010) R86. [31] Blankenberg D. Gordon A. Von Kuster G. Coraor N. Taylor J. Nekrutenko A. Manipulation of FASTQ data with galaxy Bioinformatics 26 14 2010 1783 1785 D. Blankenberg, A. Gordon, G. Von Kuster, N. Coraor, J. Taylor, A. Nekrutenko, G. Team, Manipulation of FASTQ data with Galaxy, Bioinformatics 26 (14) (2010) 1783–1785. [32] Liu Y. Peng H. Wong L. Li J. High-speed and high-ratio referential genome compression Bioinformatics 33 21 2017 3364 3372 Y. Liu, H. Peng, L. Wong, J. Li, High-speed and high-ratio referential genome compression, Bioinformatics 33 (21) (2017) 3364–3372. [33] Ochoa I. Hernaez M. Weissman T. iDoComp: a compression scheme for assembled genomes Bioinformatics 31 5 2014 626 633 I. Ochoa, M. Hernaez, T. Weissman, iDoComp: a compression scheme for assembled genomes, Bioinformatics 31 (5) (2014) 626–633. [34] Deorowicz S. Danek A. Niemiec M. GDC 2: Compression of large collections of genomes Sci Rep 5 2015 11565 S. Deorowicz, A. Danek, M. Niemiec, GDC 2: Compression of large collections of genomes, Scientific Reports 5 (2015) 11565. [35] Hernaez M, Pavlichin D, Weissman T, Ochoa I. Genomic data compression. Annu Rev Biomed Data Sci 2. [36] Pratas D. Hosseini M. Pinho A.J. Compression of amino acid sequences International conference on practical applications of computational biology & bioinformatics 2018 Springer 105 113 D. Pratas, M. Hosseini, A. J. Pinho, Compression of amino acid sequences, in: International Conference on Practical Applications of Computational Biology & Bioinformatics, Springer, 2018, 105–113. [37] Pratas D. Pinho A.J. Rodrigues J.M. XS: a FASTQ read simulator BMC Res Notes 7 1 2014 40 D. Pratas, A. J. Pinho, J. M. Rodrigues, XS: a FASTQ read simulator, BMC Research Notes 7 (1) (2014) 40. [38] Escalona M. Rocha S. Posada D. A comparison of tools for the simulation of genomic next-generation sequencing data Nature Rev Genet 17 8 2016 459 M. Escalona, S. Rocha, D. Posada, A comparison of tools for the simulation of genomic next-generation sequencing data, Nature Reviews Genetics 17 (8) (2016) 459. "
    },
    {
        "doc_title": "File Forgery Detection Using a Weighted Rule-Based System",
        "doc_scopus_id": "85092163560",
        "doc_doi": "10.1007/978-3-030-58219-7_8",
        "doc_eid": "2-s2.0-85092163560",
        "doc_date": "2020-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Automated systems",
            "Computational solutions",
            "Digital datas",
            "Forgery detections",
            "Robust methods",
            "Security breaches",
            "Weighted rules"
        ],
        "doc_abstract": "© 2020, Springer Nature Switzerland AG.The society is becoming increasingly dependent on digital data sources. However, our trust on the sources and its contents is only ensured if we can also rely on robust methods that prevent fraudulent forgery. As digital forensic experts are continually dealing with the detection of forged data, new fraudulent approaches are emerging, making it difficult to use automated systems. This security breach is also a good challenge that motivates researchers to explore computational solutions to efficiently address the problem. This paper describes a weighted rule-based system for file forgery detection. The system was developed and validated in the several tasks of ImageCLEFsecurity 2019 track challenge, where promising results were obtained.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "MIP model-based heuristics for the minimum weighted tree reconstruction problem",
        "doc_scopus_id": "85092154724",
        "doc_doi": "10.1007/s12351-020-00608-z",
        "doc_eid": "2-s2.0-85092154724",
        "doc_date": "2020-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Numerical Analysis",
                "area_abbreviation": "MATH",
                "area_code": "2612"
            },
            {
                "area_name": "Modeling and Simulation",
                "area_abbreviation": "MATH",
                "area_code": "2611"
            },
            {
                "area_name": "Strategy and Management",
                "area_abbreviation": "BUSI",
                "area_code": "1408"
            },
            {
                "area_name": "Statistics, Probability and Uncertainty",
                "area_abbreviation": "DECI",
                "area_code": "1804"
            },
            {
                "area_name": "Management Science and Operations Research",
                "area_abbreviation": "DECI",
                "area_code": "1803"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Management of Technology and Innovation",
                "area_abbreviation": "BUSI",
                "area_code": "1405"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2020, Springer-Verlag GmbH Germany, part of Springer Nature.We consider the minimum weighted tree reconstruction (MWTR) problem and two matheuristic methods to obtain optimal or near-optimal solutions: the Feasibility Pump heuristic and the Local Branching heuristic.These matheuristics are based on a Mixed Integer Programming model used to find feasible solutions. We discuss the applicability and effectiveness of the matheuristics to obtain solutions to the MWTR problem. The purpose of the MWTR problem is to find a minimum weighted tree connecting a set of leaves in such a way that the length of the path between each pair of leaves is greater than or equal to a given distance between the considered pair of leaves. The Feasibility Pump matheuristic starts with the Linear Programming solution, iteratively fixes the values of some variables and solves the corresponding problem until a feasible solution is achieved. The Local Branching matheuristic, in its turn, improves a feasible solution by using a local search. Computational results using two different sets of instances, one from the phylogenetic area and another from the telecommunications area, show that these matheuristics are quite effective in finding feasible solutions and present small gap values. Each matheuristic can be used independently; however, the best results are obtained when used together. For instances of the problem having up to 17 leaves, the feasible solution obtained by the Feasibility Pump heuristic is improved by the Local Branching heuristic. Noticeably, when comparing with existing based models processes that solve instances having up to 15 leaves, this achievement of the matheuristic increases the size of solved instances.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A computational platform for heart failure cases research",
        "doc_scopus_id": "85083723599",
        "doc_doi": null,
        "doc_eid": "2-s2.0-85083723599",
        "doc_date": "2020-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Biomedical Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2204"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Computational platforms",
            "Computational system",
            "Different stages",
            "Efficient treatment",
            "Ejection fraction",
            "Genomic information",
            "Health informations",
            "Therapeutic targets"
        ],
        "doc_abstract": "© 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.Heart failure is a global health issue that affects millions of people worldwide, and is the main cause of disability and hospitalisation of elderly people. Approximately half of these have heart failure with preserved ejection fraction (HFpEF) and this proportion is increasing as the population ages. There is still no efficient treatment for HFpEF and today's existing therapies only aim at relieving symptoms. With the aim to unravelling the pathophysiology of HFpEF and identify new therapeutic targets, ongoing long-time studies are collecting patient's data, including the genomic information. This procedure is complex and requires electronically-stored health information to keep the patient's information centralised to simplify the following up. In this paper, we present an computational system to support researchers in the different stages of a clinical study, and we describe its use in the management and analyse of HFpEF cohorts.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Exploring the Value of Electronic Health Records from Multiple Datasets",
        "doc_scopus_id": "85071693378",
        "doc_doi": "10.1007/978-3-030-29196-9_19",
        "doc_eid": "2-s2.0-85071693378",
        "doc_date": "2019-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Mathematics (all)",
                "area_abbreviation": "MATH",
                "area_code": "2600"
            }
        ],
        "doc_keywords": [
            "Data interoperability",
            "Electronic health record",
            "Medical information",
            "Multiple data sets",
            "Observational data",
            "Observational study",
            "Privacy and security",
            "Secondary use"
        ],
        "doc_abstract": "© 2019, Springer Nature Switzerland AG.During the last decades, most European countries dedicated huge efforts in collecting and maintaining Electronic Health Records (EHR). With the continuous grow of these datasets, it became obvious that its secondary use for research may lead to new insights about diseases and treatments outcomes. EHR databases can be used to speed up and reduce the cost of health research studies, which are essential for the advance and improvement of health services. However, many times, a single observational data source is not enough for a clinical study, thus data interoperability has a major impact on the exploration of value of EHRs. Despite the recognized benefit of data sharing, database owners remain reluctant in conceding access to the contents of their databases, mainly due to ownership, privacy and security issues. In this paper, we exploit two major international initiatives, the European Medical Information Framework (EMIF) and the Observational Health Data Sciences and Informatics (OHDSI), to provide a methodology through which multiple longitudinal clinical repositories can be queried, without the data leaving its original repository.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A weighted rule-based model for file forgery detection: UA.Pt bioinformatics at ImageCLef 2019",
        "doc_scopus_id": "85070502485",
        "doc_doi": null,
        "doc_eid": "2-s2.0-85070502485",
        "doc_date": "2019-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Computational solutions",
            "Digital technologies",
            "Forgery detections",
            "ImageCLEF",
            "Poor performance",
            "Random forest algorithm",
            "Rule-based models",
            "Weighted rules"
        ],
        "doc_abstract": "Copyright © 2019 for this paper by its authors.With today's digital technology, disparate kinds of data can be easily manipulated. The forgery commonly hides information, by altering files' extensions, files' signatures, or by using steganography. Consequently, digital forensic examiners are faced with new problems in the detection of these forged files. The lack of automatised approaches to discover these infractions encourages researchers to explore new computational solutions that can help its identification. This paper describes the methodologies used in the ImageCLEFsecurity 2019 challenge, which were mainly rule-based models. The rules and all of their underlying mechanisms created for each task are described. For the third task, was used a random forest algorithm due to the poor performance of these rules.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Strategies to access patient clinical data from distributed databases",
        "doc_scopus_id": "85064615496",
        "doc_doi": "10.5220/0007576104660473",
        "doc_eid": "2-s2.0-85064615496",
        "doc_date": "2019-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Biomedical Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2204"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Common data model",
            "Distributed database",
            "Distributed query",
            "Electronic health record",
            "Electronic health record systems",
            "Health services",
            "Observational study",
            "Privacy and security"
        ],
        "doc_abstract": "© 2019 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.Over the last twenty years, the use of electronic health record systems has become widespread worldwide, leading to the creation of an extensive collection of health databases. These databases can be used to speed up and reduce the cost of health research studies, which are essential for the advance of health science and the improvement of health services. However, despite the recognised gain of data sharing, database owners remain reluctant to grant access to the contents of their databases because of privacy and security issues, and because of the lack of a common strategy for data sharing. Two main approaches have been used to perform distributed queries while maintaining all data control in the hands of the data custodians: applying a common data model, or using Semantic Web principles. This paper presents a comparison of these two approaches by evaluating them according to parameters relevant to data integration, such as cost, data quality, interoperability, extendibility, consistency, and efficiency.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A methodology to perform semi-automatic distributed EHR database queries",
        "doc_scopus_id": "85051747869",
        "doc_doi": "10.5220/0006579701270134",
        "doc_eid": "2-s2.0-85051747869",
        "doc_date": "2018-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Biomedical Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2204"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Health Informatics",
                "area_abbreviation": "MEDI",
                "area_code": "2718"
            },
            {
                "area_name": "Health Information Management",
                "area_abbreviation": "HEAL",
                "area_code": "3605"
            }
        ],
        "doc_keywords": [
            "Clinical data",
            "Database queries",
            "Digital datas",
            "Electronic health",
            "Electronic health record (EHRs)",
            "Pharmaceutical research",
            "Semi-automatics",
            "Social issues"
        ],
        "doc_abstract": "Copyright © 2018 by SCITEPRESS – Science and Technology Publications, Lda. All rights reserved.The proliferation of electronic health databases has resulted in the existence of a wide collection of diversified clinical digital data. These data are fragmented over dispersed databases in different clinical silos around the world. The exploration of these electronic health records (EHRs) is essential for clinical and pharmaceutical research and, therefore, solutions for secure sharing of information across different databases are needed. Although several partial solutions have been proposed over the years, data sharing and integration has been hindered by many ethical, legal and social issues. In this paper, we present a methodology to perform semiautomatic queries over longitudinal clinical data repositories, where every data custodian maintains full control of data.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Compact mixed integer linear programming models to the minimum weighted tree reconstruction problem",
        "doc_scopus_id": "84990232272",
        "doc_doi": "10.1016/j.ejor.2016.06.014",
        "doc_eid": "2-s2.0-84990232272",
        "doc_date": "2017-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Modeling and Simulation",
                "area_abbreviation": "MATH",
                "area_code": "2611"
            },
            {
                "area_name": "Management Science and Operations Research",
                "area_abbreviation": "DECI",
                "area_code": "1803"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "Minimum evolution",
            "Mixed integer linear programming",
            "Routing topology inferences",
            "Topology discovery",
            "Tree realization"
        ],
        "doc_abstract": "© 2016 Elsevier B.V.The Minimum Weighted Tree Reconstruction (MWTR) problem consists of finding a minimum length weighted tree connecting a set of terminal nodes in such a way that the length of the path between each pair of terminal nodes is greater than or equal to a given distance between the considered pair of terminal nodes. This problem has applications in several areas, namely, the inference of phylogenetic trees, the modeling of traffic networks and the analysis of internet infrastructures. In this paper, we investigate the MWTR problem and we present two compact mixed-integer linear programming models to solve the problem. Computational results using two different sets of instances, one from the phylogenetic area and another from the telecommunications area, show that the best of the two models is able to solve instances of the problem having up to 15 terminal nodes.",
        "available": true,
        "clean_text": "serial JL 271700 291210 291692 291715 291813 291814 291817 291871 31 European Journal of Operational Research EUROPEANJOURNALOPERATIONALRESEARCH 2016-06-14 2016-06-14 2016-09-01 2016-09-01 2019-10-29T12:20:48 S0377-2217(16)30434-9 S0377221716304349 10.1016/j.ejor.2016.06.014 S300 S300.1 FULL-TEXT 2019-11-01T08:48:02.675056Z 0 0 20170101 2017 2016-06-14T06:28:57.073489Z articleinfo articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids contenttype copyright crossmark dateloaded dateloadedtxt datesearch datesort dateupdated dco docsubtype doctype doi eid ewtransactionid hubeid indexeddate issfirst issn issnnorm issuelist itemstage itemtransactionid itemweight openaccess openarchive pg pgfirst pglast pii piinorm pubdatestart pubdatetxt pubyr sectiontitle sortorder srctitle srctitlenorm srctype ssids alllist content subj subheadings tomb volfirst volissue volumelist yearnav figure table body mmlmath acknowledge affil articletitle auth authfirstini authfull authkeywords authlast highlightsabst orcid primabst pubtype ref 0377-2217 03772217 true 256 256 1 1 Volume 256, Issue 1 24 242 251 242 251 20170101 1 January 2017 2017-01-01 2017 Innovative Applications of O.R. article fla © 2016 Elsevier B.V. All rights reserved. COMPACTMIXEDINTEGERLINEARPROGRAMMINGMODELSMINIMUMWEIGHTEDTREERECONSTRUCTIONPROBLEM FORTZ B 1 Introduction 2 Formulations 2.1 Path-weight formulation 2.2 Path-edges formulation 3 Computational results 4 Conclusion Acknowledgments References ABDI 1990 43 59 H TREESHIERARCHICALSTRUCTURES ADDITIVETREEREPRESENTATIONS BHAMIDI 2010 176 203 S BUNEMAN 1974 48 50 P BYUN 2006 1189 1198 S COMPUTATIONALSCIENCEAPPLICATIONSICCSA2006 REDUCINGDELIVERYDELAYINHRMTREE CATANZARO 2009 112 125 D CATANZARO 2015 753 765 D CATANZARO 2009 126 140 D CATANZARO 2012 276 294 D CAVALLISFORZA 1967 233 257 L CHUNG 2001 432 448 F COATES 2002 11 20 M ACMSIGMETRICSPERFORMANCEEVALUATIONREVIEW MAXIMUMLIKELIHOODNETWORKTOPOLOGYIDENTIFICATIONEDGEBASEDUNICASTMEASUREMENTS COATES 2003 192 203 M PROCEEDINGS3RDACMSIGCOMMCONFERENCEINTERNETMEASUREMENTIMC03 MERGINGLOGICALTOPOLOGIESUSINGENDTOENDMEASUREMENTS CORTER 1986 429 451 J CUNNINGHAM 1980 593 605 J DAY 1987 461 467 W DIAS 2012 774 788 Z DONNET 2013 44 81 B DATATRAFFICMONITORINGANALYSISMEASUREMENTCLASSIFICATIONANOMALYDETECTIONQUALITYEXPERIENCE INTERNETTOPOLOGYDISCOVERY DONNET 2007 2 14 B DONNET 2006 2210 2220 B DRESS 1984 321 402 A DUFFIELD 2002 26 45 N DUFFIELD 2001 1636 1645 N INFOCOM2001TWENTIETHANNUALJOINTCONFERENCEIEEECOMPUTERCOMMUNICATIONSSOCIETIESPROCEEDINGSIEEEVOLUME3 ADAPTIVEMULTICASTTOPOLOGYINFERENCE EDELBERG 1976 23 39 M ERIKSSON 2010 1 9 B PROCEEDINGSINFOCOM2010IEEECONFERENCECOMPUTERCOMMUNICATIONS TOWARDPRACTICALUSENETWORKTOMOGRAPHYFORINTERNETTOPOLOGYDISCOVERY FARACH 1995 155 179 M FELSENSTEIN 2004 147 175 J INFERRINGPHYLOGENIESCHAPTER11 DISTANCEMATRIXMETHODS FIORINI 2012 31 35 S GASCHEN 2002 2354 2360 B GILMORE 1979 425 431 G GOUVEIA 1995 959 970 L GOUVEIA 1996 178 190 L GOVINDAN 2000 1371 1380 R PROCEEDING19THANNUALJOINTCONFERENCEIEEECOMPUTERCOMMUNICATIONSSOCIETIESVOLUME3 HEURISTICFORINTERNETMAPDISCOVERY HADDADI 2008 48 69 H HAKIMI 1972 255 269 S HAKIMI 1965 305 317 S HUSON 2011 23 35 D ISAEV 2006 A INTRODUCTIONMATHEMATICALMETHODSINBIOINFORMATICS JUNKER 2008 B ANALYSISBIOLOGICALNETWORKS KOOLEN 2009 1164 1171 A MAGNANTI 1995 503 615 T NETWORKMODELSHANDBOOKSINOPERATIONSRESEARCHMANAGEMENTSCIENCEVOL7 OPTIMALTREES MILLER 1960 326 329 C MOUNT 2001 D BIOINFORMATICSSEQUENCEGENOMEANALYSIS NEI 2000 M MOLECULAREVOLUTIONPHYLOGENETICS NI 2011 7798 7809 J NI 2008 J INFOCOM200827THIEEECONFERENCECOMPUTERCOMMUNICATIONS NETWORKROUTINGTOPOLOGYINFERENCEENDTOENDMEASUREMENTS PARKER 1996 1875 1905 D PAUPLIN 2000 41 47 Y SATTATH 1977 319 345 S SHIH 2007 1708 1718 M SIMOESPEREIRA 1987 277 287 J SIMOESPEREIRA 1990 299 312 J SIMOESPEREIRA 1982 1 17 J SOETE 1983 621 626 G VARONE 1998 337 346 S VARONE 2006 102 111 S FORTZX2017X242 FORTZX2017X242X251 FORTZX2017X242XB FORTZX2017X242X251XB 2018-09-01T00:00:00Z © 2016 Elsevier B.V. All rights reserved. 2019-03-25T13:40:25.896Z S0377221716304349 Belgian Science Policy Office Belgian Federal Science Policy Office Portuguese Foundation for Science and Technology UID/MAT/04106/2013 SFRH/BD/76268/2011 FCT FCT Fuel Cell Technologies Program CIDMA Portuguese Interuniversity Attraction Poles Programme P7/36 Center for Research and Development in Mathematics and Applications The research of Cristina Requejo and Olga Oliveira has been partially supported by Portuguese funds through the Center for Research and Development in Mathematics and Applications (CIDMA) and the FCT, the Portuguese Foundation for Science and Technology, within project UID/MAT/04106/2013. The research of Olga Oliveira has been supported by a research fellowship (grant SFRH/BD/76268/2011) through FCT, the Portuguese Foundation for Science and Technology, within the project POPH-QREN. The research of Bernard Fortz and Olga Oliveira has been funded by the Interuniversity Attraction Poles Programme P7/36 COMEX initiated by the Belgian Science Policy Office. item S0377-2217(16)30434-9 S0377221716304349 10.1016/j.ejor.2016.06.014 271700 2019-11-01T08:48:02.675056Z 2017-01-01 true 741485 MAIN 10 61525 849 656 IMAGE-WEB-PDF 1 gr1 5431 86 219 gr2 7033 100 219 gr3 5275 44 219 gr4 4952 38 219 gr5 9380 126 219 gr1 15354 180 461 gr2 7106 73 160 gr3 11713 69 342 gr4 21587 113 658 gr5 22255 221 384 si10 253 24 22 si20 258 13 52 si30 279 16 68 si40 755 51 165 si50 1578 19 516 si60 540 22 118 si70 214 25 21 si80 1055 43 248 si90 505 16 142 si100 453 16 154 si110 514 24 118 si13 1586 19 421 si14 389 18 72 si15 370 18 67 si16 387 18 72 si17 2226 48 464 si18 376 14 92 si19 284 15 64 si2 387 16 88 si21 472 16 153 si22 569 16 194 si23 201 21 23 si24 183 13 43 si25 199 21 23 si26 349 21 93 si27 861 21 292 si28 293 21 79 si29 227 21 46 si3 389 15 98 si31 418 21 150 si32 596 45 97 si33 424 16 119 si34 1240 44 351 si35 1208 44 317 si36 223 25 21 si37 804 50 132 si38 825 50 157 si39 1079 51 237 si4 206 13 45 si41 940 18 342 si42 960 51 184 si43 794 43 166 si44 1604 51 346 si45 1338 24 412 si46 753 19 217 si47 905 18 285 si48 1041 19 314 si49 1257 19 406 si5 559 24 123 si51 1588 19 516 si52 1595 19 517 si53 1591 19 517 si54 1542 19 514 si55 1552 19 514 si56 971 19 294 si57 1240 24 379 si58 866 19 267 si59 689 19 213 si6 874 18 225 si61 531 24 124 si62 1123 23 316 si63 816 22 212 si64 836 22 211 si65 1123 22 279 si66 251 25 28 si67 588 16 179 si68 237 25 23 si69 1310 27 330 si7 400 16 88 si71 280 25 31 si72 1308 65 225 si73 826 51 157 si74 728 43 159 si75 1082 51 231 si76 934 18 334 si77 497 44 88 si78 605 44 116 si79 771 44 151 si8 271 15 60 si81 1973 44 488 si82 1059 43 248 si83 2052 43 529 si84 1438 24 432 si85 1027 56 235 si86 1858 66 376 si87 1348 24 430 si88 1588 24 449 si89 287 16 57 si9 409 24 73 si91 263 25 26 si92 238 22 25 si93 2368 79 380 si94 488 27 78 si95 1350 66 254 si96 1876 66 349 si97 2642 113 354 si98 864 51 130 si99 2256 110 293 si101 238 16 56 si102 226 13 52 si103 220 13 51 si104 202 16 47 si105 1032 29 234 si106 568 27 117 si107 791 23 169 si108 859 23 183 si109 255 13 56 si11 820 26 172 si111 1504 31 378 si112 227 13 46 si113 124 18 17 si114 227 14 46 si115 225 16 51 si116 256 16 60 si12 216 13 44 si1 64 9 11 EOR 13766 S0377-2217(16)30434-9 10.1016/j.ejor.2016.06.014 Elsevier B.V. Fig. 1 A distance matrix and its graph realization. Fig. 1 Fig. 2 A possible topology for a tree with 4 terminal nodes. Fig. 2 Fig. 3 A caterpillar tree. A possible topology for a tree with 8 terminal nodes. Fig. 3 Fig. 4 Two balanced trees. On the left, a possible topology for a tree with 7 terminal nodes. On the right, a possible topology for a tree with 8 terminal nodes. Fig. 4 Fig. 5 Performance profile. Fig. 5 Table 1 Computational results for data from the phylogenetics application. Table 1 Matrix |Vt | Path-weight formulation Path-edges formulation Path-edges + formulation PL4 T W GAP LB T DZ GAP GAP LB T w W T DZ GAP GAP LB T w W T DZ GAP GAP LB M391 5 0.219 0.0486 0 0.109 0.0473 31.52 0 0 0.0486 0 0.0473 0 0 0.031 0.0487 0.577 0.0473 0 0 6 0.499 0.0583 0 0.499 0.057 58.78 0 0.016 0.0591 0.078 0.057 0.34 0 0.031 0.0591 33.243 0.057 0.08 0 7 2.278 0.0626 0 2.793 0.0607 73.4 0 0.015 0.0634 1.919 0.0607 0.69 0 0.031 0.0634 328.021 0.0607 0.37 0 8 73.975 0.0693 0 58.141 0.0672 82.69 0 0.063 0.0698 6.49 0.0672 0.75 0 0.109 0.0698 >7200 – – – 9 1003.18 0.0948 0 735.182 0.0923 90.14 0 0.14 0.0951 20.155 0.0923 0.6 0 0.172 0.0951 >7200 – – – 10 >7200 0.1061 60.77 >7200 0.1027 94.29 36.08 0.655 0.1068 728.225 0.1027 1.04 0 7.691 0.1068 >7200 – – – 11 >7200 0.1326 83.44 >7200 0.1289 96.78 59.67 18.658 0.134 2675.67 0.1276 1.18 0 14.929 0.1337 >7200 – – – 12 >7200 0.1386 – >7200 0.1377 98.21 95.64 33.509 0.1449 >7200 1.322 1.21 0.84 77.532 0.1378 >7200 – – – 13 >7200 0.1555 – >7200 0.1537 98.98 98.18 59.075 0.1658 >7200 0.1445 1.8 1.73 63.882 0.1523 >7200 – – – 14 >7200 0.1607 – >7200 0.1603 99.42 99.1 108.95 0.1711 >7200 0.1481 2.34 2.27 306.4 0.1562 >7200 – – – 15 >7200 0.1733 – >7200 0.1694 99.66 99.65 278.866 0.1813 >7200 0.156 3.82 3.75 417.815 0.1647 >7200 – – – Primate 5 0.25 0.843 0 0.218 0.0823 31.91 0 0 0.0843 0 0.0823 0 0 0 0.0843 1.42 0.0823 0 0 6 0.531 0.1059 0 0.452 0.1023 61.19 0 0.016 0.1059 0.031 0.1023 0 0 0.032 0.1059 67.907 0.1023 0 0 7 1.841 0.1272 0 1.732 0.1232 72.54 0 0.031 0.1272 0.406 0.1232 0.37 0 0.046 0.1272 507.906 0.1232 0 0 8 25.943 0.128 0 23.041 0.1229 80.3 0 0.063 0.128 2.294 0.1229 0.38 0 0.094 0.128 >7200 – – – 9 228.697 0.1296 0 211.802 0.1246 87.11 0 0.14 0.1296 17.768 0.1246 3.03 0 0.188 0.1296 >7200 – – – 10 >7200 0.1297 6.5 >7200 0.122 91.98 10.62 0.531 0.1298 107.593 0.122 2.45 0 19.16 0.1298 >7200 – – – 11 >7200 0.17 72.41 >7200 0.1652 95.88 52.35 15.787 0.1762 1.356.95 0.1625 2.3 0 34.413 0.17 >7200 – – – 12 >7200 0.2076 96.68 >7200 0.2019 97.62 76.03 29.125 0.212 >7200 0.1959 2.23 1.54 75.426 0.2058 >7200 – – – M887 5 0.219 0.1033 0 0.218 0.0972 29.56 0 0 0.1033 0 0.0971 0 0 0 0.1033 0.125 0.0972 0 0 6 0.499 0.1157 0 0.546 0.1098 57.62 0 0.015 0.1201 0.5 0.1098 1.88 0 0.078 0.1201 64.788 0.1098 0.42 0 7 2.121 0.1364 0 1.965 0.1292 71.56 0 0.016 0.1364 1.263 0.1292 1.52 0 0.047 0.1364 608.917 0.1292 0 0 8 63.945 0.1756 0 41.917 0.1619 82.73 0 0.063 0.1763 5.975 0.1619 1.52 0 0.094 0.1763 >7200 0.188 14.14 14.01 9 742.375 0.1823 0 487.235 0.1685 89.37 0 0.125 0.186 24.102 0.1685 1.7 0 0.172 0.186 >7200 – – – 10 >7200 0.2026 50.69 >7200 0.1859 93.75 30.69 0.609 0.2059 220.412 0.1859 2.11 0 18.954 0.2059 >7200 – – – 11 >7200 0.2113 81.2 >7200 0.196 96.50 0 60.25 0.2168 1960.88 0.1938 2.57 0 15.038 0.2135 >7200 – – – 12 >7200 0.2184 – >7200 0.2058 98.95 94.65 33.041 0.2259 >7200 0.1967 2.71 2.59 72.961 0.2179 >7200 – – – 13 >7200 0.2395 – >7200 0.2292 98.94 97.84 56.098 0.2562 >7200 0.2172 4.4 4.31 146.999 0.238 >7200 – – – 14 >7200 0.2512 – >7200 0.2519 99.45 99.09 136.344 0.2829 >7200 0.2304 8.1 8.03 252.018 0.2543 >7200 – – – 15 >7200 0.2787 – >7200 0.2602 99.66 99.65 207.262 0.2922 >7200 0.2664 14.34 14.29 953.521 0.304 >7200 – – – Table 2 Computational results for data from the networking application. Table 2 Matrix |Vt | Path-weight formulation Path-edges formulation Path-edges + formulation PL4 T W GAP LB T DZ GAP GAP LB T w W T DZ GAP GAP LB T w W T DZ GAP GAP LB Sim7 5 0.22 0.4043 0 0.296 0.4043 28.13 0 0 0.4043 0.016 0.4043 0 0 0.015 0.4043 0.16 0.4043 0 0 6 0.28 0.4348 0 0.858 0.4347 49.88 0 0 0.4348 0.031 0.4347 0 0 0.296 0.4348 23.845 0.4347 0 0 7 1.872 0.5055 0 2.808 0.5054 67.91 0 0.031 0.5055 0.047 0.5054 0 0 0.031 0.5055 4181.93 0.5054 0 0 Sim15 5 0.3 0.1893 0 0.515 0.1893 34.45 0 0 0.1893 0 0.1893 0 0 0.015 0.1893 0.124 0.1893 0 0 6 0.26 0.2756 0 1.138 0.2756 57.34 0 0.016 0.2756 0.047 0.2756 0 0 0.015 0.2756 118.092 0.2756 0 0 7 1.286 0.3013 0 1.748 0.3016 66.47 0 0.016 0.3013 0.53 0.3013 1.55 0 0.047 0.3013 8.056 0.3013 0 0 8 31.692 0.3778 0 18.189 0.3778 79.30 0 0.063 0.3778 9.672 0.3778 2.69 0 0.125 0.3778 >7200 – – – 9 309.517 0.3932 0 122.663 0.3932 86.48 0 0.156 0.3932 13.307 0.3932 2.61 0 0.203 0.3932 >7200 – – – 10 >7200 0.4286 33.44 4726.98 0.4286 91.81 0 0.406 0.4286 155.048 0.4286 3.16 0 18.58 0.4286 >7200 – – – 11 >7200 0.626 60.31 >7200 0.626 95.94 51.79 13.478 0.626 1625.24 0.626 2.22 0 32.926 0.626 >7200 – – – 12 >7200 0.722 94.74 >7200 0.727 97.64 94.99 30.311 0.7322 >7200 0.722 1.93 1.73 67.579 0.722 >7200 – – – 13 >7200 0.8085 – >7200 0.7918 98.54 97.44 38.142 0.8188 >7200 0.7474 7.09 2.45 82.571 0.7474 >7200 – – – 14 >7200 0.8845 – >7200 0.9796 99.26 98.82 146.531 1.0875 >7200 0.8335 14.16 12.65 281.939 0.8742 >7200 – – – 15 >7200 0.9804 – >7200 1.1557 99.61 99.37 172.099 1.2949 >7200 0.9859 15.31 14.72 823.027 1.0418 >7200 – – – Sim20 5 0.203 0.299 0 0.328 0.299 0 0 0 0.299 0 0.299 0 0 0 0.299 0.109 0.299 0 0 6 0.187 0.3394 0 0.796 0.3394 57.39 0 0.015 0.3394 0.031 0.3394 0 0 0.031 0.3394 0.842 0.3394 0 0 7 1.825 0.3751 0 1.747 0.3751 70.65 0 0.31 0.3751 0.14 0.3751 3.72 0 0.031 0.3751 8.973 0.3751 3.24 0 8 46.722 0.4564 0 31.496 0.4564 81.78 0 0.078 0.4564 8.112 0.4564 3.53 0 0.094 0.4564 >7200 – – – 9 581.085 0.5174 0 376.226 0.5173 88.40 0 0.172 0.5174 32.199 0.5174 3.3 0 0.218 0.5174 >7200 – – – 10 >7200 0.5736 48.81 >7200 0.5736 92.98 23.97 0.609 0.5736 434.664 0.5736 2.89 0 19.078 0.5736 >7200 – – – 11 >7200 0.609 69.97 >7200 0.609 95.72 49.69 18.938 0.609 1652.79 0.609 2.72 0 15.35 0.609 >7200 – – – 12 >7200 0.6347 98.44 >7200 0.6373 97.55 76.05 36.208 0.645 >7200 0.6244 2.83 0 85.488 0.6244 >7200 – – – 13 >7200 0.7515 – >7200 0.7657 98.71 98.39 70.06 0.7824 >7200 0.7301 2.79 2.17 146.952 0.7301 >7200 – – – 14 >7200 0.8481 – >7200 0.9027 99.33 98.88 104.567 0.9674 >7200 0.7915 3.22 2.7 732.016 0.7967 >7200 – – – 15 >7200 1.0057 – >7200 1.0633 99.65 99.64 282.391 1.1268 >7200 0.9012 4.26 3.82 958.435 0.914 >7200 – – – Table 3 Number of instances solved within the time limit imposed. Table 3 Path-weight Path-edges Path-edges + PL4 28 29 38 18 Table 4 Average and standard deviation values for the computational time. Table 4 n Path-weight Path-edges Path-edges + PL4 5 average 0.25 0.28 0 0.42 standard deviation 0.04 0.14 0.01 0.52 6 average 0.38 0.71 0.12 51.54 standard deviation 0.15 0.26 0.29 45.58 7 average 1.87 2.13 0.72 940.63 standard deviation 0.34 0.52 0.73 1607.35 8 average 48.46 34.56 6.51 – standard deviation 20.51 15.97 2.77 – 9 average 572.97 386.62 21.51 – standard deviation 316.93 240.81 7.14 – Table 5 Average and standard deviation values for the GAP. Table 5 n Path-edges Path-edges + PL4 5 average 25.93 0.31 0 standard deviation 12.88 0.77 0 6 average 57.03 0.27 0.08 standard deviation 3.8 0.51 0.17 7 average 70.42 1.31 0.6 standard deviation 2.71 1.33 1.3 8 average 81.36 1.81 – standard deviation 1.52 1.31 – 9 average 88.3 2.63 – standard deviation 1.52 0.54 – 10 average 92.96 2.42 – standard deviation 1.08 0.82 – 11 average 96.16 2.23 – standard deviation 0.45 0.63 – 12 average 97.99 2.52 – standard deviation 0.6 1.2 – 13 average 98.79 4.95 – standard deviation 0.21 3.11 – 14 average 99.37 8.52 – standard deviation 0.09 6.63 – 15 average 99.65 5.85 – standard deviation 0.02 6.59 – Table 6 Average and standard deviation values for the GAP LB . Table 6 n Path-weight Path-edges Path-edges + 10 average 40.04 92.96 0 standard deviation 21.15 1.08 0 11 average 73.47 96.16 0 standard deviation 9.3 0.45 0 12 average 96.62 97.99 2.52 standard deviation 1.85 0.6 1.2 13 average – 98.79 4.95 standard deviation – 0.21 3.11 14 average – 99.37 8.52 standard deviation – 0.09 6.63 15 average – 99.65 5.85 standard deviation – 0.02 6.59 Innovative Applications of O.R. Compact mixed integer linear programming models to the minimum weighted tree reconstruction problem Bernard Fortz a Olga Oliveira b Cristina Requejo ⁎ b a Department of Computer Science, Université Libre de Bruxelles, B-1050 Brussels, Belgium and INOCS, INRIA Lille Nord-Europe, France Department of Computer Science Université Libre de Bruxelles B-1050 Brussels, Belgium and INOCS, INRIA Lille Nord-Europe France b Department of Mathematics, University of Aveiro, Aveiro 3810-193, Portugal Department of Mathematics University of Aveiro Aveiro 3810-193 Portugal ⁎ Corresponding author. Tel.: +351 963621692. The Minimum Weighted Tree Reconstruction (MWTR) problem consists of finding a minimum length weighted tree connecting a set of terminal nodes in such a way that the length of the path between each pair of terminal nodes is greater than or equal to a given distance between the considered pair of terminal nodes. This problem has applications in several areas, namely, the inference of phylogenetic trees, the modeling of traffic networks and the analysis of internet infrastructures. In this paper, we investigate the MWTR problem and we present two compact mixed-integer linear programming models to solve the problem. Computational results using two different sets of instances, one from the phylogenetic area and another from the telecommunications area, show that the best of the two models is able to solve instances of the problem having up to 15 terminal nodes. Keywords Mixed integer linear programming Tree realization Topology discovery Routing topology inference Minimum evolution problem 1 Introduction We address the problem of reconstructing a weighted tree T = ( V , E ) by knowing only pairwise distances dij , for all i, j ∈ Vt , between a set of terminal nodes Vt ⊂ V. Given a set Vt of n terminal nodes and an n × n distance matrix D, find a tree T = ( V , E ) spanning V = V t ∪ V a , where Va is a subset of n − 2 additional nodes, and associate edge weights we , e ∈ E, such that the weight of the unique path Pij between any two terminal nodes i and j ∈ Vt is at least dij , i.e. ∑ e ∈ P i j w e ≥ d i j , and such that the total sum of the edge weights ∑{i, j} ∈ E wij is minimized. This problem is the Minimum Weighted Tree Reconstruction (MWTR) Problem. The MWTR problem is a specific version of the distance realization problem (which is a graph realization problem), namely a tree realization problem for a distance matrix. Several authors studied the tree realization problem for a distance matrix and this class of combinatorial problems was proved to be NP-complete (Chung, Garrett, Graham, & Shallcross, 2001; Day, 1987; Farach, Kannan, & Warnow, 1995). Fiorini and Joret (2012) and Catanzaro, Aringhieri, Summa, and Pesenti (2015) discuss the NP-hardness of two related optimization problems, the minimum evolution problem (MEP) and the balanced minimum evolution problem (BMEP). These two problems are very well known distance realization problems from the computational biology area. The MWTR arises in a number of areas, such as telecommunications and computational biology. All the applications we consider have in common the notion of a graph realization of a distance matrix and more specific of a tree realization of an additive distance matrix. A distance matrix has a tree realization, if it is an additive matrix and can be embedded into a tree. Abdi (1990) mentions several applications from these “additive trees that are used to represent objects as leaves such that the distance on the tree between two leaves reflects the similarity between the objects”. Probably the most well know application is, in computational biology, the reconstruction of phylogenetic trees (Catanzaro, 2009; Felsenstein, 2004; Huson & Scornavacca, 2011). There are also applications in psychology (Corter & Tversky, 1986; Cunningham, 1980; Gilmore, Hersh, Caramazza, & Griffin, 1979; Sattath & Tversky, 1977; Soete, 1983) to represent cognitive processes or proximity and similarity relations. There are applications in information security for the detection and recognition of documents duplications (Dias, Rocha, & Goldenstein, 2012; Gilmore et al., 1979). And there are applications in telecommunications, namely in network tomography to discover the logical underlying network (Chung et al., 2001; Coates, Rabbat, & Nowak, 2003; Donnet & Friedman, 2007; Ni, Xie, Tatikonda, & Yang, 2008) and the routing topology of a network (Bhamidi, Rajagopal, & Roch, 2010; Chung et al., 2001; Donnet & Friedman, 2007; Haddadi, Rio, Iannaccone, Moore, & Mortier, 2008). In this work we use data from the two applications, the phylogenetics application and the network application, that will be described. An application of the MWTR includes in computational biology the reconstruction of phylogenetic trees. A phylogenetic tree represents the evolutionary relationships of a set of species, where terminal nodes represent the observed species, additional nodes represent common ancestors, edges represent the evolutionary relationships between pairs of nodes and edge weights represent the quantification of this evolutionary relationship (Felsenstein, 2004; Mount, 2001; Nei & Kumar, 2000). It is worth noting that phylogenetic trees allow understanding of the evolutionary history of species and can assist in the development of vaccines (Gaschen et al., 2002) and the study of biodiversity (Junker & Schreiber, 2008). In computational biology inferring a phylogenetic tree is one of the steps of the phylogenetic reconstruction. As part of such inference is the determination of the tree topology and the determination of the branch lengths, which requires further analysis methods. Such analysis methods includes parsimony methods, distance methods, and probabilistic methods arising from the maximum likelihood approach. These methods make specific assumptions about evolution. Distance methods exploit the existence of a measure of dissimilarity (also called distance) among pairs of species and aim at determining the tree topology together with branch lengths. Examples of distance methods assumptions are the minimum evolution principle and the balanced minimum evolution principle. In the minimum evolution principle the sum of all branch lengths is minimized (Nei & Kumar, 2000). This is the principle used in MEP. The balanced minimum evolution principle is a new version of the minimum evolution principle. This new version was first introduced by Pauplin (2000) to simplify tree length computations. Within this principle sibling subtrees have equal weight, as opposed to the standard version where all terminal nodes have the same weight and thus the weight of a subtree is equal to the number of its terminal nodes. This is the principle used in BMEP. Another application of the MWTR includes in telecommunications the inference of the underlying network. The reconstruction of the telecommunications network includes the determination of the underlying network topology as part of the network tomography process. The internet is a collection of interconnected networks, and its topology is unknown because of its decentralized and unregulated growth. In network tomography the knowledge of the underlying routing within some (unknown) network topology is important to develop more sophisticated and ambitious traffic control protocols and dynamic routing algorithms. Ni and Tatikonda (2011) propose “a general framework for designing and analyzing topology and link performance inference algorithms using ideas and tools from phylogenetic inference in evolutionary biology. The framework is built upon additive metrics. Under an additive metric the path metric (path length) is expressed as the summation of the link metrics (link lengths) along the path. The basic idea is to use (estimated) distances between the terminal nodes (end hosts) to infer the routing tree topology and link metrics”. Chung et al. (2001) investigate distance realization problems, a class of problems which, in their words, arise in the study of internet data traffic models and refer the construction of trees to infer the logical network topology. There are several techniques to reconstruct a network topology. For instance, one such technique can use ICMP (Internet Control Message Protocol) commands such as ping and traceroute (Donnet, 2013; Donnet, Raoult, Friedman, & Crovella, 2006; Govindan & Tangmunarunkit, 2000). However, these techniques require the cooperation of all the internal network devices, which is, most of the time, not possible, due to political and security issues. Another way to infer the routing network topology is to use tomographic techniques. These techniques only use end-to-end network measurements, such as loss measurements or delay variance. The end-to-end network measurements can be obtained using multicast (Duffield, Horowitz, Presti, & Towsley, 2002; Duffield, Horowitz, & Prestis, 2001; Ni et al., 2008) or unicast probing (Coates et al., 2002; Eriksson, Dasarathy, Barford, & Nowak, 2010; Shih & Hero, 2007). With this limited information only the logical topology can be inferred. The logical topology is obtained from the physical topology, representing only the physical devices on the network where traffic branching occurs and joining all the connections between these devices by a single logical link. The key idea is to use measurements at pairs of receivers to identify the logical topology defined by the branching points between paths to different receivers. In network design the terminal nodes represent the receivers, additional nodes represent physical devices where traffic branching occurs, edges represent relationships between pair of nodes and edges weights represent the quantification of some evolving connection property, like the delay or packet losses, for which end-to-end network measurements can be obtained. As already mentioned, all these applications have in common the notion of a graph realization of a distance matrix (Abdi, 1990). Over the years several authors studied the characteristics of the distance matrix and its graph and tree realization (Edelberg, Garey, & Graham, 1976; Hakimi & Patrinos, 1972; Koolen & Moulton, 2009; Simões-Pereira, 1987, 1990; Simões-Pereira & Zamfirescu, 1982; Varone, 1998; 2006). Hakimi and Yau (1965) were the first to refer, in 1965, the graph realization problem of a distance matrix and presented an algorithm for the special case where the realization of the matrix is a tree. Consider a n × n positive, symmetric matrix D, where the diagonal elements are zero, and every entry dij > 0, ∀i, j ∈ Vt, i ≠ j, represents the distance between terminal node i and terminal node j. In addition, if the elements of the matrix satisfy the triangle inequality d i j ≤ d i k + d k j , ∀ i , j , k ∈ V t , then the matrix D is called a distance matrix and has a graph realization (Isaev, 2006; Varone, 1998). The graph realization problem (Chung et al., 2001) can be stated as follows. Given a distance matrix D of dimension n, representing distances between a set of n objects, determine a edge-weighted connected graph G = ( V , E ) with node set V, |V| > n, containing a subset Vt ⊂ V, with | V t | = n terminal nodes (each node representing an object), and the value dij in matrix D satisfying d i j G = d i j , where d i j G denotes the length of the shortest path in G between terminal node i and terminal node j, i, j ∈ Vt . If such a graph exists then the distance matrix D has a realization. This means a metric given by the distance matrix D must be embedded into a graph. Associated with this existence problem is the optimization problem that determines a graph such that the sum of all edge weights of G is minimized. Among all the realizations of the distance matrix D, the one having the minimum total length is optimal (Chung et al., 2001). For a general distance matrix an optimal realization exists (Dress, 1984), however computing optimal realizations is hard, even for a small number of terminal nodes (Chung et al., 2001). Chung et al. (2001) formulate several versions of the distance matrix realization problem, mention relevant results, discuss their algorithmic implications, present approximation results and several heuristics. Because the realization problem is hard even to approximate, Chung et al. (2001) and Farach et al. (1995) introduce a weak realization of a distance matrix. A distance matrix D has a weak realization if there is a graph G whose node set contains node set Vt and the distance d i j G in the graph G between nodes i and j is greater than or equal to dij . For a given distance matrix with n terminal nodes, the distance, in the graph to be built, between two terminal nodes must be the minimal possible. Such a graph which is a weak realization for D must be a tree (Chung et al., 2001). Since the weak realization is a tree, for a set of n terminal nodes, there can be at most n − 2 additional nodes of degree exactly three. Even when restricting the topologies to binary unrooted trees, there are ( 2 n − 5 ) ! ! = ( 2 n − 5 ) ! 2 n − 3 ( n − 3 ) ! different possible topologies (Cavalli-Sforza & Edwards, 1967; Nei & Kumar, 2000). Hence there are finitely many topologies for a weak realization for D, and for each topology the problem of determining a weak realization can be formulated as a linear programming problem. To the best of our knowledge Catanzaro et al. (2015), Catanzaro, Labbé, Pesenti, and Salazar-Gonzaléz (2009) are the only authors to present (mixed integer) linear programming models for solving the problem. It is worth noting that although a distance matrix has a graph realization, not all distance matrices describe trees. To describe a tree the distance matrix must also be additive (Buneman, 1974), i.e. satisfy the four-point condition. In Fig. 1 we present a distance matrix and its graph realization. This distance matrix has no tree realization. Distances that fit exactly on a tree can be characterized by the following four-point condition that generalizes the triangle inequality (take k = ℓ ) (1.1) d i j + d k ℓ ≤ max { d i k + d j ℓ , d i ℓ + d j k } , ∀ i , j , k , ℓ ∈ V t . As a consequence of this condition, on any quartet i, j, k, ℓ we have that of the three sums d i j + d k ℓ , d i k + d j ℓ and d i ℓ + d j k , the largest two are equal. Distance matrices with this property are called additive, because the weights on the paths along the tree add up to the values in the distance matrix. The distance matrix represented in Fig. 1 does not satisfy the four-point condition, it is not additive. Buneman (1974) proved that a distance matrix can be represented by a tree if it is additive. For a tree with 4 terminal nodes, i, j, k, ℓ (e.g. Fig. 2 ), it can be checked that the four-point condition (1.1) holds w i 1 + w 1 j + w k 2 + w 2 ℓ ≤ max { w i 1 + w 12 + w 2 k + w j 1 + w 12 + w 2 ℓ , w i 1 + w 12 + w 2 ℓ + w j 1 + w 12 + w 2 k } . with wij being the weights associate to each edge in the tree solution. The constructed trees can either be rooted or unrooted. We consider unrooted trees and all the contents in this work can be adapted to a rooted tree. Therefore, and for modeling purposes, we force the tree structure to be a unrooted binary tree, all the additional nodes to have degree exactly three and the terminal nodes to be the leaves. Restricting ourselves to such topologies will help us to deal with this combinatorial problem which is a weak realization problem. Enforcing this tree structure is not a restriction to the problem as any tree can be converted into a rooted binary tree, and vice-versa. Byun and Yoo (2006) present an algorithm to convert a tree into a binary tree by including dummy nodes. The root node can then be added at the middle point in the longest path of the tree. If this point is in the edge {i, j}, remove edge {i, j}, add the dummy root node r and edges {i, r} and {j, r}, one new edge inherits the weight of edge {i, j} and the other new edge has weight 0. If this point is in the node i, consider the edge {i, j} connecting two nodes and proceed as before. In this work we contribute with two compact mixed integer linear programming (MILP) formulations of the MWTR problem. Both formulations use flows to help with the definition of the tree topology, however each with a different underlying reconstructing idea. One formulation, the Path-weight formulation, produces a tree solution and the other formulation, the Path-edges formulation, constructs a balanced tree. A balanced tree is a tree with minimal diameter. The matrix defined using the obtained branch weights is such that its submatrix corresponding to the terminal nodes dominates the given distance matrix. The Path-weight formulation produces a tree solution to the MWTR problem, using additional flow variables to ensure connectivity. This formulation is inspired from Model 4 in Catanzaro et al. (2009). As reported in Catanzaro et al. (2009), the linear relaxation of this model has an objective value of zero. We strengthen the formulation by adding valid inequalities that cut off the zero-objective solutions. The Path-edges formulation produces a balanced tree solution of the MWTR problem and flows are defined between every pair of terminal nodes. In Catanzaro, Labbé, Pesenti, and Salazar-Gonzaléz (2012) a balanced tree is also considered. However, we use multicommodity flows to deal with connectivity and path lengths. Instead of minimizing the total sum of all edge weights, the objective function deals with the minimization of the total tree length. Comparatively to the formulations presented in Catanzaro et al. (2012), formulation Path-edges solves more instances to optimality and, for the instances not solved to optimality, obtains a better lower bound value in smaller computational time. This paper aims at developing tighter compact MILP formulations for the MWTR problem, without requiring the development of specialized algorithms. Our aim is not to compete with the state-of-the-art algorithms which is a very specialized branch-and-cut-and-price algorithm based on a formulation with an exponential number of variables. In Section 2, we present and discuss two mixed integer linear programming formulations for the MWTR problem and include valid equalities and inequalities which improve the performance of the second formulation. Section 3 is devoted to computational results and Section 4 concludes the paper. 2 Formulations In this section we present two Mixed Integer Linear Programming formulations of the MWTR problem. Consider a tree T = ( V , E ) spanning the set of nodes V = V a ∪ V t . Va is the set of additional or internal nodes and Vt is the set of terminal or external nodes. The pairwise distances between terminal nodes in Vt are given in distance matrix D. The tree topologies we consider are such that the additional nodes of the tree all have degree three. Any tree can be transformed into a tree where every additional node has degree three by adding ”dummy” nodes and edges, as described in Byun and Yoo (2006). When | V t | = n , an unrooted tree has n − 2 additional nodes and 2 n − 3 edges. Without loss of generality, let V a = { 1 , … , n − 2 } be the additional node set and V t = { n − 1 , … , 2 n − 2 } be the terminal node set. In feasible trees, the length of a path varies between the length of a caterpillar tree (the most imbalanced tree) and the length of the most balanced tree. In a caterpillar tree all additional nodes are consecutively connected forming the central path (e.g. Fig. 3 ). Thus all the additional nodes, but two, are connected to exactly one terminal node, and those two additional nodes are connected exactly to two terminal nodes. A binary balanced tree has the minimum possible maximum height (depth) and is such that the heights of the left and right subtrees differ by at most one and the left and the right subtrees are balanced. A balanced tree is a binary tree having the smallest diameter (e.g. Fig. 4 ) and therefore the shortest path length with consecutive additional nodes. This tree has the n terminal nodes pairwise connected to ⌊ n 2 ⌋ additional nodes, if n is even (e.g. Fig. 4, on the right), and if n is odd n − 1 terminal nodes pairwise connected to ⌊ n 2 ⌋ additional nodes and 1 terminal node connected to an additional node (e.g. Fig. 4, on the left). Eliminating the terminal nodes from this balanced tree we obtain a tree with only additional nodes. The degree of the nodes of this new tree are distributed as follows: ⌊ n 2 ⌋ nodes have degree one, ⌈ n 2 ⌉ - ⌊ n 2 ⌋ nodes have degree two and n − 2 − ⌈ n 2 ⌉ nodes have degree three. The shortest path with consecutive additional nodes is obtained by binding consecutively a node with degree one, to the nodes with degree three, to the node of degree two, if it exits, and to a node with degree one. The obtained path uses 1 + ( n − 2 − ⌈ n 2 ⌉ ) + ( ⌈ n 2 ⌉ − ⌊ n 2 ⌋ ) + 1 = n − ⌊ n 2 ⌋ = ⌈ n 2 ⌉ additional nodes. Therefore any feasible solution contains a path with at least ⌈ n 2 ⌉ consecutive additional nodes. Additional nodes can be arbitrarily interchanged in a solution to our problem, without modifying the tree topology. This introduces a lot of symmetry in the problem. As any feasible solution to the problem contains a path with at least ⌈ n 2 ⌉ consecutive additional nodes, the numbering of additional nodes is arbitrary. To break some of that symmetry, we can assume this path is composed of edges { i , i + 1 } for additional nodes i = 1 , … , ⌈ n 2 ⌉ − 1 , and force these edges to be present in any solution. Both formulations use the following variables. Binary variables xij, i ∈ Va, j ∈ V, i < j indicate whether edge {i, j} belongs to the tree solution, while continuous variables wij ≥ 0 represent the weight associated to edge {i, j}. 2.1 Path-weight formulation We seek a tree T and associated weights we , e ∈ T, that provide a weak realization of distance matrix D. Consider the path Pij that connects terminal nodes i and j, i, j ∈ Vt . By definition of a weak realization, (2.1) ∑ e ∈ P i j w e ≥ d i j must hold. To ensure this, consider additional continuous variables uij , for all i , j ∈ V , i ≠ j , which indicate the length of the path between nodes i and j. In order to impose connectivity several approaches can be used. Usual approaches consists either in the inclusion of the subtour elimination inequalities (2.2) ∑ i , j ∈ S x i j ≤ | S | − 1 , S ⊂ V , S ≠ ∅ , | S | > 1 or in the inclusion of the cut-set inequalities (2.3) ∑ i ∈ S , j ∈ S c x i j ≥ 1 , S ⊂ V , S ≠ ∅ , 0 ∈ S . The linear relaxation of both models provide the same bound, however the number of inequalities increase exponentially with the size of the model. It is well known that in order to ensure connectivity/prevent circuits, instead of using one of the families of inequalities (2.2) and (2.3) with an exponential number of inequalities, one can use compact extended formulations (Magnanti & Wolsey, 1995). The most common are derived using either the well-known Miller–Tucker–Zemlin inequalities (Gouveia, 1995; Miller, Tucker, & Zemlin, 1960) or using stronger multicommodity flow formulations (Gouveia, 1996; Magnanti & Wolsey, 1995). In the formulation presented below we use multicommodity flows. Fixing additional node 1 as the root of the flow, we introduce binary flow variables y i j k for all k ∈ Vt, i ∈ Va, j ∈ V with i < j, indicating whether edge {i, j} is used from i to j in the path from root node 1 to terminal node k. Let dmax ≔ max {dij : i, j ∈ Vt }. The formulation that minimizes the total edges weights and reconstructs an unrooted tree for the MWTR problem is as follows. Path-weight formulation m i n ∑ i ∈ V a ∑ j ∈ V j > i w i j subject to (2.4) ∑ i ∈ V a ∑ j ∈ V j > i x i j = 2 n − 3 (2.5) ∑ j ∈ V j > i x i j + ∑ j ∈ V a i > j x j i = 3 , ∀ i ∈ V a (2.6) ∑ i ∈ V a j > i x i j = 1 , ∀ j ∈ V t (2.7) x i , i + 1 = 1 ∀ i ∈ V a , i = 1 , … , ( ⌈ n / 2 ⌉ − 1 ) (2.8) ∑ j ∈ V a ∪ { k } j ≠ 1 y 1 j k = 1 , ∀ k ∈ V t (2.9) ∑ i ∈ V a y i k k = 1 , ∀ k ∈ V t (2.10) ∑ i ∈ V a i < j y i j k = ∑ i ∈ V a ∪ { k } i > j y j i k , ∀ k ∈ V t , ∀ j ∈ V a ∖ { 1 } (2.11) y i j k ≤ x i j , ∀ k ∈ V t , ∀ i ∈ V a , ∀ j ∈ V ∖ { 1 } , j > i (2.12) u i j ≥ d i j ∀ i , j ∈ V t , i < j (2.13) u i j ≥ w i j ∀ i ∈ V a , ∀ j ∈ V t , i < j (2.14) d m a x x i j ≥ w i j ∀ i ∈ V a , ∀ j ∈ V , i < j (2.15) w i j ≥ u i j − d m a x ( 1 − x i j ) ∀ i ∈ V a , ∀ j ∈ V , i < j (2.16) w i j ≥ u i k − u j k − d m a x ( 1 − x i j ) ∀ i ∈ V a , ∀ j , k ∈ V , i < j , j < k (2.17) w i j ≥ u j k − u i k − d m a x ( 1 − x i j ) ∀ i ∈ V a , ∀ j , k ∈ V , i < j , j < k (2.18) w i j ≥ u i k − u k j − d m a x ( 1 − x i j ) ∀ i ∈ V a , ∀ j , k ∈ V , i < k , k < j (2.19) w i j ≥ u k j − u i k − d m a x ( 1 − x i j ) ∀ i ∈ V a , ∀ j , k ∈ V , i < k , k < j (2.20) w i j ≥ u k i − u k j − d m a x ( 1 − x i j ) ∀ i , k ∈ V a , ∀ j ∈ V , i < j , k < i (2.21) w i j ≥ u k j − u k i − d m a x ( 1 − x i j ) ∀ i , k ∈ V a , ∀ j ∈ V , i < j , k < i (2.22) x i j ∈ { 0 , 1 } ∀ i ∈ V a , ∀ j ∈ V , i < j (2.23) y i j k ∈ { 0 , 1 } ∀ k ∈ V t , ∀ i ∈ V a , ∀ j ∈ V , i < j (2.24) w i j ≥ 0 ∀ i ∈ V a , ∀ j ∈ V , i < j (2.25) u i j ≥ 0 ∀ i , j ∈ V , i < j Constraints (2.4)–(2.7) define a spanning tree with all additional nodes with degree three and all terminal nodes with degree one. The cardinality constraints (2.4) ensure that there are 2 n − 3 edges in the solution. Constraints (2.5) ensure that all additional nodes have degree three. Constraints (2.6) ensure that all terminal nodes have degree one. As already mentioned, to reduce the symmetry, we fix a path between the first additional nodes with constraints (2.7). Constraints (2.8)–(2.10) are flow conservation constraints and constraints (2.11) are linking constraints between flow variables y i j k and topology variables xij . Constraints (2.12)–(2.21) link edge weight variables wij and path length variables uij . Constraints (2.12) ensure a weak realization of the distance matrix. Constraints (2.13) establish a lower bound for variables uij , associated to the length of the path between an additional node i and an external node j, to be the value of the corresponding (edge) weight wij . Constraints (2.14) fix wij to 0 when edge {i, j} does not belong to the tree. Together with (2.13), constraints (2.15) impose that wij is equal to uij if edge {i, j} belongs to the tree. Constraints (2.16)–(2.21) impose the triangle inequality for any order of the nodes i, j and k. The index specifications included in the constraints (2.16)–(2.21) improve the performance of our formulation as they impose an order on the variables index. Constraints (2.22) to (2.25) are integrality and non-negativity constraints. Our formulation strengthens the Flow Model proposed in Catanzaro et al. (2009) by including lower bounds on the wij variables. 2.2 Path-edges formulation Pauplin (2000) developed a method to directly calculate the sum of all weights of a tree (the length of the tree) without having to explicitly determine its edge-weights. According to this method the tree length is given by ∑ i , j ∈ V t d i j 2 − z i j where zij indicates the number of edges in the path Pij between terminal nodes i and j. When d i j = ∑ e ∈ P i j w e , we have ∑ i , j ∈ V t d i j 2 − z i j = ∑ i , j ∈ V t ∑ e ∈ P i j w e 2 − z i j . As the weight we appears as many times as the number of paths Pij to which the edge e belongs to, it holds ∑ i , j ∈ V t d i j 2 − z i j = ∑ e ∈ E w e and for a weak realization we have ∑ i , j ∈ V t d i j 2 − z i j ≤ ∑ e ∈ E w e and min ∑ i , j ∈ V t d i j 2 − z i j ≤ min ∑ e ∈ E w e . Using binary variables p i j ℓ , for all i, j ∈ Vt, i < j and ℓ ∈ { 2 , 3 , … , ( n − 1 ) } , specifying the number of edges of a path Pij between terminal nodes i and j, the expression ∑ i , j ∈ V t d i j 2 − z i j can be linearized. This relation and linearization process was already used in Catanzaro et al. (2012). The binary decision variables p i j ℓ indicating whether the path Pij connecting terminal node i to terminal node j has (exactly) ℓ edges. Therefore ∑ i , j ∈ V t d i j 2 − z i j = ∑ i , j ∈ V t d i j ∑ ℓ = 2 n − 1 2 − ℓ p i j ℓ . Variables p i j ℓ have the same interpretation as variables x i j ℓ in Catanzaro et al. (2012). Besides these path variables p i j ℓ , the binary topology variables xij and the weight variables wij , we consider flow variables. The binary flow variables f i j k ℓ , for all i, j ∈ Va ∪ {k, ℓ}, k, ℓ ∈ Vt, i ≠ j and k < ℓ, indicate whether the flow traverses the edge {i, j} belonging to the path connecting terminal node k to terminal node ℓ in the direction from node i to node j. The formulation that specifies the number of edges of a path between terminal nodes and reconstructs an unrooted tree for the MWTR problem is as follows. Path-edges formulation m i n ∑ i ∈ V t ∑ j ∈ V t j > i d i j ∑ ℓ = 2 n − 1 2 − ℓ · p i j ℓ subject to (2.26) ∑ i ∈ V a ∑ j ∈ V j > i x i j = 2 n − 3 (2.27) ∑ i ∈ V a x i j = 1 , ∀ j ∈ V t (2.28) ∑ j ∈ V j > i x i j + ∑ j ∈ V a j < i x j i = 3 , ∀ i ∈ V a (2.29) x i , i + 1 = 1 ∀ i ∈ V a , i = 1 , … , ( ⌈ n / 2 ⌉ − 1 ) (2.30) ∑ j ∈ V t x 1 j = 2 (2.31) ∑ j ∈ V t x ( n − 2 ) j = 2 (2.32) ∑ j ∈ V t x i j ≤ 2 ∀ i ∈ V a (2.33) ∑ i ∈ V a f k i k ℓ = 1 ∀ k , ℓ ∈ V t , k < ℓ (2.34) ∑ j ∈ { ℓ } ∪ V a ∖ { i } f i j k ℓ − ∑ j ∈ { k } ∪ V a ∖ { i } f j i k ℓ = 0 ∀ i ∈ V a , k , ℓ ∈ V t , k < ℓ (2.35) ∑ i ∈ V a f i ℓ k ℓ = 1 ∀ k , ℓ ∈ V t , k < ℓ (2.36) ∑ h ∈ { ℓ } ∪ V a ∖ { i } f j h k ℓ − f i j k ℓ ≥ 0 ∀ i ∈ V a ∪ { k } , j ∈ V a , k , ℓ ∈ V t , k < ℓ (2.37) f i j k ℓ + f j i k ℓ ≤ x i j ∀ i , j ∈ V , ∀ k , ℓ ∈ V t , i < j , k < ℓ (2.38) ∑ ℓ = 2 n − 1 p i j ℓ = 1 ∀ i , j ∈ V t , i < j (2.39) 2 + ∑ i ∈ V a ∑ j ∈ V a j ≠ i f i j k ℓ = ∑ i = 2 n − 1 i · p k ℓ i ∀ k , ℓ ∈ V t , k < ℓ (2.40) x i j ∈ { 0 , 1 } ∀ i ∈ V a , ∀ j ∈ V , i < j (2.41) p i j ℓ ∈ { 0 , 1 } ∀ ℓ ∈ { 2 , 3 , … , n − 1 } , ∀ i , j ∈ V t , i < j (2.42) f i j k ℓ ∈ { 0 , 1 } ∀ i , j ∈ V a ∪ { k , ℓ } ∀ k , ℓ ∈ V t , i ≠ j , k < ℓ Constraint (2.26) is the tree cardinality constraint and establishes that the number of edges in the tree is 2 n − 3 . Constraints (2.27) establish that all the terminal nodes have degree one and constraints (2.28) force the additional nodes degree to be three. As above, we fix a path of additional nodes with constraints (2.29). Since the tree is unrooted, we know that there are two additional nodes which are adjacent to two terminal nodes. Therefore, to reduce symmetry, constraints (2.30) and (2.31) enforce those two additional nodes to be node 1 and node ( n − 2 ) . Constraints (2.32) impose that an additional node is connected to, at most, two terminal nodes. Constraints (2.33)–(2.35) are flow conservation constraints. Constraints (2.36) establish that if the flow sent from terminal node k to terminal node ℓ passes through edge {i, j}, in the direction from node i to node j, then the flow passes through, at least, one edge between node j and a node different than node i. Constraints (2.37) are linking constraints between variables and impose that there can be no flow in edge {i, j} if it does not belong to the tree. Constraints (2.38) impose that variables p i j ℓ assume value one for exactly one ℓ in { 2 , 3 , … , ( n − 1 ) } corresponding to the number of edges in the path between terminal nodes i and j. Constraints (2.39) relate variables f i j k ℓ with variables p i j ℓ . Using variables f i j k ℓ we know exactly the number of edges in the path between terminal nodes k and ℓ. Using variables p k ℓ i we also know exactly the number of edges in the path between terminal nodes k and ℓ and that number must be exactly the same. Constraints (2.40), (2.41) and (2.42) are the integrality constraints. This second formulation uses the same idea in Catanzaro et al. (2012) to obtain the total tree edges length by the formulation designated by the authors as the Path-Length-4-Point (PL4). In Section 3 we will compare the formulations presented in this section with this PL4 formulation. After having reconstructed a unrooted tree with this formulation, the weights have to be assigned to the tree edges. This is accomplished by solving the following simple linear program. m i n ∑ i ∈ V a ∑ j ∈ V j > i w i j subject to ∑ i ∈ V a ∑ j ∈ V i < j w i j ( f i j k ℓ + f j i k ℓ ) ≥ d k ℓ ∀ k , ℓ ∈ V t , k < ℓ w i j ≥ 0 ∀ i , j ∈ V , i < j Using the flow variables, the path between each pair of terminal nodes is exactly known. This information is used to associate weights to the edges such that the total sum of the edges weights is minimized and the tree length between every pair of terminal nodes dominates (is greater than) the corresponding distance from the distance matrix D. In a tree there is exactly one path between every pair of terminal nodes and the path variables p i j ℓ state there are ℓ, for some unique ℓ ≥ 2, edges in the path between terminal nodes i and j. Therefore ∑ ℓ = 2 n − 1 ℓ p i j ℓ is the number of edges in the path between terminal nodes i and j. By summing the number of edges of all paths and taking into account that some edges belong to more than one path we must have (2.43) 2 ∑ i ∈ V t ∑ j ∈ V t j > i ∑ ℓ = 2 n − 1 2 − ℓ ℓ p i j ℓ = 2 n − 3 , as the number of edges in the tree is 2 n − 3 . This is already stated in the formulation through constraint (2.26), however this equality reinforces this condition using the path variables. Huffman codes are optimal path-length sequences whose corresponding rooted binary tree determines a code. When producing optimal Huffman codes the key idea are these rooted binary trees represented as sequences of ascending path-lengths. A sequence of n path-lengths represents a binary tree with n leaves where each leaf represents a symbol in the code. Parker and Ram (1996) characterize these path-length sequences by establishing that these binary trees obey the property established by the Kraft equality, a special case of the Kraft inequality. These path-lengths can be compared to the distances from the tree realization problem. Therefore the nontrivial property of the path-length sequences in a rooted binary tree characterized with the Kraft equality can be borrowed by the MWTR problem and the following equality can be established: (2.44) ∑ ℓ = 2 n − 1 ∑ j ∈ V t j > i 2 − ℓ p i j ℓ + ∑ ℓ = 2 n − 1 ∑ j ∈ V t j < i 2 − ℓ p j i ℓ = 1 2 ∀ i ∈ V t The inclusion of the two equalities (2.43) and (2.44) improved the performance of the Path-edges formulation. Beside these two equalities the following valid inequalities presented in Catanzaro et al. (2012) can also be included. (2.45) ∑ j ∈ V t i < j p i j n − 1 + ∑ j ∈ V t j < i p j i n − 1 ≤ 2 ∑ j ∈ V t i < j p i j ℓ + 2 ∑ j ∈ V t j < i p j i ℓ ∀ i ∈ V t , ∀ ℓ ∈ { 2 , 3 , … , n − 2 } (2.46) ∑ i ∈ V t ∑ j ∈ V t j > i p i j n − 1 ≤ 4 (2.47) ∑ j ∈ V t i < j ∑ q = 2 ℓ 2 ℓ − q p i j q ≤ 2 ℓ − 1 − 1 ∀ i ∈ V t , ∀ ℓ ∈ { 2 , 3 , … , ⌊ n 2 ⌋ } , n > 2 ℓ − 1 + 1 Inequalities (2.45) state that if a tree has a path of length n − 1 then it also has a path of length n − 2 , n − 3 , … , 2 , inequality (2.46) indicates that a tree has at most four paths of length n − 1 and inequalities (2.47) are a consequence of the Kraft equality. 3 Computational results Computational results will assess the quality of the Linear Programming (LP) solutions obtained with each formulation from Section 2 and the best lower and upper bounds achieved. The computational tests were performed on an Intel(R) Core(TM) i7-3770 CPU 3.40 Gigahertz processor and 16.0 Gigabyte of RAM. We present computational results for instances of the problem with a number of terminal nodes varying between 5 and 15, for a total of 55 instances. We use two sets of data instances, one set coming from a phylogenetics application, and the other one from a networking application. The first set of instances is available from Catanzaro et al. (2012). From this set we use three phylogenetic distance matrices, matrices M391, Primate and M887, with t = 15 , t = 12 and t = 15 taxa, respectively, and for each we vary the number of terminal nodes (taxa) between 5 and t, obtaining 30 instances. The data for the second set of instances were generated using the network-level simulator NS-3. We performed three simulations named Sim7, Sim15 and Sim20 with t = 7 , t = 15 and t = 15 terminal nodes, varying the number of terminal nodes between 5 and t obtaining 25 instances. The two formulations from Section 2 were implemented using the Mosel language and solved with FICO Xpress 7.1 FICO Xpress Optimization Suite (Xpress-IVE 1.23.00 64 bit, Xpress-Optimizer 23.01.03 and Xpress-Mosel 3.4.0). Path-edges formulation used together with the valid equalities (2.43) and (2.44) and inequalities (2.45), (2.46), (2.47) presented at the end of Section 2 is designated Path-edges + formulation. We compare the performance of the two formulations introduced in Section 2, Path-weight formulation and Path-edges formulation, and the Path-edges + formulation with the formulation PL4 from Catanzaro et al. (2012). Our implementation of PL4 considers all the valid inequalities presented in Catanzaro et al. (2012). The computational results are summarized in Tables 1 and 2 in which the first column, labeled Matrix, indicates the name of the matrix instance used and the second column, labeled |Vt |, indicates the size of the instance. The third, fourth and fifth columns concern the results of the Path-weight formulation, from the sixth to the eleventh columns the results of the Path-edges formulation are presented, from the twelfth to the seventeenth columns are the results of the Path-edges + formulation and the eighteenth, nineteenth, twentieth and twenty-first columns concern PL4 formulation. The columns labeled T show the execution time, in seconds, used to solve the instance and having a maximum runtime of 7200 seconds and for the Path-edges formulation and Path-edges + formulation, the columns labeled T w shows the execution time of the linear program solved to assign the weights. The columns labeled W and DZ present the optimum value obtained or the best value obtained having a runtime limit of 7200 seconds, where DZ stands for ∑ k ∈ V t ∑ ℓ ∈ V t ℓ > k d k ℓ ∑ i = 2 n − 1 2 − i · p k ℓ i and W stands for ∑ i ∈ V a ∑ j ∈ V j > i w i j . The columns labeled GAP present the LP solution gap which is obtained as follows: G A P = U B − P L U B × 100 , where UB represents the best upper bound value obtained (or the optimum value) within the runtime of 7200 seconds and PL represents the value of the corresponding linear programming relaxation. The columns labeled GAP LB present the lower bound gap and is obtained as follows: G A P L B = U B − L B U B × 100 , where UB represents the best upper bound value obtained (or the optimum value) and LB the best lower bound value obtained within the runtime of 7200 seconds. The optimum solution within the time limit imposed is obtained in the following cases: • by the Path-weight formulation for all instances with n < 10 terminal nodes and for instance Sim15 with n = 10 ; • by the Path-edges formulation for all instances with n < 10 terminal nodes; • by the Path-edges + formulation for all instances with n < 12 terminal nodes; • by the PL4 formulation for all instances with n < 8 terminal nodes. To better check the improvements achieved we display in Table 3 the number of instances, among the total of 55 instances, for which the optimal solution was obtained, within the time limit imposed, when the model indicated is used. The Path-edges + formulation solves the instances substantially faster than the other formulations. In Fig. 5 , we compare the computational times in the form of a profile graph that displays the number of solved instances in a given time by each formulation. Comparing, in Tables 1 and 2, the columns labeled with W of the Path-weight formulation and of the Path-edges formulation we notice that for some instances from the phylogenetics application the values obtained are different. This is due to the fact that the obtained trees are different. The tree we obtain when minimizing ∑ k ∈ V t ∑ ℓ ∈ V t ℓ > k d k ℓ ∑ i = 2 n − 1 2 − i · p k ℓ i is such that, when assigning its edges weights the equality ∑ e ∈ P i j w e = d i j does not hold. In that case we obtain a tree that minimizes ∑ k ∈ V t ∑ ℓ ∈ V t ℓ > k d k ℓ ∑ i = 2 n − 1 2 − i · p k ℓ i but does not minimizes ∑ i ∈ V a ∑ j ∈ V j > i w i j (see column labeled DZ), as in this case it holds ∑ k ∈ V t ∑ ℓ ∈ V t ℓ > k d k ℓ ∑ i = 2 n − 1 2 − i · p k ℓ i < ∑ i ∈ V a ∑ j ∈ V j > i w i j . When the optimal solution can not be found within the runtime limit imposed the Path-weight formulation obtains, on average, ten feasible solutions, the Path-edges + formulation obtains, on average, three feasible solutions and the PL4 formulation is unable to obtain feasible solutions within the runtime limit imposed, except for matrix M887 where for n = 8 this formulation obtained one feasible solution. The difference between the number of feasible solutions of the Path-weight formulation and of the Path-edges formulation is due to the fact that the only integer (binary) variables of the Path-weight formulation are those which identify the tree, whereas the Path-edges formulation only has integer (binary) variables. For instances with the same number of terminal nodes, Tables 4–6 display the average time, the average GAP and the average GAP LB , respectively, and their corresponding standard deviation values. Table 4 presents the values for instances with n ≤ 9, since for n > 9 only the Path-edges + obtains a feasible solution within the runtime limit imposed. Table 6 displays the values for the formulations Path-weight, Path-edges and Path-edge + , since the formulation PL4 does not obtain feasible solutions for n ≥ 10, and for instances with n ≥ 10 because for n < 10 the GAP LB is equal to zero (the optimal solution is achieved). Now we compare the results between the Path-edges formulation and the Path-edges + formulation. The Path-edges + formulation is substantially faster, for example for n = 9 it is eighteen times faster. The average GAP of the Path-edges formulation varies from 25.93%, for n = 5 , to 99.65%, for n = 15 , while the average GAP of the Path-edges + formulation does not exceed 9%. Finally, the average GAP LB of the Path-edges formulation is over 90% while for the Path-edges + formulation it does not exceed 9%. We may conclude that the equalities and inequalities included in the Path-edges formulation considerably improve the formulation. 4 Conclusion In this paper, we introduce two formulations for the minimum weighted tree reconstruction (MWTR) problem: the Path-weight formulation and the Path-edges formulation. Some valid equalities and inequalities are also introduced to strengthen the Path-edges formulation. Computational experiments performed on data sets coming from phylogenetics and networking applications show that the strengthened Path-edges formulation outperforms the previous formulations proposed in the literature. Several strategies could be applied to both formulations to improve their performance. Among them is the strategy proposed in Catanzaro et al. (2012). Generally the application of these strategies is not straightforward. We leave this approach for future work. Acknowledgments The research of Cristina Requejo and Olga Oliveira has been partially supported by Portuguese funds through the Center for Research and Development in Mathematics and Applications (CIDMA) and the FCT, the Portuguese Foundation for Science and Technology, within project UID/MAT/04106/2013. The research of Olga Oliveira has been supported by a research fellowship (grant SFRH/BD/76268/2011) through FCT, the Portuguese Foundation for Science and Technology, within the project POPH-QREN. The research of Bernard Fortz and Olga Oliveira has been funded by the Interuniversity Attraction Poles Programme P7/36 COMEX initiated by the Belgian Science Policy Office. References Abdi, Dress, von Haeseler, 1990 H. Abdi Additive-tree representations Dress A. von Haeseler A. Trees and Hierarchical Structures Lecture Notes in Biomathematics 84 1990 Springer Berlin Heidelberg 43 59 Bhamidi, Rajagopal, Roch, 2010 S. Bhamidi R. Rajagopal S. Roch Network delay inference from additive metrics Random Structures Algorithms 37 2 2010 176 203 Buneman, 1974 P. Buneman A note on the metric properties of trees Journal of Combinatorial Theory 17 1974 48 50 Byun, Yoo, 2006 S.-S. Byun C. Yoo Reducing delivery delay in HRM tree Gavrilova M. Gervasi O. Kumar V. Tan C. Taniar D. Laganà A. Mun Y. Choo H. Computational Science and Its Applications - ICCSA 2006 Lecture Notes in Computer Science 3981 2006 Springer Berlin Heidelberg 1189 1198 Catanzaro, 2009 D. Catanzaro The minimum evolution problem: overview and classification Networks 53 2 2009 112 125 Catanzaro, Aringhieri, Summa, Pesenti, 2015 D. Catanzaro R. Aringhieri M.D. Summa R. Pesenti A branch-price-and-cut algorithm for the minimum evolution problem European Journal of Operational Research 244 3 2015 753 765 Catanzaro, Labbé, Pesenti, Salazar-Gonzaléz, 2009 D. Catanzaro M. Labbé R. Pesenti J.-J. Salazar-Gonzaléz Mathematical models to reconstruct phylogenetic trees under the minimum evolution criterion Networks 53 2 2009 126 140 Catanzaro, Labbé, Pesenti, Salazar-Gonzaléz, 2012 D. Catanzaro M. Labbé R. Pesenti J.-J. Salazar-Gonzaléz The balanced minimum evolution problem INFORMS Journal on Computing 24 2 2012 276 294 Cavalli-Sforza, Edwards, 1967 L. Cavalli-Sforza A. Edwards Phylogenetic analysis. Models and estimation procedures American Journal of Human Genetics 19 1967 233 257 Chung, Garrett, Graham, Shallcross, 2001 F. Chung M. Garrett R. Graham D. Shallcross Distance realization problems with applications to internet tomography Journal of Computer and System Sciences 63 3 2001 432 448 Coates, Castro, Nowak, Gadhiok, King, Tsang, 2002 M. Coates R. Castro R. Nowak M. Gadhiok R. King Y. Tsang Maximum likelihood network topology identification from edge-based unicast measurements ACM SIGMETRICS performance evaluation review 30 2002 11 20 Coates, Rabbat, Nowak, 2003 M. Coates M. Rabbat R. Nowak Merging logical topologies using end-to-end measurements Proceedings of the 3rd ACM SIGCOMM conference on internet measurement, IMC ’03 2003 192 203 Corter, Tversky, 1986 J.E. Corter A. Tversky Extended similarity trees Psychometrika 51 3 1986 429 451 Cunningham, 1980 J.P. Cunningham Trees as memory representations for simple visual patterns Memory & Cognition 8 6 1980 593 605 Day, 1987 W.H. Day Computational complexity of inferring phylogenies from dissimilarity matrices Bulletin of Mathematical Biology 49 4 1987 461 467 Dias, Rocha, Goldenstein, 2012 Z. Dias A. Rocha S. Goldenstein Image phylogeny by minimal spanning trees IEEE Transactions on Information Forensics and Security 7 2 2012 774 788 Donnet, 2013 B. Donnet Internet topology discovery Data Traffic Monitoring and Analysis: From Measurement, Classification, and Anomaly Detection to Quality of Experience Lecture Notes in Computer Science 7754 2013 Springer 44 81 Donnet, Friedman, 2007 B. Donnet T. Friedman Internet topology discovery: a survey IEEE Communications Surveys 9 4 2007 2 14 Donnet, Raoult, Friedman, Crovella, 2006 B. Donnet P. Raoult T. Friedman M. Crovella Deployment of an algorithm for large-scale topology discovery IEEE Journal on Selected Areas in Communications 24 12 2006 2210 2220 Dress, 1984 A. Dress Trees, tight extensions of metric spaces, and the cohomological dimension of certain groups: a note on combinatorial properties of metric spaces Advances in Mathematics 53 1984 321 402 Duffield, Horowitz, Presti, Towsley, 2002 N. Duffield J. Horowitz F.L. Presti D. Towsley Multicast topology inference from measured end-to-end loss IEEE Transactions on Information Theory 48 1 2002 26 45 Duffield, Horowitz, Prestis, 2001 N. Duffield J. Horowitz F.L. Prestis Adaptive multicast topology inference INFOCOM 2001. twentieth annual joint conference of the IEEE computer and communications societies. proceedings IEEE., volume 3 2001 1636 1645 Edelberg, Garey, Graham, 1976 M. Edelberg M. Garey R. Graham On the distance matrix of a tree Discrete Mathematics 14 1976 23 39 Eriksson, Dasarathy, Barford, Nowak, 2010 B. Eriksson G. Dasarathy P. Barford R. Nowak Toward the practical use of network tomography for internet topology discovery Proceedings of the INFOCOM 2010, the IEEE conference on computer communications 2010 1 9 Farach, Kannan, Warnow, 1995 M. Farach S. Kannan T. Warnow A robust model for finding optimal evolutionary trees Algorithmica 13 1 1995 155 179 Felsenstein, 2004 J. Felsenstein Distance matrix methods Inferring Phylogenies, chapter 11 2004 Sinauer Associates, Inc Sunderland, Massachusetts 147 175 Fiorini, Joret, 2012 S. Fiorini G. Joret Approximating the balanced minimum evolution problem Operations Research Letters 40 1 2012 31 35 Gaschen, Taylor, Yusim, Foley, Gao, Lang et al., 2002 B. Gaschen J. Taylor K. Yusim B. Foley F. Gao D. Lang Diversity considerations in HIV-1 vaccine selection Science 296 5577 2002 2354 2360 Gilmore, Hersh, Caramazza, Griffin, 1979 G. Gilmore H. Hersh A. Caramazza J. Griffin Multidimensional letter similarity derived from recognition errors Perception & Psychophysics 25 5 1979 425 431 Gouveia, 1995 L. Gouveia Using the Miller-Tucker-Zemlin constraints to formulate a minimal spanning tree problem with hop constraints Computers and Operations Research 22 9 1995 959 970 Gouveia, 1996 L. Gouveia Multicommodity flow models for spanning trees with hop constraints European Journal of Operational Research 95 1996 178 190 Govindan, Tangmunarunkit, 2000 R. Govindan H. Tangmunarunkit Heuristic for internet map discovery Proceeding of the 19th annual joint conference of IEEE computer and communications societies, volume 3 2000 1371 1380 Haddadi, Rio, Iannaccone, Moore, Mortier, 2008 H. Haddadi M. Rio G. Iannaccone A. Moore R. Mortier Network topologies: inference, modelling and generation IEEE Communications Surveys 10 2 2008 48 69 Hakimi, Patrinos, 1972–73 S.L. Hakimi A. Patrinos The distance matrix of a graph and its tree realization Quarterly of Applied Mathematics 30 1972 255 269 73 Hakimi, Yau, 1965 S.L. Hakimi S.S. Yau Distance matrix of a graph and its realizability Quarterly of Applied Mathematics 22 1965 305 317 Huson, Scornavacca, 2011 D. Huson C. Scornavacca A survey of combinatorial methods for phylogenetic networks Genome Biology and Evolution 3 2011 23 35 Isaev, 2006 A. Isaev Introduction to Mathematical Methods in Bioinformatics 2006 Springer Junker, Schreiber, 2008 B.H. Junker F. Schreiber Analysis of Biological Networks 2008 John Wiley & Sons Koolen, Moulton, 2009 A.L.J. Koolen V. Moulton Optimal realizations of generic five-point metric European Journal of Combinatorics 30 2009 1164 1171 Magnanti, Wolsey, 1995 T.L. Magnanti L.A. Wolsey Optimal trees Ball M. Magnanti T.L. Monma C. Nemhauser G.L. Network Models, Handbooks in Operations Research and Management Science, Vol. 7 1995 Elsevier Science Publishers North-Holland 503 615 Miller, Tucker, Zemlin, 1960 C. Miller A. Tucker R. Zemlin Integer programming formulations and travelling salesman problems Journal of the Association for Computing Machinery 7 4 1960 326 329 Mount, 2001 D. Mount Bioinformatics. Sequence and genome analysis 2001 Cold Spring Harbor Laboratory Press Nei, Kumar, 2000 M. Nei S. Kumar Molecular evolution and phylogenetics 2000 Oxford University Press Ni, Tatikonda, 2011 J. Ni S. Tatikonda Network tomography based on additive metrics IEEE Transactions on Information Theory 57 12 2011 7798 7809 Ni, Xie, Tatikonda, Yang, 2008 J. Ni H. Xie S. Tatikonda Y.R. Yang Network routing topology inference from end-to-end measurements INFOCOM 2008, the 27th IEEE conference on computer communications 2008 Network Simulator NS-3 Network Simulator NS-3. www.nsnam.org. Parker, Ram, 1996 D. Parker P. Ram The construction of Huffman codes is a submodular (“convex”) optimization problem over a lattice of binary trees SIAM Journal on Computing 28 5 1996 1875 1905 Pauplin, 2000 Y. Pauplin Direct calculation of a tree length using a distance matrix Journal of Molecular Evolution 51 2000 41 47 Sattath, Tversky, 1977 S. Sattath A. Tversky Additive similarity trees Psichometrica 42 3 1977 319 345 Shih, Hero, 2007 M.-F. Shih A. Hero Hierarchical inference of unicast network topologies based on end-to-end measurements IEEE Transactions on Signal Processing 55 5 2007 1708 1718 Simões-Pereira, 1987 J. Simões-Pereira A note on distance matrices with unicyclic graph realizations Discrete Mathematics 65 1987 277 287 Simões-Pereira, 1990 J. Simões-Pereira An algorithm and its role in the study of optimal graph realizations of distance matrices Discrete Mathematics 79 1990 299 312 Simões-Pereira, Zamfirescu, 1982 J. Simões-Pereira C. Zamfirescu Submatrices of non-tree-realizable distance matrices Linear Algebra and its Applications 44 1982 1 17 Soete, 1983 G.D. Soete A least squares algorithm for fitting additive trees to proximity data Psychometrika 48 4 1983 621 626 FICO Xpress Optimization Suite FICO Xpress Optimization Suite. www.fico.com/xpress. Varone, 1998 S.C. Varone Trees related to realizations of distance matrices Discrete Mathematics 192 1998 337 346 Varone, 2006 S.C. Varone A constructive algorithm for realizing a distance matrix European Journal of Operational Research 174 1 2006 102 111 "
    }
]