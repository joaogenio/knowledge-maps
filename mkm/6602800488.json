[
    {
        "doc_title": "A Survey of Network-Based Hardware Accelerators",
        "doc_scopus_id": "85127229981",
        "doc_doi": "10.3390/electronics11071029",
        "doc_eid": "2-s2.0-85127229981",
        "doc_date": "2022-04-01",
        "doc_type": "Review",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Signal Processing",
                "area_abbreviation": "COMP",
                "area_code": "1711"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2022 by the author. Licensee MDPI, Basel, Switzerland.Many practical data-processing algorithms fail to execute efficiently on general-purpose CPUs (Central Processing Units) due to the sequential matter of their operations and memory bandwidth limitations. To achieve desired performance levels, reconfigurable (FPGA (Field-Programmable Gate Array)-based) hardware accelerators are frequently explored that permit the processing units’ architectures to be better adapted to the specific problem/algorithm requirements. In particular, network-based data-processing algorithms are very well suited to implementation in reconfigurable hardware because several data-independent operations can easily and naturally be executed in parallel over as many processing blocks as actually required and technically possible. GPUs (Graphics Processing Units) have also demonstrated good results in this area but they tend to use significantly more power than FPGA, which could be a limiting factor in embedded applications. Moreover, GPUs employ a Single Instruction, Multiple Threads (SIMT) execution model and are therefore optimized to SIMD (Single Instruction, Multiple Data) operations, while in FPGAs fully custom datapaths can be built, eliminating much of the control overhead. This review paper aims to analyze, compare, and discuss different approaches to implementing network-based hardware accelerators in FPGA and programmable SoC (Systems-on-Chip). The performed analysis and the derived recommendations would be useful to hardware designers of future network-based hardware accelerators.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Accelerating population count with a hardware co-processor for microblaze",
        "doc_scopus_id": "85108422282",
        "doc_doi": "10.3390/JLPEA11020020",
        "doc_eid": "2-s2.0-85108422282",
        "doc_date": "2021-06-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2021 by the author. Licensee MDPI, Basel, Switzerland.This paper proposes a Field-Programmable Gate Array (FPGA)-based hardware accelerator for assisting the embedded MicroBlaze soft-core processor in calculating population count. The population count is frequently required to be executed in cyber-physical systems and can be applied to large data sets, such as in the case of molecular similarity search in cheminformatics, or assisting with computations performed by binarized neural networks. The MicroBlaze instruction set architecture (ISA) does not support this operation natively, so the count has to be realized as either a sequence of native instructions (in software) or in parallel in a dedicated hardware accelerator. Different hardware accelerator architectures are analyzed and compared to one another and to implementing the population count operation in MicroBlaze. The achieved experimental results with large vector lengths (up to 217) demonstrate that the best hardware accelerator with DMA (Direct Memory Access) is ~31 times faster than the best software version running on MicroBlaze. The proposed architectures are scalable and can easily be adjusted to both smaller and bigger input vector lengths. The entire system was implemented and tested on a Nexys-4 prototyping board containing a low-cost/low-power Artix-7 FPGA.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware Accelerators for Data Processing in High-Performance Computing Systems",
        "doc_scopus_id": "85123798232",
        "doc_doi": "10.1109/AICT52784.2021.9620439",
        "doc_eid": "2-s2.0-85123798232",
        "doc_date": "2021-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "Accelerator architectures",
            "Hardware accelerators",
            "Hardware resources",
            "High performance computing systems",
            "Modeling in software",
            "Processing time",
            "Reconfigurable-systems",
            "Searching data",
            "Sorting data"
        ],
        "doc_abstract": "© 2021 IEEE.This tutorial overviews reconfigurable hardware accelerators that have been proposed for data processing in high-performance computing systems. They are based on different kinds of networks (sorting, searching, counting, etc.) and recur to iterative implementations that allow the required hardware resources to be significantly reduced almost without compromising the respective processing times. The accelerator architectures are first modelled in software and then implemented in reconfigurable hardware. The results of experiments are reported and references are given to more detailed descriptions of all the design and validation steps.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Preface",
        "doc_scopus_id": "85119837668",
        "doc_doi": null,
        "doc_eid": "2-s2.0-85119837668",
        "doc_date": "2021-01-01",
        "doc_type": "Editorial",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": null,
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware accelerators for information processing in high-performance computing systems",
        "doc_scopus_id": "85060436269",
        "doc_doi": "10.24507/ijicic.15.01.321",
        "doc_eid": "2-s2.0-85060436269",
        "doc_date": "2019-02-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            }
        ],
        "doc_keywords": [
            "Data extraction",
            "Hardware accelerators",
            "High performance computing systems",
            "Large datasets",
            "Programmable system on chips",
            "Programmable systems",
            "Rapid extraction"
        ],
        "doc_abstract": "© 2019, ICIC International. All rights reserved.A frequent problem in information processing is the rapid extraction and subsequent analysis of subsets of data that have to be formed from external requests supplying some filtering constraints. The subsets are composed of items that more or less (i.e., not exactly) satisfy the desired requirements and further improvement is needed to find elements that meet the constraints. The paper suggests methods and circuits that accelerate operations on the subsets and data extraction in such a way that: a) the number of items that meet the requirements exactly is determined, and b) all such items are extracted. It is proposed that the subsets are represented in the form of special tables and to process such tables. The problem is divided in two parts that are solved in software and in hardware correspondingly. The first part is the extraction of subsets from large data sets and this is done either in a general-purpose computer or in embedded to programmable system-on-chip processors. The second part, which is the main target of this paper, is the manipulation and analysis of subsets (tables) in hardware accelerators. The results of experiments clearly demonstrate the advantages of the proposed technique over existing methods in terms of both cost and throughput.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware accelerators for data sort",
        "doc_scopus_id": "85066962290",
        "doc_doi": "10.1007/978-3-030-20721-2_4",
        "doc_eid": "2-s2.0-85066962290",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Alternative solutions",
            "Communication overheads",
            "Communication time",
            "Data processing techniques",
            "Hardware accelerators",
            "Important features",
            "Propagation delays",
            "Sequential computations"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.This chapter is dedicated to sorting networks with regular and easily scalable structures, which permit data to be sorted and a number of supplementary problems to be solved. Two core architectures are discussed: (1) iterative that is based on a highly parallel combinational sorting network with minimal propagation delay, and (2) communication-time allowing data to be processed as soon as a new item is received and, thus, minimizing communication overhead that is frequently pointed out as the main bottleneck in system performance. The architectures are modeled in software (using Java language) and implemented in FPGA. It is shown that sorting is a base for many other data processing techniques, some of which have already been discussed in Chap. 3. Several new problems that are important for practical applications are highlighted, namely retrieving maximum and/or minimum sorted subsets, filtering (making it possible a set of data with the desired characteristics to be extracted), processing non-repeated items applying the address-based technique that has already been used in the previous chapter, traditional pipelining together with the introduced ring pipeline. The primary emphasis is on such important features as efficient pre-processing, uniformity of core components, rational combination of parallel, pipelined and sequential computations, and regularity of the circuits and interconnections. Potential alternative solutions are demonstrated and discussed. Many examples are given and analyzed with all necessary details.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Architectures of FPGA-based hardware accelerators and design techniques",
        "doc_scopus_id": "85066952203",
        "doc_doi": "10.1007/978-3-030-20721-2_2",
        "doc_eid": "2-s2.0-85066952203",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Alternative solutions",
            "Design and implementations",
            "FPGA-based hardware accelerators",
            "Hardware accelerators",
            "Hardware descriptions",
            "Processing operations",
            "Reusable components",
            "Sequential computations"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.This chapter demonstrates distinctive features of FPGA-based hardware accelerators. In order to compete with the existing alternative solutions (both in hardware and in software) a wide level parallelism must be implemented in circuits with small propagation delays. For providing such characteristics several useful techniques are discussed and analyzed such as the ratio between combinational and sequential computations at different levels. Individual data items are represented in the form of long size input vectors that are processed concurrently in accelerators producing long size output vectors. Thus, pre- (conversion of individual items to long size input vectors) and post- (conversion of long size output vectors to individual items) processing operations have to be carried out. The technique of communication-time data processing is introduced and its importance is underlined. Core network-based architectures of hardware accelerators are discussed and the best architectures are chosen for future consideration. Finally, different aspects of design and implementation of FPGA-based hardware accelerators are analyzed and three sources for the designs are chosen that are synthesizable hardware description language specifications, the proposed reusable components, and intellectual property cores available on the market. At the end of the chapter a few useful examples are presented in detail and discussed.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware accelerators for data search",
        "doc_scopus_id": "85066948869",
        "doc_doi": "10.1007/978-3-030-20721-2_3",
        "doc_eid": "2-s2.0-85066948869",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Complicated systems",
            "Design technique",
            "Extreme value",
            "Frequent values",
            "Hardware accelerators",
            "Iterative searching",
            "Organized structure",
            "Very large datum"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.This chapter is dedicated to searching networks, which permit to find extreme values in a set of data and to check if there are items satisfying some predefined conditions or limitations, indicated by given thresholds. The simplest task is retrieving the maximum and/or the minimum values. More complicated procedures permit the most frequent value/item to be found and a set of the most frequent values/items above a given threshold or satisfying some other constraint to be retrieved. The described above tasks may be solved for entire data sets, for intervals of data sets, or for specially organized structures, such as Boolean/ternary matrices. Different architectures are proposed that rely on: combinational and iterative searching networks, address-based technique, and some others. They are modelled in software (using Java language) and implemented in FPGA on the basis of the design technique described in the previous chapter. All necessary details for software and the basic VHDL modules for FPGA are presented and discussed. Searching maximum/minimum items in very large data sets and pipelining are also overviewed. The networks of this chapter will be used as components of more complicated systems considered in subsequent chapters.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based hardware accelerators for selected computational problems",
        "doc_scopus_id": "85066940312",
        "doc_doi": "10.1007/978-3-030-20721-2_5",
        "doc_eid": "2-s2.0-85066940312",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Automatic Generation",
            "Combinatorial search",
            "Computational problem",
            "Counting networks",
            "FPGA-based hardware accelerators",
            "Hamming weights",
            "Low-level designs",
            "Mixed solution"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.This chapter is dedicated to several computational problems that can efficiently be solved in FPGA-based hardware accelerators. The base of them, which is described in detail, is Hamming weight counting and comparison, which has many practical applications. Three core methods are presented that are counting networks, low-level designs from elementary logic cells, and designs using arithmetical units. Mixed solutions that involve composition of different methods are also discussed. Automatic generation of constants for look-up tables is suggested. Many practical examples with synthesizable VHDL code are shown. Finally, applicability of the proposed methods is demonstrated on some problems from the scope of combinatorial search (namely, matrix/set covering), frequent items computations, filtering, and information processing.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware/software co-design",
        "doc_scopus_id": "85066935447",
        "doc_doi": "10.1007/978-3-030-20721-2_6",
        "doc_eid": "2-s2.0-85066935447",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Application specific",
            "Communication overheads",
            "Hardware circuits",
            "Hardware implementations",
            "Hardware/software",
            "Hardware/software partitioning",
            "Processing systems",
            "Programmable logic"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.For those problems allowing high-level parallelism to be applied, hardware implementations are generally faster than relevant software running in general-purpose and application-specific computers. However, software is more flexible and easily adaptable to potentially changing conditions and requirements. Besides, on-chip hardware circuits set a number of constraints, primarily on resources that limit the complexity of implemented designs. For example, searching and sorting networks can be mapped to commercial FPGAs for data sets not exceeding a few thousands of items. Usually, software enables designers/programmers to cope with the complexity of the developed products much easier than hardware. Thus, it is reasonable flexibility and maintainability of software to be rationally combined with the speed and other capabilities of hardware, which can be achieved in hardware/software co-design. This chapter is devoted to the relevant topics and discusses hardware/software partitioning, dedicated helpful blocks (namely, priority buffers), hardware/software interaction, and some useful methods allowing communication overhead to be reduced. A number of examples with systems-on-chip that combine software running in a processing system and hardware implemented in a programmable logic (in FPGA section) are given and discussed.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Preface",
        "doc_scopus_id": "85066934039",
        "doc_doi": null,
        "doc_eid": "2-s2.0-85066934039",
        "doc_date": "2019-01-01",
        "doc_type": "Editorial",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": null,
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable devices and design tools",
        "doc_scopus_id": "85066922588",
        "doc_doi": "10.1007/978-3-030-20721-2_1",
        "doc_eid": "2-s2.0-85066922588",
        "doc_date": "2019-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Circuit specifications",
            "Design environment",
            "Design Methodology",
            "Hardware accelerators",
            "Hardware descriptions",
            "Platform independent",
            "Programmable systems",
            "Reconfigurable devices"
        ],
        "doc_abstract": "© Springer Nature Switzerland AG 2019.This chapter gives a short introduction to reconfigurable devices (Field-Programmable Gate Arrays—FPGA and hardware programmable Systems-on-Chip—SoC), design languages, methods, and tools that will be used in the book. The core reconfigurable elements and the most common embedded blocks are briefly characterized. A generic design flow is discussed and some examples are given that are ready to be tested in FPGA/SoC-based prototyping boards. All the subsequent chapters of the book will follow the suggested design methodology that includes: (1) proposing and evaluating basic architectures that are well suited for hardware accelerators; (2) modeling the chosen architectures in software (in Java language); (3) extracting the core components of future accelerators and generating (in software) fragments for synthesizable hardware description language specifications; (4) mapping the software models to hardware designs; (5) synthesis, implementation, and verification of the accelerators in hardware. The first chapter gives minimal necessary details and the background needed for the next chapters. All circuit specifications will be provided in VHDL. We will use Xilinx Vivado 2018.3 as the main design environment but will try to keep the proposed circuit specifications as platform independent as possible. An overview of the problems addressed in the book is also done and an introduction to different kinds of network-based processing is provided.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Intelligent management system of production and quality products for the small and medium business enterprises",
        "doc_scopus_id": "85039966449",
        "doc_doi": "10.15199/48.2018.01.38",
        "doc_eid": "2-s2.0-85039966449",
        "doc_date": "2018-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2018, Wydawnictwo SIGMA - N O T Sp. z o.o. All rights reserved.The article presents a model of fuzzy quality control of a company. The practical relevance of the research consists in the potential use of the developed system as a universal tool to assess efficiency of food production process quality management and to develop a package of actions to increase efficiency of the quality management system. The developed model enables to forecast and manage quality parameters of the manufactured products.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Exploration of high-performance ports in Zynq-7000 devices with different traffic conditions",
        "doc_scopus_id": "85046670858",
        "doc_doi": "10.1109/ICEE-B.2017.8192204",
        "doc_eid": "2-s2.0-85046670858",
        "doc_date": "2017-12-12",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Instrumentation",
                "area_abbreviation": "PHYS",
                "area_code": "3105"
            },
            {
                "area_name": "Control and Optimization",
                "area_abbreviation": "MATH",
                "area_code": "2606"
            }
        ],
        "doc_keywords": [
            "Actual throughputs",
            "Parallel Computation",
            "Performance degradation",
            "Real-time embedded systems",
            "Traffic conditions"
        ],
        "doc_abstract": "© 2017 IEEE.This paper presents experimental results that allow high-performance ports in Zynq microchips to be evaluated taking into account parallel computations and their influence on throughput of FIR filters. All projects are based on Xilinx components. We found that although parallel traffic leads to performance degradation, actual throughput is reduced not very significantly. The results of experiments are discussed.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Network-based priority buffer",
        "doc_scopus_id": "85046641510",
        "doc_doi": "10.1109/ICEE-B.2017.8192203",
        "doc_eid": "2-s2.0-85046641510",
        "doc_date": "2017-12-12",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Instrumentation",
                "area_abbreviation": "PHYS",
                "area_code": "3105"
            },
            {
                "area_name": "Control and Optimization",
                "area_abbreviation": "MATH",
                "area_code": "2606"
            }
        ],
        "doc_keywords": [
            "Design environment",
            "Fast electronics",
            "Hardware resources",
            "Network-based",
            "Potential sources",
            "priority buffer",
            "Real-time data",
            "Real-time embedded systems"
        ],
        "doc_abstract": "© 2017 IEEE.The paper suggests very fast electronic solutions for priority buffers that take data from many potential sources, accumulate them in a register, and output the most priority item in run time in such a way that as soon as a new value arrives it is included in the set with all previously received and untreated items and properly handled. It is shown that such circuits are required for real time embedded and cyber-physical systems. The buffer was first simulated in a Java program (in software) that allows to verify the intended functionality and then prototyped in hardware using commercially available prototyping boards with field-programmable gate arrays and up-to-date design environment, namely Vivado 2017.1. The best-known alternatives are briefly described and analyzed. The results of experiments have shown that the proposed solutions consume comparable hardware resources and are significantly faster. They may be used not only for priority management but also for real-time data sort.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "RAM-based mergers for data sort and frequent item computation",
        "doc_scopus_id": "85027691153",
        "doc_doi": "10.23919/MIPRO.2017.7973413",
        "doc_eid": "2-s2.0-85027691153",
        "doc_date": "2017-07-10",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Instrumentation",
                "area_abbreviation": "PHYS",
                "area_code": "3105"
            }
        ],
        "doc_keywords": [
            "General purpose software",
            "High performance computing systems",
            "Parallel data",
            "Parallel sorting",
            "Proposed architectures",
            "Reconfigurable computing",
            "Sorting network",
            "Streaming data"
        ],
        "doc_abstract": "© 2017 Croatian Society MIPRO.Data sorting and frequent item computation are important tasks in data processing. The paper suggests an architecture for parallel data sorting with simultaneous counting of every item frequency. The architecture is designed for streaming data and incorporates data sorting in hardware, merging of preliminary sorted blocks with compressing of repeated items with calculating of repetitions in hardware, and merging large subsets received from the hardware in general-purpose software. Hardware merge components of this architecture count and compress repeated items in sorted subsets in order to reduce merging time and prepare the data for frequent item computation. The results of experiments clearly demonstrate advantages of the proposed architectures.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable systems in engineering education: Best practices and future trends",
        "doc_scopus_id": "85023622828",
        "doc_doi": "10.1109/EDUCON.2017.7942983",
        "doc_eid": "2-s2.0-85023622828",
        "doc_date": "2017-06-07",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            },
            {
                "area_name": "Education",
                "area_abbreviation": "SOCI",
                "area_code": "3304"
            }
        ],
        "doc_keywords": [
            "Best practices",
            "Course structure",
            "Digital designs",
            "First year students",
            "FPGA technology",
            "Future trends",
            "Reconfigurable systems",
            "Two-level strategies"
        ],
        "doc_abstract": "© 2017 IEEE.Advantages of reconfigurable systems and their importance for engineering education are reported in many publications. The paper presents recent results in this area that are achieved within long-term collaboration of two Universities: University of Aveiro in Portugal and Tallinn University of Technology in Estonia. Many alternative curricula have been analyzed and tested, and finally the following two-level strategy has been chosen: 1) an introductive segment on FPGA technology is given within the disciplines on digital design for the first year students; 2) a number of advanced courses, one of which is obligatory and the other optional, are given for the fourth and fifth year students. The paper discusses the methodology that has been developed and successfully realized. We also demonstrate advantages of both the proposed course structure and continuous evaluation with the main objective to disseminate the results.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Secure design of communication networks",
        "doc_scopus_id": "85019197242",
        "doc_doi": "10.1109/Anti-Cybercrime.2017.7905289",
        "doc_eid": "2-s2.0-85019197242",
        "doc_date": "2017-04-19",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Safety Research",
                "area_abbreviation": "SOCI",
                "area_code": "3311"
            },
            {
                "area_name": "Safety, Risk, Reliability and Quality",
                "area_abbreviation": "ENGI",
                "area_code": "2213"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Law",
                "area_abbreviation": "SOCI",
                "area_code": "3308"
            }
        ],
        "doc_keywords": [
            "Fault injection attacks",
            "Hamming weights",
            "Hardware resources",
            "Micro-electronic devices",
            "Pseudorandom generators",
            "Receiving modules",
            "Transmitting data",
            "Transmitting module"
        ],
        "doc_abstract": "© 2017 IEEE.The paper is focused on increasing the security measures against malicious attacks by protecting hardware that exchange data. This is in contrast to studying or improving the existing methods that rely on only securing the data. We consider errors that may appear on a way between transmitting and receiving modules in different microelectronic devices and some of such errors may be injected by potential intruders (attackers). It is shown that although the known methods are sufficient they involve significant hardware resources and delays. We suggest detecting fault injection attacks through computing Hamming weights of each transmitting data combined with additional data created by a pseudo-random generator to be controlled by internal hardware of transmitting and receiving modules. Any generated number is known by the receiving and transmitting modules and it alters the final values of Hamming weights that can only be correctly recognized inside the transmitter/receiver. Our experiments have demonstrated that the proposed supplementary circuits allow the considered problem to be solved and they are very fast and moderate in resources.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Fast iterative circuits and RAM-based mergers to accelerate data sort in software/hardware systems",
        "doc_scopus_id": "85028310572",
        "doc_doi": "10.3176/proc.2017.3.07",
        "doc_eid": "2-s2.0-85028310572",
        "doc_date": "2017-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Communication time",
            "General purpose software",
            "Hardware resources",
            "Iterative networks",
            "Parallel data processing",
            "Peripheral component interconnect Express bus",
            "Proposed architectures",
            "Software functions"
        ],
        "doc_abstract": "© 2017 Authors.The paper suggests and describes two architectures for parallel data sort. The first architecture is applicable to large data sets and it combines three stages of data processing: data sorting in hardware (in a Field-Programmable Gate Arrays – FPGA), merging preliminary sorted blocks in hardware (in the FPGA), and merging large subsets received from the FPGA in general-purpose software. Data exchange between the FPGA and a general-purpose computer is organized through a fast Peripheral Component Interconnect (PCI) express bus. The second architecture is applicable to small data sets and it enables sorting to be done at the time of data acquisition, i.e. as soon as the last data item is received, the sorted items can be transferred immediately. The results of experiments clearly demonstrate the advantages of the proposed architectures that permit the reduction of the required hardware resources and increasing throughput compared to the results reported in publications and software functions targeted to data sorting.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Fast processing of non-repeated values in hardware",
        "doc_scopus_id": "85020550720",
        "doc_doi": "10.5755/j01.eie.23.3.18336",
        "doc_eid": "2-s2.0-85020550720",
        "doc_date": "2017-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The paper suggests a technique for fast data processing of unique and constrained items. The technique is based on two methods that involve: 1) address-based data sorting; and 2) communication-time networks. Input data are received one by one from a sequential channel. The first method enables undesirable values (e.g. previously taken or explicitly blocked) to be discarded. Although this method is chosen from the scope of data sorting, it is used in the paper (after some adjustments) for filtering. The second method enables each data item to be properly handled during communication time. For example, in case of data sorting it means that as soon as a new item is received it will immediately be placed in a proper position of the produced sorted subset that is composed of all previously acquired items. The circuits that implement the proposed methods have been entirely modeled and verified in software, then described in VHDL, synthesized and implemented in hardware, and finally evaluated. The results have shown that the proposed solutions are well suited for real-time applications.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Data processing in the firmware systems for logic control based on search networks",
        "doc_scopus_id": "85011838845",
        "doc_doi": "10.1134/S0005117917010088",
        "doc_eid": "2-s2.0-85011838845",
        "doc_date": "2017-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Configurable logic",
            "Experimental comparison",
            "Hardware accelerators",
            "Logic control",
            "Parallel network",
            "Pipeline processing",
            "Processor systems"
        ],
        "doc_abstract": "© 2017, Pleiades Publishing, Ltd.It was proposed to use the hardware accelerators for analysis and data processing in the systems of logic control on a chip including the interacting processor system, memory, and configurable logic components. The data processing expected execution of operations over the sets of elements each of which can be activated by software and realized in the hardware in parallel networks admitting, if necessary, pipeline processing. New methods of design and use of the sorting and search networks were proposed, and the results of their theoretical and experimental comparison with the existing networks were presented.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Digital design: Best practices and future trends",
        "doc_scopus_id": "85002489691",
        "doc_doi": "10.1109/BEC.2016.7743718",
        "doc_eid": "2-s2.0-85002489691",
        "doc_date": "2016-11-14",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Best practices",
            "Contemporary techniques",
            "Design method",
            "Digital designs",
            "Parallelism and concurrencies",
            "Parameterization method",
            "Reconfigurable systems",
            "Reconfigurable technologies"
        ],
        "doc_abstract": "© 2016 IEEE.The paper is dedicated to specification, synthesis, and implementation of digital systems. The emphasis is done on application of reconfigurable technology, which is widely employed today. At the beginning, traditional methods of digital design are briefly reviewed and it is shown how these methods can be adapted to new computer-aided tools. The importance of hardware and system-level description languages as well as hierarchical specifications and designs is emphasized. Then contemporary techniques are discussed namely the usage of templates, intellectual property cores, block-based diagrams that enable different cores to be integrated, and parameterization methods. A number of examples are given. To increase system performance parallelism and concurrency are widely applied and we will demonstrate how they can be used efficiently. Since digital devices need to be further integrated into more complicated systems, we will discuss also such topics as hardware/software interactions and interfaces. Finally, a number of methods developed by the authors will be presented and illustrated on examples. They are from the scope of hierarchical design, logical synthesis, parallel networks for sorting/searching, combinatorial optimization, and hardware/software co-design.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Interactions of Zynq-7000 devices with general purpose computers through PCI-express: A case study",
        "doc_scopus_id": "84979221621",
        "doc_doi": "10.1109/MELCON.2016.7495400",
        "doc_eid": "2-s2.0-84979221621",
        "doc_date": "2016-06-20",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Energy Engineering and Power Technology",
                "area_abbreviation": "ENER",
                "area_code": "2102"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Renewable Energy, Sustainability and the Environment",
                "area_abbreviation": "ENER",
                "area_code": "2105"
            },
            {
                "area_name": "Automotive Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2203"
            }
        ],
        "doc_keywords": [
            "Evaluation board",
            "Intellectual property cores",
            "PCI Express",
            "PCI Express bus",
            "Processing systems",
            "Programmable logic",
            "Programmable systems",
            "Protocol overhead"
        ],
        "doc_abstract": "© 2016 IEEE.The paper analyses interactions of all programmable systems-on-chip (Xilinx Zynq-7000 devices) with host computers through fast PCI-express bus. A case study of such interactions is presented for Xilinx ZC706 evaluation board that enables PCIe ×4 Gen2 communications. The developed driver for Linux applications in PC provides read/write functions for general-purpose programs that enable data transfers through PCI express bus in both directions. The necessary modules were designed at three different levels: 1) host PC software running under Linux; 2)Zynq-7000 software developed in Xilinx SDK from C language; 3)hardware synthesized from VHDL specifications in Xilinx Vivado suite and linked with the available intellectual property cores. All the described components were implemented and tested and the results of experiments are reported. The speed of data transfers is close to the maximum theoretically attainable speed but it takes into account all necessary protocol overheads. Potential limitations and problems are also discussed and practical applications are shown.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "High-performance information processing in distributed computing systems",
        "doc_scopus_id": "84957052837",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84957052837",
        "doc_date": "2016-02-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            }
        ],
        "doc_keywords": [
            "Biological applications",
            "Distributed computing systems",
            "High performance computing systems",
            "Highly parallels",
            "PCI Express bus",
            "Programmable system on chips",
            "Searching",
            "Systems on chips"
        ],
        "doc_abstract": "© 2016, ICICI International .This paper explores distributed computing systems that may be used efficiently in information processing that is frequently needed in electronic, environmental, medical, and biological applications. Three major components of such systems are: 1) data acquisition and preprocessing; 2) transmitting the results of preprocessing to a higher level computing system that is a PC; and 3) post processing in higher level computing system (in the PC). Preprocessing can be done in highly parallel accelerators that are mapped to reconfigurable hardware. The core of an accelerator is a sorting/searching network that is implemented either in an FPGA or in a programmable system-on-chip (such as Zynq devices). Data is transmitted to a PC through a high-bandwidth PCI-express bus. The paper suggests novel solutions for sorting/searching networks that enable the number of data items that can be handled to be significantly increased compared to the best known alternatives, maintaining a very high processing speed that is either similar to, or higher than in the best known alternatives. Preprocessing can also include supplementary tasks, such as extracting the minimum/maximum sorted subsets, finding the most frequently occurring items, and filtering the data. A higher level computing system executes final operations, such as merging the blocks produced by the sorting networks, implementing higher level algorithms that use the results of preprocessing, statistical manipulation, analysis of existing and acquired sets, data mining. It is shown through numerous experiments that the proposed solutions are very effective and enable a more diverse range of problems to be solved with better performance.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis and implementation of parallel logic controllers in all programmable systems-on-chip",
        "doc_scopus_id": "85028970998",
        "doc_doi": "10.1007/978-3-319-26725-8_2",
        "doc_eid": "2-s2.0-85028970998",
        "doc_date": "2016-01-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Computer Science (miscellaneous)",
                "area_abbreviation": "COMP",
                "area_code": "1701"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Automotive Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2203"
            },
            {
                "area_name": "Social Sciences (miscellaneous)",
                "area_abbreviation": "SOCI",
                "area_code": "3301"
            },
            {
                "area_name": "Economics, Econometrics and Finance (miscellaneous)",
                "area_abbreviation": "ECON",
                "area_code": "2001"
            },
            {
                "area_name": "Control and Optimization",
                "area_abbreviation": "MATH",
                "area_code": "2606"
            },
            {
                "area_name": "Decision Sciences (miscellaneous)",
                "area_abbreviation": "DECI",
                "area_code": "1801"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2016, Springer International Publishing Switzerland.The chapter is dedicated to the design of logic controllers with customizable behavior in all programmable systems-on-chip in such a way that the desired functionality is defined in software of a processing systemsystem and realized in hardware of reconfigurable logic. The controllers implement algorithms described in form of parallel hierarchical graph-schemes that are built in software from predefined modules. Parallel hierarchical circuits of the controllers are mapped to the reconfigurable logic customized from software through high-performance interfaces. The circuits generate control signals to determine the desired functionality of external devices. A number of experiments are done in Xilinx Zynq-7000 microchips and the results are reported.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Software/hardware solutions for information processing in all programmable systems-on-chip",
        "doc_scopus_id": "85010711346",
        "doc_doi": null,
        "doc_eid": "2-s2.0-85010711346",
        "doc_date": "2016-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "Algorithms in computer engineering and applied informatics often require extraction of data with some desired properties from large sets. Such tasks appear within different clustering algorithms in the scope of data mining, in classification of objects in accordance with given criteria, in knowledge acquisition obtained from controlled environments, in statistical analysis and in other areas. Many of these tasks involve widely used data processing techniques that are sorting and searching and for numerous practical applications, especially in real-time and high-performance systems, speeding-up is important. The paper suggests effective portable solutions that enable fast parallel information processing to be implemented in all-programmable systems-on-chip that combine multi-core computations with programmable logic interacting through multiple high-performance interfaces. Acceleration is achieved with parallel networks for data sorting created in programmable logic and enabling software running in multi-core processing units to be speeded-up, which is demonstrated in numerous practical examples fully implemented and tested in commercial microchips.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Fast data sort based on searching networks with ring pipeline",
        "doc_scopus_id": "84983089365",
        "doc_doi": "10.5755/j01.eie.22.4.15920",
        "doc_eid": "2-s2.0-84983089365",
        "doc_date": "2016-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The paper suggests a technique for fast data sort based on a specially organized binary searching network with the following new distinctive features: 1) data sort is done within the time of data acquisition through a serial interface; 2) a new type of pipeline, which we call ring pipeline, is created 3) the delay for receiving each data item is minimized thanks to the novel ring pipeline; 4) sorted data can be transmitted almost immediately after receiving the last input item; 5) several data sets may be sorted by the same network at the same acquisition time. It is proved theoretically that the network is very fast. It was modelled and evaluated in software and the basic components were synthesized and implemented in hardware. The results have shown a significant speed-up comparing to the best known alternatives.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "On-chip reconfigurable hardware accelerators for popcount computations",
        "doc_scopus_id": "84961904282",
        "doc_doi": "10.1155/2016/8972065",
        "doc_eid": "2-s2.0-84961904282",
        "doc_date": "2016-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [
            "Chemical informatics",
            "Combinatorial search",
            "Communication overheads",
            "Hardware accelerators",
            "Programmable logic",
            "Programmable systems",
            "Software implementation",
            "Three level systems"
        ],
        "doc_abstract": "© 2016 Valery Sklyarov et al.Popcount computations are widely used in such areas as combinatorial search, data processing, statistical analysis, and bio- and chemical informatics. In many practical problems the size of initial data is very large and increase in throughput is important. The paper suggests two types of hardware accelerators that are (1) designed in FPGAS and (2) implemented in Zynq-7000 all programmable systems-on-chip with partitioning of algorithms that use popcounts between software of ARM Cortex-A9 processing system and advanced programmable logic. A three-level system architecture that includes a general-purpose computer, the problem-specific ARM, and reconfigurable hardware is then proposed. The results of experiments and comparisons with existing benchmarks demonstrate that although throughput of popcount computations is increased in FPGA-based designs interacting with general-purpose computers, communication overheads (in experiments with PCI express) are significant and actual advantages can be gained if not only popcount but also other types of relevant computations are implemented in hardware. The comparison of software/hardware designs for Zynq-7000 all programmable systems-on-chip with pure software implementations in the same Zynq-7000 devices demonstrates increase in performance by a factor ranging from 5 to 19 (taking into account all the involved communication overheads between the programmable logic and the processing systems).",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Computing sorted subsets for data processing in communicating software/hardware control systems",
        "doc_scopus_id": "84957098357",
        "doc_doi": "10.15837/ijccc.2016.1.1442",
        "doc_eid": "2-s2.0-84957098357",
        "doc_date": "2016-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2006-2015 by CCC Publications.Computing and filtering sorted subsets are frequently required in statistical data manipulation and control applications. The main objective is to extract subsets from large data sets in accordance with some criteria, for example, with the maximum and/or the minimum values in the entire set or within the predefined constraints. The paper suggests a new computation method enabling the indicated above problem to be solved in all programmable systems-on-chip from the Xilinx Zynq family that combine a dual-core Cortex-A9 processing unit and programmable logic linked by high-performance interfaces. The method involves highly parallel sorting networks and run-time filtering. The computations are done in communicating software, running in the processing unit, and hardware, implemented in the programmable logic. Practical applications of the proposed technique are also shown. The results of implementation and experiments clearly demonstrate significant speed-up of the developed software/hardware system comparing to alternative software implementations.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "On-chip hardware accelerators for data processing and combinatorial search",
        "doc_scopus_id": "84960882337",
        "doc_doi": "10.1109/ICAICT.2015.7338515",
        "doc_eid": "2-s2.0-84960882337",
        "doc_date": "2015-11-25",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "Combinatorial search",
            "Development technique",
            "Hardware accelerators",
            "High performance computing",
            "Information and communication",
            "Multiple function",
            "parallelism",
            "Programmable systems"
        ],
        "doc_abstract": "© 2015 IEEE.Data processing and combinatorial search are widely used techniques in the scope of information and communication. Examples of practical applications are sorting, frequent items encountering, matrix/set covering, graph/map coloring, data mining, priority management, and many others. Often information/data processing that involves the listed above tasks has to be done in embedded systems where high performance needs to be achieved in portable and low-cost devices integrating multiple functions and capabilities. An efficient development technique for such systems is hardware/software co-design with the use of programmable systems-on-chip that are highly integrated, easily customizable/configurable and permit broad parallelism to be supported that is the primary way to accelerate computations. The tutorial is dedicated to such a design technique.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based time and cost effective Hamming weight comparators for binary vectors",
        "doc_scopus_id": "84961719984",
        "doc_doi": "10.1109/EUROCON.2015.7313700",
        "doc_eid": "2-s2.0-84961719984",
        "doc_date": "2015-10-30",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Energy Engineering and Power Technology",
                "area_abbreviation": "ENER",
                "area_code": "2102"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Basic elements",
            "Binary vectors",
            "Cost effective",
            "Design technique",
            "Hamming weights",
            "Look up table",
            "Parallel processing"
        ],
        "doc_abstract": "© 2015 IEEE.The paper shows that resources and performance of Hamming weight comparators for binary vectors significantly depend on available basic elements from which the comparators are built and, thus, to optimize the final circuits different design techniques need to be applied. The presented analysis of existing solutions clearly demonstrates that although they may be efficient for one platform (such as fully customized circuits), for another platform (such as FPGA) they become not advantageous at all. The paper suggests several, supplementing each other, Hamming weight counters and comparators based on optimized mapping of the circuits to FPGA look-up tables giving the best performance and the fewest resources compared to the best known alternatives. It is shown that the proposed methods are easily adjustable to a wide range of problem dimensions. Besides, the paper gives well-defined recommendations that enable the most appropriate circuit to be chosen for particular requirements such as the size of the vectors and the required performance. Final evaluations of the results have been done through prototyping in FPGAs and comparison with the best known alternatives.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Analysis and comparison of attainable hardware acceleration in all programmable systems-on-chip",
        "doc_scopus_id": "84983127575",
        "doc_doi": "10.1109/DSD.2015.45",
        "doc_eid": "2-s2.0-84983127575",
        "doc_date": "2015-10-20",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            }
        ],
        "doc_keywords": [
            "Communication overheads",
            "Complete solutions",
            "Hardware acceleration",
            "High-performance ports",
            "Programmable system on chips",
            "Programmable systems",
            "Software and hardwares",
            "Software/hardware"
        ],
        "doc_abstract": "© 2015 IEEE.Zynq-7000 devices from Xilinx incorporate a dual-core processing unit running software, programmable logic that can be customized to implement different hardware circuits, and interfaces enabling interactions and data exchange between software and hardware components to be provided. Such devices permit complete solutions for embedded systems to be integrated on a chip. The paper compares different types of Zynq-based systems and studies communications between the processing unit and the programmable logic. Thorough evaluation of the available on-chip high-performance interfaces is done based on the results of numerous experiments. Two types of projects that are data sorters and popcount computations were chosen for particular assessments. We found that efficiency of software/hardware solutions depends on many mutually related factors such as the volume of processed data, applied parallelism, and involved high-performance ports. Concrete recommendations based on experiments and comparisons are given and discussed.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Multi-core DSP-based vector set bits counters/comparators",
        "doc_scopus_id": "84928376304",
        "doc_doi": "10.1007/s11265-014-0915-y",
        "doc_eid": "2-s2.0-84928376304",
        "doc_date": "2015-09-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Signal Processing",
                "area_abbreviation": "COMP",
                "area_code": "1711"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Modeling and Simulation",
                "area_abbreviation": "MATH",
                "area_code": "2611"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [
            "Core components",
            "Fixed threshold",
            "Hamming weights",
            "Hardware accelerators",
            "Hardware/software",
            "On chips",
            "Prototyping systems",
            "Software and hardwares"
        ],
        "doc_abstract": "© 2014, Springer Science+Business Media New York.The paper shows that fast counting non-zero components (Hamming weights) and comparing the results (Hamming distances) in large sets of data items is important for numerous practical applications and this problem has been broadly investigated by software and hardware designers. It is frequently referenced as population or vector set bits count (or simply popcount). This paper is dedicated to multi-core FPGA-based accelerators that compute Hamming weights/distances and compare the results with fixed thresholds and variable bounds. It is shown that widely available in contemporary FPGAs digital signal processing slices may be used efficiently and they provide the fastest and the less resource consuming solutions. A thorough analysis and comparison with the best known alternatives both in hardware and in software is presented and supported by numerous experiments in the recent Nexys-4, ZedBoard and ZyBo prototyping systems. Complete hardware description language (VHDL) specifications for core components are given ready to be synthesized, implemented, tested and evaluated. Experiments with the proposed designs clearly demonstrate significant speed-up comparing to known hardware/software alternatives.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Integration of high-level synthesis to the courses on reconfigurable digital systems",
        "doc_scopus_id": "84946140676",
        "doc_doi": "10.1109/MIPRO.2015.7160258",
        "doc_eid": "2-s2.0-84946140676",
        "doc_date": "2015-07-15",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Computing system",
            "Design philosophy",
            "Digital system design",
            "Industry requirements",
            "Programmable logic",
            "Programmable systems",
            "Software Specification",
            "Teaching methods"
        ],
        "doc_abstract": "© 2015 MIPRO.Digital system design constitutes an essential part of engineering education. Many universities worldwide target the respective courses to field-programmable gate arrays and the relevant design flow. Recent programmable systems-on-chip integrating a processor-based computing system and a programmable logic rely on quite a different design philosophy constituting a new challenge for future engineers. These new trends have to be certainly reflected in the pedagogical activity so that the current students would, in a few years, satisfy the growing industry requirements. In this paper we analyze the new design flow and explore in detail one particular part of it: a possibility of directly generating hardware modules from software specifications through high-level synthesis. The reported teaching method is to be applied in two tightly collaborating Universities: University of Aveiro in Portugal and Tallinn University of Technology in Estonia.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware accelerators for information retrieval and data mining",
        "doc_scopus_id": "84944145029",
        "doc_doi": "10.1109/ICTRC.2015.7156457",
        "doc_eid": "2-s2.0-84944145029",
        "doc_date": "2015-07-14",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (miscellaneous)",
                "area_abbreviation": "COMP",
                "area_code": "1701"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Database management",
            "Hardware accelerators",
            "Hierarchical merging",
            "Highly parallels",
            "Parallel processing",
            "Statistical datas",
            "Support method"
        ],
        "doc_abstract": "© 2015 IEEE.Many algorithms in informatics require a set of objects with similar properties to be grouped (clustered) on the basis of some predefined criteria. The proposed technique involves hierarchical merging in which software, responsible for solving the entire problem, is enhanced with highly parallel networks in hardware accelerators. Additional improvements are achieved with the aid of support methods that are sort and verification of object intersections that may also be autonomously used for other types of information processing and database management. It is shown and experimentally proved that the proposed solutions are efficient. They can be used in such areas as health care, statistical data manipulation and so on.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design and implementation of counting networks",
        "doc_scopus_id": "84929321472",
        "doc_doi": "10.1007/s00607-013-0360-y",
        "doc_eid": "2-s2.0-84929321472",
        "doc_date": "2015-06-18",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Numerical Analysis",
                "area_abbreviation": "MATH",
                "area_code": "2612"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computational Mathematics",
                "area_abbreviation": "MATH",
                "area_code": "2605"
            }
        ],
        "doc_keywords": [
            "Design and implementations",
            "Hamming weights",
            "Important features",
            "Parallel circuits",
            "Performance analysis",
            "Pipelined implementation",
            "Propagation delays",
            "Reduced complexity"
        ],
        "doc_abstract": "© 2013, Springer-Verlag Wien.The paper describes Hamming weight counters/comparators built on counting networks that incorporate two distinctive and important features. The counting networks are composed of simple logic (core) elements with incrementally reducing numbers of elements from the inputs to the outputs. This feature provides the same performance as the best known sorting networks with radically reduced complexity. Compared to a competitive design based on parallel counters, the propagation delays of signals passing through data independent segments within the circuit are shortened, which allows faster pipelined implementations. Several types of counting networks are elaborated, namely pure combinational, partially sequential with reusable fragments, and pipelined. The correctness of the proposed concept and scalability of the networks are proven. Formal expressions to estimate the complexity and throughput of the network are given. Finally, the results of extensive experiments, evaluations and comparisons are reported that demonstrate that the solutions proposed offer better characteristics than the best known alternatives.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Zynq-based system for extracting sorted subsets from large data sets",
        "doc_scopus_id": "84936950558",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84936950558",
        "doc_date": "2015-06-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electronic, Optical and Magnetic Materials",
                "area_abbreviation": "MATE",
                "area_code": "2504"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© MIDEM Society.The paper describes hardware/software architecture of a system for extracting the maximum and minimum sorted subsets from large data sets, two methods that enable high-level parallelism to be achieved, and implementation of the system in recently appeared on the market Zynq-7000 microchips incorporating a high-performance processing unit and advanced programmable logic from the Xilinx 7th family. The methods are based on highly parallel and easily scalable sorting networks and the proposed technique enabling sorted subsets to be extracted incrementally with very high speed that is close to the speed of data transfer through high-performance interfaces. The results of implementations and experiments clearly demonstrate significant speed-up of the developed software/hardware system comparing to alternative software implementations.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Comparison of On-chip Communications in Zynq-7000 All Programmable Systems-on-Chip",
        "doc_scopus_id": "84924331822",
        "doc_doi": "10.1109/LES.2015.2399656",
        "doc_eid": "2-s2.0-84924331822",
        "doc_date": "2015-03-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Communication overheads",
            "high-performance ports",
            "Processing systems",
            "Programmable logic",
            "Programmable systems"
        ],
        "doc_abstract": "© 2009-2012 IEEE.This letter analyses and compares on-chip interfaces for hardware/software communications in the Zynq-7000 all programmable systems-on-chip. Many experiments were carried out to evaluate the exchange of data between the processing system and the programmable logic through general-purpose and high-performance ports; the experiments were conducted for both standalone and Linux applications. The results enable the most effective interfaces for specific types of data to be identified and the effectiveness of Zynq-based hardware accelerators to be assessed.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware accelerators for data sort in all programmable systems-on-chip",
        "doc_scopus_id": "84949995957",
        "doc_doi": "10.4316/AECE.2015.04002",
        "doc_eid": "2-s2.0-84949995957",
        "doc_date": "2015-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2015 AECE.1Abstract-The paper analyzes and evaluates architectures of the most efficient hardware accelerators for data sort in FPGA and all programmable systems-on-chip (such as devices from the Xilinx Zynq-7000 family). The following novel methods are proposed and discussed: 1) data sorting in hardware that is executed concurrently with getting inputs through single or multiple ports; 2) a technique allowing rational compromise between the cost and the latency of the circuit to be achieved. Both methods are targeted to hardware/software co-design and permit the best solution to be found for different requirements within pre-defined constraints. The results of experiments, implementations, and rigorous comparisons demonstrate high efficiency and broad applicability of the proposed methods for wide range of practical applications.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Processing sorted subsets in a multi-level reconfigurable computing system",
        "doc_scopus_id": "84928680168",
        "doc_doi": "10.5755/j01.eee.21.2.11509",
        "doc_eid": "2-s2.0-84928680168",
        "doc_date": "2015-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "© 2015, Kauno Technologijos Universitetas. All rights reserved.The paper suggests a technique for extracting and filtering sorted subsets in a three-level computing system with such sub-systems as general-purpose computer (level 1), ARM Cortex-A9 (level 2), and reconfigurable logic (level 3). The last two levels are implemented in Zynq-7000 device available on the prototyping board ZC706. Communications between the levels 1 and 2-3 are organized through PCI express bus and interactions between components of levels 2 and 3 - through on-chip AXI interfaces. We studied two levels of software programs (running in PC and ARM), high-performance hardware accelerators implemented in Zynq-7000 programmable logic, and architecture enabling interactions and exchange of data between different levels. The selected for analysis sorting problem has high computational complexity and is widely required in data processing (data mining and statistical data manipulation, in particular). The results of experiments demonstrate that the elaborated architecture is efficient and permits fast solutions to be found. Proposals for potential further improvements are also given.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design space exploration in multi-level computing systems",
        "doc_scopus_id": "84908701584",
        "doc_doi": "10.1145/2659532.2659616",
        "doc_eid": "2-s2.0-84908701584",
        "doc_date": "2014-06-27",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Human-Computer Interaction",
                "area_abbreviation": "COMP",
                "area_code": "1709"
            },
            {
                "area_name": "Computer Vision and Pattern Recognition",
                "area_abbreviation": "COMP",
                "area_code": "1707"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Computing system",
            "Design space exploration",
            "Hardware/software systems",
            "Host computers",
            "Peripheral devices",
            "Processing systems",
            "Programmable logic",
            "Programmable system on chips"
        ],
        "doc_abstract": "Copyright © 2014 ACM.The paper is dedicated to the design space exploration for Xilinx devices from Zynq-7000 family with such architecture that includes a dual-core processing system and a programmable logic on the same microchip. The developed multi-level computing system enables three subsystems to be combined that are: a personal host computer, a Zynq-based hardware/software system and peripheral devices. Interactions with the host computer are provided through files that are used to supply data to the Zynq device and to get the results from the Zynq device. For interactions between software running in the Zynq processing system and hardware implemented in the Zynq programmable logic, different types of interfaces have been supported. A number of peripheral modules for using such devices as VGA monitors and keypads have been designed. The paper reports the results of integration of the developed components and proposals for using such system in practical applications.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "High-performance data processing over N-ary trees",
        "doc_scopus_id": "84929289360",
        "doc_doi": "10.1007/978-1-4614-1791-0_8",
        "doc_eid": "2-s2.0-84929289360",
        "doc_date": "2014-03-01",
        "doc_type": "Book Chapter",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Circuits and systems",
            "Combinatorial search",
            "Hierarchical clusters",
            "Hierarchical finite state machines",
            "High performance computation",
            "Models of computation",
            "Processing elements",
            "Software libraries"
        ],
        "doc_abstract": "© 2013 Springer Science+Business Media, LLC. All rights are reserved.An N-ary tree (N≥2) is a connected graph that does not contain cycles and has up to N children for any node. It can be used efficiently to represent data in well-structured hierarchical clusters and to process the data through the parent-child relationships. Several branches of a tree can be handled concurrently, the data hierarchy is described explicitly, and recursion can easily be applied. Thus this model is very appropriate for parallel high-performance computations in areas such as data processing (e.g. sort and search), priority queue management, combinatorial searches and so forth. N-ary trees have been profoundly studied (primarily for N=2) and are supported by software libraries. FPGAs have large embedded dual-port memories with programmable data width for different ports, advanced logic capabilities, and a large potential for parallelism and these features enable N-ary trees with data operations associated with their nodes to be represented more compactly and processed more efficiently in FPGAs than in software. A number of recent research efforts are dedicated to high-performance computations in electronic circuits and systems without the direct use of processing elements, which undoubtedly introduce many constraints (e.g. pre-defined operand sizes, fixed instruction sets, limited concurrency and parallelism). This chapter presents recent advances in this area and is composed of four basic parts: (1) an overview of N-ary trees, their applications, and potential varieties; (2) a discussion of common techniques for implementing and processing N-ary trees in hardware, including their representation in memory, models of computations and algorithms; (3) a description of hierarchical finite-state machines (HFSMs) with extended capabilities (with datapath, in particular) that enable N-ary trees to be processed in hardware and provide support for parallelism, hierarchy and recursion; (4) examples, practical applications, experiments and comparisons of HFSMs. The last part shows that the circuits that have been implemented are faster than the alternatives, and this conclusion is confirmed by examples and experiments in several application areas.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Programmable systems-on-chip for information processing",
        "doc_scopus_id": "84988273254",
        "doc_doi": "10.1109/ICAICT.2014.7035967",
        "doc_eid": "2-s2.0-84988273254",
        "doc_date": "2014-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Application specific",
            "Combinatorial search",
            "High performance computing",
            "Parallelism",
            "Programmable system on chips",
            "Programmable systems",
            "Software/hardware co designs",
            "System architectures"
        ],
        "doc_abstract": "Information processing is a very broad area in which many problems are computationally intensive and thus, they require parallelization and acceleration based on new technologies. The Xilinx Zynq-7000 all programmable system-on-chip can be seen as a very adequate platform permitting application-specific software and problem-targeted hardware to be coupled on a single configurable microchip. The tutorial is dedicated to multi-level software/hardware co-design techniques and system architectures that combine general-purpose computers, multi-core application-specific processing, and accelerators in reconfigurable hardware with emphasis on broad parallelism. Four projects from the scope of data processing, application informatics, parallel algorithms (mapped to hardware), and combinatorial search are briefly characterized and will be demonstrated in fully implemented and ready to test projects that include software and reconfigurable hardware linked with on-chip high-performance interfaces. Particular design examples, potential practical applications, experiments and comparisons will be demonstrated.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware/software co-design in extensible processing platforms for combinatorial search algorithms",
        "doc_scopus_id": "84904164541",
        "doc_doi": "10.1109/MELCON.2014.6820578",
        "doc_eid": "2-s2.0-84904164541",
        "doc_date": "2014-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Boolean satisfiability",
            "Design space exploration",
            "Hardware/software co-design",
            "High-performance processing",
            "Processing platform",
            "Sequential processing",
            "Software and hardwares",
            "Software/hardware partitioning"
        ],
        "doc_abstract": "The paper analyzes combinatorial search algorithms over discrete matrices for which deep parallelization is strongly required and argues that the best results can be achieved with rational distribution of algorithmic operations between software and hardware. Since extensible processing platforms combine a high-performance processing system and reconfigurable logic on the same microchip, they are chosen for design space exploration and evaluation of different types of software/hardware partitioning. It is shown that reconfigurable logic is more preferable for concurrent execution of lower level application-specific operations over vectors such as Hamming weight computation, test for orthogonality/intersection, and the majority of bitwise operations. Higher level procedures mainly involving sequential processing of matrices are more efficient for implementation in software running on embedded processor. Two problems from the scope of the Boolean satisfiability were taken as a case study. All the proposed solutions were modeled in software and then were implemented, tested, and evaluated in Zynq xc7z020 microchip. © 2014 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Application of extensible processing platforms for experiments with FPGA-based circuits",
        "doc_scopus_id": "84904162713",
        "doc_doi": "10.1109/MELCON.2014.6820579",
        "doc_eid": "2-s2.0-84904162713",
        "doc_date": "2014-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Host-PC",
            "Multi-core processor",
            "Parallel circuits",
            "Processing platform",
            "Processing systems",
            "Programmable logic",
            "Reconfigurable logic",
            "Shared memory"
        ],
        "doc_abstract": "Extensible processing platforms combine a high performance multi-core processor with a programmable logic on the same microchip. The paper describes how such platform has been used to provide support for experiments with competitive devices implemented in the programmable logic. The processor receives initial data from a host PC, copies the data to memory, which can also be accessed from the reconfigurable logic, activates the analyzed devices that execute operations over the data, and collects the results from the devices that finally are transmitted to the host PC. There are two main contributions in the paper that are 1) the developed technique of interaction of the processing system with the reconfigurable logic through a shared memory window; 2) a set of experiments illustrating the technique. © 2014 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Teaching FPGA-based systems",
        "doc_scopus_id": "84903436966",
        "doc_doi": "10.1109/EDUCON.2014.6826133",
        "doc_eid": "2-s2.0-84903436966",
        "doc_date": "2014-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            },
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            },
            {
                "area_name": "Education",
                "area_abbreviation": "SOCI",
                "area_code": "3304"
            }
        ],
        "doc_keywords": [
            "Communication modules",
            "Engineering course",
            "Industry requirements",
            "Laboratory equipments",
            "Portugal",
            "Software/hardware co designs",
            "Teaching materials",
            "Teaching methods"
        ],
        "doc_abstract": "In this paper we report on recent advances in teaching Field-Programmable Gate Array-based systems within engineering courses given in two Universities: University of Aveiro in Portugal and Tallinn University of Technology in Estonia. Although both institutions have a 6-year history of intensive and fruitful collaboration in this area there is a constant need to update both the teaching methods and the respective laboratory equipment and tools to keep in pace with the demanding industry requirements. This paper describes the most recent changes in the organization of the respective courses and the corresponding teaching materials. In particular, the developed communication modules required for software/hardware co-design are explained in detail. © 2014 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "High-performance implementation of regular and easily scalable sorting networks on an FPGA",
        "doc_scopus_id": "84903318125",
        "doc_doi": "10.1016/j.micpro.2014.03.003",
        "doc_eid": "2-s2.0-84903318125",
        "doc_date": "2014-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Artificial Intelligence",
                "area_abbreviation": "COMP",
                "area_code": "1702"
            }
        ],
        "doc_keywords": [
            "FPGA-based hardware accelerators",
            "Hardware implementations",
            "High performance implementations",
            "Parallel processing",
            "Pipelined implementation",
            "Processing technique",
            "Sequential operations",
            "Sorting network"
        ],
        "doc_abstract": "The paper is dedicated to fast FPGA-based hardware accelerators that implement sorting networks. The primary emphasis is on the uniformity of core components, feasible combinations of parallel, pipelined and sequential operations, and the regularity of the circuits and interconnections. The paper shows theoretically, and based on numerous experiments, that many existing solutions that are commonly considered to be very efficient have worthy competitors that are better for many practical problems. We compared the even-odd merge and bitonic merge sorting networks (which are among the fastest known) with the even-odd transition network, which is often characterized as significantly slower and more resource consuming. We found that the latter is the most regular network that can be implemented very efficiently in FPGA, so we are proposing new, easily scalable hardware solutions and processing techniques based on this. Finally, the paper provides four main contributions and suggests: (1) a regular hardware implementation of resource and time effective architectures based on the even-odd transition network; (2) a pipelined implementation of even-odd transition networks; (3) a pre-processing technique that enables sorting to be further accelerated; (4) combinations of this technique with a merge sort, an address-based sort, a quicksort, and a radix sort. © 2014 Elsevier B.V. All rights reserved.",
        "available": true,
        "clean_text": "serial JL 271554 291210 291716 291718 291791 291869 291883 31 Microprocessors and Microsystems MICROPROCESSORSMICROSYSTEMS 2014-03-14 2014-03-14 2014-06-23T09:20:13 S0141-9331(14)00030-1 S0141933114000301 10.1016/j.micpro.2014.03.003 S300 S300.1 FULL-TEXT 2015-05-14T04:11:00.055321-04:00 0 0 20140701 20140731 2014 2014-03-14T00:00:00Z articleinfo articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids contenttype copyright crossmark dateloaded dateloadedtxt datesearch datesort dateupdated dco docsubtype doctype doi eid ewtransactionid hubeid indexeddate issfirst issn issnnorm issuelist itemstage itemtransactionid itemweight openaccess openarchive pg pgfirst pglast pii piinorm pubdateend pubdatestart pubdatetxt pubyr sortorder srctitle srctitlenorm srctype subheadings tomb volfirst volissue volumelist yearnav figure table body mmlmath acknowledge affil articletitle auth authfirstini authfull authkeywords authlast orcid primabst ref vitae alllist content subj ssids 0141-9331 01419331 true 38 38 5 5 Volume 38, Issue 5 12 470 484 470 484 201407 July 2014 2014-07-01 2014-07-31 2014 article fla Copyright © 2014 Elsevier B.V. All rights reserved. HIGHPERFORMANCEIMPLEMENTATIONREGULAREASILYSCALABLESORTINGNETWORKSFPGA SKLYAROV V 1 Introduction 2 Related work 3 The proposed method and motivations 4 Theoretical comparisons of the proposed and the best known networks 5 Variations of the proposed network 6 Practical applications 7 Experiments and comparisons 7.1 Experimental setup 7.2 Experimental comparison of the proposed and the best known networks 8 Conclusion Acknowledgments References KNUTH 2011 D ARTCOMPUTERPROGRAMMINGSORTINGSEARCHING MUELLER 2012 1 23 R GAPANNINI 2012 903 917 G GROZEA 2010 105 117 C FACINGMULTICORECHALLENGE FPGAVSMULTICORECPUSVSGPUS LACEY 1991 315 316 S COPE 2010 433 448 B SKLIAROVA 2004 1449 1461 I ALIAS 2012 606 619 C PIESTRAK 2007 611 612 S SKLYAROV 2004 197 211 V SKLYAROVX2014X470 SKLYAROVX2014X470X484 SKLYAROVX2014X470XV SKLYAROVX2014X470X484XV item S0141-9331(14)00030-1 S0141933114000301 10.1016/j.micpro.2014.03.003 271554 2014-06-23T05:12:23.089259-04:00 2014-07-01 2014-07-31 true 4026889 MAIN 15 57736 849 656 IMAGE-WEB-PDF 1 si7 348 22 33 si6 425 17 48 si5 348 22 33 si4 232 18 13 si3 230 21 13 si2 230 21 13 si1 625 17 119 gr1 24856 330 314 fx2 11568 155 111 fx1 10010 155 111 gr9 25035 179 467 gr8 94579 433 600 gr7 37502 232 499 gr6 17264 222 224 gr5 78369 356 606 gr4 52246 414 336 gr3 59880 423 379 gr2 25739 167 378 gr17 49961 363 528 gr16 38441 351 461 gr15 40210 356 448 gr14 69801 309 601 gr13 45927 243 511 gr12 33781 282 499 gr11 73339 350 514 gr10 83900 314 542 gr1 4449 164 156 fx2 9964 164 117 fx1 9534 164 117 gr9 4057 84 219 gr8 10922 158 219 gr7 6704 102 219 gr6 6200 164 165 gr5 9734 129 219 gr4 7138 164 133 gr3 7349 164 147 gr2 7286 97 219 gr17 7025 151 219 gr16 6584 164 215 gr15 6872 164 206 gr14 8627 113 219 gr13 7685 104 219 gr12 5244 124 219 gr11 10866 149 219 gr10 10844 127 219 MICPRO 2119 S0141-9331(14)00030-1 10.1016/j.micpro.2014.03.003 Elsevier B.V. Fig. 1 Number of comparators for different values N of data items. Fig. 2 Basic concepts of the proposed method. Fig. 3 Even–odd merge network (a); bitonic merge network (b); a comparator/swapper (c). Fig. 4 The even–odd transition sorting network (a) and the network with reusable comparators (b). Fig. 5 Pipelined implementations: for even–odd merge sorter in Fig. 3a (a); for bitonic sorter in Fig. 3b (b), for the proposed circuit in Fig. 4b (c); the sequence of vectors recorded in the register R and in the PLR for the worst and for the best cases (d); a fragment of a state transition diagram to control the proposed circuit (e). Fig. 6 Variations of the proposed circuit which now has 4 reusable lines. Fig. 7 Pipeline for the circuit shown in Fig. 6a. Fig. 8 Pipelined implementation (a) and an example (b). Fig. 9 Merging of sorted sets in a host system. Fig. 10 The structure of the even–odd merge network (a) and the number of comparators for different values of N (b). Fig. 11 Using the proposed circuit for radix sort (a); comparison is done for segments composed of n <M bits but swapping has to be applied to whole words (b); an example of sorting (c). Fig. 12 Using the proposed circuits in address-based sorting: an example (a); processing of segments (b). Fig. 13 Experimental setup for the Atlys board (a) and ZedBoard (b). Fig. 14 A general structure of circuits implemented in FPGA and organization of experiments. Fig. 15 Resource (a) and throughput (b) evaluation for different non-pipelined circuits (i.e. combinational even–odd mergers and the proposed circuit in Fig. 4b) implemented and tested in the Atlys board. Fig. 16 Resource (a) and throughput (b) evaluation for different non-pipelined circuits (i.e. combinational even–odd mergers and the proposed circuit in Fig. 4b) implemented and tested in the ZedBoard. Fig. 17 Resource (a) and performance (b) evaluation for different pipelined circuits implemented and tested in the Atlys board. Table 1 Characteristics of different sorting networks. Ns F max (MHz) T min (ns) Throughput (the number of sorted items per second) Even–odd merge (Fig. 3a) 474 (6%) a 21.02 47.6 168160000 Bitonic merge (Fig. 3b) 584 (8%) a 20.42 49.0 163360000 The proposed circuit (Fig. 4b) 279 (4%) a 108.38 9.2 216760000 (the worst case) a Resources used also include circuits for interactions with the host computer that fill embedded FPGA memory with the initial data and transmit back the sorted sets. Table 2 Resource consumption of different circuits. N Ns (xc6slx45) Ns (xc7z020) Ns (xc6slx45) Ns (xc7z020) Ns (xc6slx45) Ns (xc7z020) Even–odd merge Bitonic merge Proposed 16 1323 (19%) 1071 (8%) 1680 (25%) 1360 (10%) 315 (5%) 255 (2%) 32 4011 (59%) 3247 (24%) 5040 (74%) 4080 (31%) 651 (10%) 527 (4%) 64 >100% 9231 (69%) >100% 11,424 (86%) 1321 (19%) 1071 (8%) 128 >100% >100% >100% >100% 2667 (39%) 2159 (20%) 256 >100% >100% >100% >100% 5355 (78%) 4335 (33%) 512 >100% >100% >100% >100% >100% 8687 (65%) Table 3 Throughput estimates for different circuits. N Even–odd merge/bitonic merge Proposed I s k / I s p 16 1600000000/D comp 1000000000/D comp 1.6 32 2133333333/D comp 1000000000/D comp 2.1 64 3047619048/D comp 1000000000/D comp 3.0 Table 4 Number of iterations in columns (1), (2) and steps in column (3) in different sorters. N (1) Circuit in Fig. 4b without pre-sort (and without enable signal) (2) Circuit in Fig. 4b with pre-sort (and with enable signal) (3) Even–odd/bitonic merge networks 32 16 [2× D comp] 8 [2× D comp] 15 [D comp] 64 32 [2× D comp] 15 [2× D comp] 21 [D comp] 128 64 [2× D comp] 31 [2× D comp] 28 [D comp] 256 128 [2× D comp] 60 [2× D comp] 36 [D comp] 512 256 [2× D comp] 120 [2× D comp] 45 [D comp] 1024 512 [2× D comp] 251 [2× D comp] 55 [D comp] High-performance implementation of regular and easily scalable sorting networks on an FPGA Valery Sklyarov ⁎ Iouliia Skliarova Department of Electronics, Telecommunications and Informatics, IEETA, University of Aveiro, 3810-193 Aveiro, Portugal Department of Electronics Telecommunications and Informatics IEETA, University of Aveiro 3810-193 Aveiro Portugal ⁎ Corresponding author. The paper is dedicated to fast FPGA-based hardware accelerators that implement sorting networks. The primary emphasis is on the uniformity of core components, feasible combinations of parallel, pipelined and sequential operations, and the regularity of the circuits and interconnections. The paper shows theoretically, and based on numerous experiments, that many existing solutions that are commonly considered to be very efficient have worthy competitors that are better for many practical problems. We compared the even–odd merge and bitonic merge sorting networks (which are among the fastest known) with the even–odd transition network, which is often characterized as significantly slower and more resource consuming. We found that the latter is the most regular network that can be implemented very efficiently in FPGA, so we are proposing new, easily scalable hardware solutions and processing techniques based on this. Finally, the paper provides four main contributions and suggests: (1) a regular hardware implementation of resource and time effective architectures based on the even–odd transition network; (2) a pipelined implementation of even–odd transition networks; (3) a pre-processing technique that enables sorting to be further accelerated; (4) combinations of this technique with a merge sort, an address-based sort, a quicksort, and a radix sort. Keywords FPGA Parallel processing Sorting networks Pipeline 1 Introduction Sorting is a procedure that is needed in numerous computing systems [1]. For many practical applications, sorting throughput is very important. To better satisfy performance requirements, fast accelerators based on FPGAs (e.g. [2–10]), GPUs (e.g. [6,11–15]) and multi-core CPUs (e.g. [16,17]), have been investigated in depth with increased intensity during the last few years. The latter can be explained by the recent significant advances in high-density and high performance microelectronic devices that have resulted in serious competitors to general-purpose and application-specific processing systems for solving computationally intensive problems. The results are especially promising if multiple operations can execute simultaneously. Two of the most frequently investigated parallel sorters are based on sorting [2] and linear [3] networks. A sorting network is a set of vertical lines composed of comparators that can swap data to change their positions in the input multi-item vector. The data propagate through the lines from left to right to produce the sorted multi-item vector on the outputs of the rightmost vertical line. Three types of such networks have been studied: pure combinational (e.g. [2,8]), pipelined (e.g. [2,8]), and combined (partially combinational and partially sequential) [e.g. 4]. The linear networks, which are often referred to as linear sorters [3], take a sorted list and insert new incoming items in the proper positions. The method is the same as the insertion sort [1] that compares a new item with all items in parallel, then inserts the new item at the appropriate position and shifts the existing elements in the entire multi-item vector. Additional capabilities of parallelization are demonstrated in the interleaved linear sorter system proposed in [3]. The main problem with this is that it is applicable only for small data sets (see, for example, the designs discussed in [3], which accommodate only tens of items). The majority of sorting networks implemented in hardware use Batcher even–odd and bitonic mergers [18]. Such networks are described in [2,4,8,11,12]. Other types are rarer (see for example the comb sort [19] in [7], the bubble and insertion sort in [2,8] and the even–odd transition sort in [11]). Research efforts are concentrated mainly on networks with a minimal depth or number of comparators (e.g. [2,12]) and on co-design, rationally splitting the problem between software and hardware (e.g. [2,8]). To our knowledge, the regularity of the circuits and interconnections is almost never taken into account. The only instance appeared recently in [4], where a generator for networks with reusable components was proposed. The results in [4] were discussed just in terms of circuit sizes, and performance was not analyzed (an estimation of throughput for the method [4] is in Section 2 of this paper). Further, no particular circuit was demonstrated. We target our results towards FPGAs because they are regarded more and more as a universal platform incorporating many complex components that were used autonomously not so long ago. For example, the All Programmable System-on-Chip (APSoC) Xilinx Zynq includes a dual ARM® Cortex™-A9 MPCore™ and an Artix/Kintex FPGA on the same microchip. The first prototyping systems (e.g. ZedBoard [20,21], ZyBo [21]) with this microchip are already available for a very reasonable price. The majority of modern FPGAs contain embedded DSP slices (e.g. the DSP48E1 slice for Xilinx FPGAs [22]) and embedded dual-port memories, which are very appropriate for sorting. We believe that in future, GPU cores might also be placed inside an FPGA, but even without such cores, streaming SIMD (single instruction multiple data) applications can be created with existing programmable logic. Comparisons of FPGA-based implementations with alternative systems [16,23,24] clearly demonstrate the potential of reconfigurable hardware, which encourages further research in this area. FPGAs still operate on a lower clock frequency than non-configurable ASICs and ASSPs and broad parallelism is evidently required to compete with potential alternatives. Thus, sorting and linear networks can be seen as very adequate models. Unfortunately, they have many limitations. Suppose N data items, each of size M bits need to be sorted. The results of [2,8] show that sorting networks cannot be built for N >64 (M =32), even in the relatively advanced FPGA FX130T from the Xilinx Virtex-5 family, because the hardware resources are insufficient. When N is increased, the complexity of the networks (the number of comparators C(N)) grows rapidly [1,2,8,18] (see Fig. 1 ). Also, to our knowledge, propagation delays through long combinational paths in FPGA networks have not been analyzed in depth and were not taken into account at all in many publications. Such delays are caused, not only by comparators, but also by multiplexers that have to be inserted even in partially regular circuits [4], and by interconnections. Components that execute comparisons with extended functionality are more flexible, but they cause new problems. For example, comparators for bitonic networks frequently perform reverse operations because the comparisons may be required for opposite orderings (first maximum, second minimum or vice versa). This requires either blocks that are driven by a special signal, or slightly different interconnections. Although at a first glance the problem looks trivial, it can be serious for networks with thousands of comparators. Let us look at Fig. 1. If a comparator requires one extra FPGA slice, it can lead to a huge number of additional slices in the resulting circuits. It is important to note that although sorting networks enhance the results, such improvements are not very practical for processing large data sets. This is because the increase in performance requires huge additional hardware resources that are often not realizable in practice. For this reason such networks are frequently combined with other methods, such as merging sorted subsets [7,9]. This paper provides four main contributions and suggests: (1) Regular and easily scalable hardware implementation of resource and time effective architectures based on even–odd transition networks. With these, the number of comparators can be reduced dramatically, offering sufficient throughput. (2) A pipelined implementation of even–odd transition networks with a reduced number of stages (sequentially executed steps). This requires fewer resources than existing alternative data sorters, while providing high throughput. The performance is sufficient, considering that the maximum attainable overall performance is constrained by surrounding circuits that use the results of sorting. (3) A pre-processing technique that enables sorting to be further accelerated. The main idea is to apply the concepts of methods such as quicksort in particular to achieve simple pre-positioning of the input data items. (4) Combining this technique with merge sort, address-based sort, quicksort, and radix sort. This allows hardware/software co-design that couples processing systems (PS) and programmable logic (PL) to be done more easily and effectively. Special attention has been paid to experiments and comparisons, the majority of which were done for relatively low cost FPGAs, with the main objective being to demonstrate wide applicability. Points (1 and 2) above have been evaluated and compared theoretically and experimentally with the best known alternatives. Points (3 and 4) above have not been fully tested in hardware, but the proposals have been verified in software. The transfer of data sets between PL (hardware that implements sorters) and PS (software that does pre- and post-processing) is also discussed. The remainder of the paper is organized in 7 sections. Section 2 presents an analysis of related work. Section 3 summarizes the main ideas of the paper and shows that they are practical. Section 4 compares the proposed networks with the best known alternatives theoretically. Section 5 discusses variations of the proposed circuits. Section 6 is dedicated to potential practical applications. Section 7 reports the results of experiments in FPGAs with comparison charts and simulation in software. The conclusion is in Section 8. 2 Related work Performance is critical for the majority of computational systems in which sorting plays an important role. One of the fastest known parallel sorting methods is based on the even–odd merge and bitonic merge networks [1,2,4,8,11,12,18]. The depth D(N) of a network that sorts N data items is the minimal number of data dependent steps S 0,…, Sk ,…, SD ( N )−1 that have to be executed sequentially. This characteristic is important for both pure combinational and sequential implementations. In the first case, circuits operated at any step k use the results of circuits from the previous step k −1; i.e. there exists a data dependency between step k and step k −1. If we assume that propagation delays of all steps are equal, then the total delay is proportional to D(N). For sequential implementations, D(N) determines the number of sequentially executed steps (clock cycles). In both cases, D(N) together with clock frequency for sequential implementations determines the latency of the network, which influences the throughput (i.e. the number of sorted data items per time unit). If N is a power p of 2 (i.e. N =2 p ), then D(N =2 p )= p ×(p +1)/2 [1,2] for both networks indicated above. Thus, these networks are very fast. Indeed, sorting 33million items (N =225) can be done with just 325 steps (D(N =225)=325). However, there is another problem. The hardware resources needed are enormous. Let us analyze the even–odd merge network (that is less resource consuming than the bitonic merge network). The number of comparators for this network is C(N =2 p )=(p 2 − p +4)×2 p −2 −1 [1,2]. Thus, sorting 33million items requires 5066719231 comparators. We found experimentally that one comparator/swapper for 32-bit data items (M =32) consumes at least 17 slices for Xilinx FPGAs. To our knowledge the largest existing FPGA XC7V2000T contains 305400 slices. Hence, to implement a network-based sorter for 33million items combinationally we would need more than a quarter of million of the most advanced FPGAs, and this is without taking into account routing overhead. Sequential implementations permit hardware resources to be reduced but cause a new problem: the number of memory transactions becomes very large [12]. So, the 325 steps indicated above are either not realizable in practice, or each step becomes very time consuming. The main idea of this paper is to find a good compromise between pure combinational parallel operations and sequential stages that execute the parallel operations. The emphasis is on circuits that are as regular as possible and thus easily scalable, avoiding redirecting data streams through multiplexing operations. This is because any multiplexer involves additional propagation delays and complicates interconnections. Of course the latter can cause further propagation delays. The results of [4] show the implementation of a sorting network for N =2048 on 3000 FPGA slices (Virtex-6 XC6VLX760). However, according to known theoretical results (e.g. [1,2,18]) this can be done if there are many sequentially executed steps, which are not explicitly shown in [4]. Indeed, 58,367 comparators are required for an even–odd merge sort and 67,584 comparators for a bitonic merge sort [1,2,18]. Any comparator/swapper occupies 21 slices for the FPGA in [4]. Thus, 3000 slices can be employed just for 142 comparators. Any vertical line of comparators for the bitonic merge considered in [4] contains 1024 comparators and there are 66 vertical lines [1,2,18]. So, we need at least: ⌈ 1024 / 142 ⌉ = 8 sequential steps to multiplex any vertical line; 66 steps to multiplex lines; and in total 66×8=528 steps. Our experience with circuits implemented in FPGA shows that multiplexing involves excessive propagation delay. Pipelining permits the clock frequency for circuits to be increased because delays between registers in a pipeline are reduced. A number of such solutions are described in [2,8]. However, once again, the complexity of the circuits becomes the main limitation. We have already mentioned in the introduction that for N >64 (M =32), sorting networks [2,8] cannot be built even in the relatively advanced FPGA FX130T from the Xilinx Virtex-5 family because of the lack of hardware resources. Thus, FPGAs can only be used for sorting very small sets of data. Large data sets are ultimately sorted in [2,8] in software in host computers/processors and the FPGA just provides assistance by sorting small subsets. Clearly the smaller the number of items in the subsets, the greater is the communications overhead. Communication (preferably in burst mode) is involved between the host system/processor and the sorters in reconfigurable logic. The analysis presented above enables us to conclude the following: (1) The known even–odd merge and bitonic merge circuits are the fastest and they enable the best throughput to be achieved. However, they are very resource consuming and can only be used effectively in existing FPGAs for sorting very small data sets. (2) Pipelined solutions permit faster circuits than in point 1 to be designed. However, assuming that pipelining can be based on flip-flops in the slices used so additional slices are not required, resource consumption is at least the same as in point 1. So, in practice, only very small data sets can be sorted. (3) To use even–odd merge and bitonic merge circuits for large data sets, the following two methods are the most commonly applied: (a) large data sets are sorted in host computers/processors based on sorted subsets of large sets produced by an FPGA (see, for example, [2,8]); (b) the sorting networks for large sets are segmented in such a way that any segment can be processed easily and the results from the processing are handled sequentially to form the sorted set (see, for example, [4,12]). Both methods involve intensive communications, either between an FPGA and a host computing system/external memory (the size of memory embedded in FPGA is limited), or between a processing system (such as [12]) and memory. (4) The existing even–odd merge and bitonic merge circuits are not very regular (compared to the even–odd transition network for example) and, thus the routing overhead may be significant in FPGAs. 3 The proposed method and motivations The basic ideas of the method discussed in this paper are illustrated in Fig. 2 . The key points are numbered by the digits 1, 2, 3 and 4 enclosed in circles. They are: (1) Sequential reuse of the same sub-sorter (Fig. 2 shows a sub-sorter for N =6) instead of a sorter composed of connected sub-sorters (such as that in the even–odd transition network in [11]). This permits the number of comparators/swappers to be reduced. (2) Connection of K sub-sorters in a pipeline. (3) Use of an optional pre-sorter, which enables the number of iterations in the sorter to be reduced. We will show later that using just the first stage of a method such as quicksort in [15] enables the number of iterations to be halved. (4) Using optional merging of sorted subsets for larger data sets. Note that the paper mainly focuses on points (1 and 2) above and is primarily dedicated to the sorter underlined in Fig. 2. Points (3 and 4) above are optional. They are discussed, but in less detail. To show the importance of these ideas we provide an initial comparison of the circuit indicated in point (1) that makes use of reusable sub-sorters with the two most frequently discussed and popular sorting networks (even–odd merge and bitonic merge) shown in Fig. 3 for N =8 (the network is scalable for any N) and M =32. The functionality of the comparator/swapper can be described by the following simple VHDL code: MaxValue<=A when A>=B else B; MinValue<=B when A>=B else A; Both circuits in Fig. 3 were synthesized in Xilinx ISE 14.6 and implemented and tested in the Atlys prototyping board of Digilent [21] containing the xc6slx45 FPGA from the Xilinx Spartan-6 family. Source data were taken from a host PC through USB and sorted data were sent back to the PC. Table 1 presents the results (Ns is the number of FPGA slices, F max is the maximum attainable clock frequency, T min is the minimum clock period). F max and T min determine how fast sorted items can be read after any change in input data. We compared the results with the proposed alternative circuit that reuses the same comparators/swappers iteratively through a feedback register R (details are in Fig. 4 ). The circuit is very regular, easily scalable, and does not require any additional components when input data are written to and sorted output data are read from the register R sequentially, applying a shift operation. To transfer data to register R in parallel would require N multiplexers at the register inputs to receive data from outside before processing and from the comparators during processing. In all the experiments, parallel recording of data to register R was applied. The role of the additional comparator in Fig. 4b will be explained later. The maximum number of clock cycles τ max in the even–odd transition network (see Fig. 4b) for sorting N =8 data items is equal to τ max = N/2=4 [11]. However this can be less than N/2 and thus less than 4 in Fig. 4b. For example, data in Fig. 3a are sorted at step 3, but because the network is hardwired, the results are transmitted through all the lines of comparators, which causes an unnecessary propagation delay. The same problem occurs in Fig. 4a. Let us introduce an enable signal which is zero at any second vertical line of the circuit in Fig. 4b when there is no exchange of data. As soon as enable=0, all data have been sorted. Suppose we need to sort data that are occasionally received in the sorted order, let us say: 8, 7, 6, 5, 4, 3, 2, 1. The sequential circuit (Fig. 4b) concludes that data have already been sorted in time 2× t, where t is the delay of any vertical line in Fig. 4b. The combinational circuits in Figs. 3 and 4a still need time D(N)× t. So, the simple iterative circuit in Fig. 4b permits the number of steps to be reduced, which cannot be done for the circuits in Figs. 3 and 4a. Moreover, the networks in Fig. 3 cannot be implemented with an enable signal similar to Fig. 4b. Indeed, since a set of merges of previously sorted subsets has to be executed, sorting is not guaranteed until the last merge phase, i.e. until the last stage that is composed of the remaining steps (e.g. after step 3 in Fig. 3a). In case of pipelining [25], the resources required are almost the same because FPGA slice flip-flops can be used without the need for additional components. The positions of pipeline registers (PLR) are shown in Fig. 5 a–c for the even–odd merge sorter (Fig. 5a), the bitonic merge sorter (Fig. 5b), and the proposed circuit (Fig. 5c). Fig. 5d depicts the sequence of vectors recorded in the register R and in the PLR for the worst and best cases (for the given example). The latter involves the enable signal (see Fig. 4b) that is tested in the simple fragment of a finite state machine (FSM) shown in Fig. 5e where the following steps are executed: (1) data from the first set are copied to the register R (state a 1); (2) data from the first set are transferred to the PLR through the first line of comparators/swappers and data from the second set are copied to the R (state a 2); (3) subsequent steps in the state a 3 depend on the enable signal. If there is a swap of inputs in the second line of comparators/swappers (i.e. the enable is equal to 1) then data are rotated (from R to PLR through the first line and from PLR to R through the second line). If there is no swap of signals in the second line of comparators/swappers (i.e. the enable is equal to 0) then sorted data are read from the outputs shown in Fig. 5c and data from a new set are copied to the register R. Note that interface signals (such as verifying availability of input data) are not shown in Fig. 5. Clock frequency for the even–odd merge and the bitonic merge sorters can be increased in pipelined versions by a factor of about 6 (see Fig. 5a and b) and for the proposed circuit by about 2 (see Fig. 5c). Once again, the proposed circuit is the least resource consuming. The throughputs of the pipelined circuits will be evaluated and compared in Section 7.2. From the experiments we found that the maximum attainable clock frequency for the circuit in Fig. 5c is higher than for the circuits in Fig. 5a and b because of the difference in routing overheads. The circuit in Fig. 5c is more regular and the routing overhead for this circuit is smaller than for the circuits in Fig. 5a and b. Additional details and comments are in Section 7.2. The results of a preliminary comparison of the circuits in Figs. 3 and 4b (N =8) permit the following conclusions to be drawn: • For pure combinational implementations, the circuit in Fig. 4b is the fastest, even without the enable signal (i.e. in the worst case). • For pipelined implementations, the circuits need to be evaluated further, and compared taking account of the difference in routing overheads. This is done in Section 7.2. • If the enable signal is used, then sorting in Figs. 4b and 5c can be further accelerated. • The resources required for the proposed circuits are the smallest (see Table 1). Note that a visual comparison of the circuits in Figs. 3 and 4b shows that the propagation delays should differ by a factor of about 3 because the depth of the circuits in Fig. 3 is 6 and the depth of the circuit in Fig. 4b is 2. However, the actual difference is more than 5 times (see Table 1). This is because the interconnections in Fig. 3 are more complicated than those in Fig. 4b therefore the routing overhead is different. So, regularity and simplicity of interconnections are important. 4 Theoretical comparisons of the proposed and the best known networks The simple experimental comparison given in Table 1 shows that for N =8 and M =32 the proposed solutions are faster and less resource consuming. Let us now evaluate theoretically the two basic characteristics for the circuits for N >8: throughput (i.e. the number of sorted data items per second) and complexity (i.e. the number of FPGA slices required). Table 2 shows the number of slices Ns for two microchips, the APSoC Zynq xc7z020 [26] (FPGA section) and the Xilinx Spartan-6 xc6slx45 FPGA [27]. These are required for the comparators/swappers of the networks without taking account of the additional resources needed for interaction with the circuits, or the routing overheads. The values of Ns are calculated as Ns (comp)× C(N), where Ns (comp) is the number of slices needed for one comparator/swapper with M =32 (i.e. for 32-bit data items), and C(N) is the number of comparators/swappers for the network. The values Ns (comp) have been found experimentally (for the xc6slx45 FPGA Ns (comp)=21 and for the APSoC Zynq xc7z020 Ns (comp)=17). The number of comparators/swappers for the proposed network in Fig. 4b is N −1. The number of comparators/swappers C(N =2 p ) for even–odd merge networks is C(N =2 p )=(p 2 − p +4)×2 p −2 −1 and for bitonic merge networks is C(N =2 p )=(p 2 + p)×2 p −2 [1,2]. The percentage of FPGA slices used is also shown in Table 2 alongside the Ns values. For example, the even–odd merge network for N =16 occupies 1323 slices, or 19% of the 6822 slices available in the xc6slx45 FPGA [27]. Table 2 shows clearly that the proposed technique permits larger data sets to be sorted in a given FPGA microchip. The resource estimation in Table 2 is not exact because the many supplementary circuits that are normally needed and the routing overheads have not been taken into account. The exact comparison will be done experimentally in Section 7.2. Much like [8], we only analyzed the isolated performance that can be achieved for sorting networks with small numbers of items. Table 3 indicates throughputs I s k (items per second) for different circuits. The values of I s k for the known even–odd merge and bitonic merge networks are calculated as (the formulae below are given for non-pipelined circuits): [(1s=109 ns)/(D comp × D(N))]× N, where D comp is the delay of a comparator/swapper in nanoseconds and D(N =2 p )= p ×(p +1)/2 [1,2]. For example, the even–odd merge network sorts N =16 data items in D comp ×10ns (because D(N =2 p )= p×(p +1)/2=10). Thus, 108/D comp sets (each set contains 16 items) can be sorted per second and throughput is 16×108/D comp 32-bit items per second. The values of I s p for the proposed circuit (see Fig. 4b) in the worst case (i.e. the enable signal is not used) are calculated as: [(1s=109 ns)/(2× D comp × N/2)]× N =109 ns/D comp. Indeed, there are two data independent vertical lines in Fig. 4b and a factor 2 is taken; in the worst case N/2 sequentially executed steps need to be done [11] and a factor N/2 is also used. We found that it is difficult to measure D comp values for individual comparators experimentally. If we analyze the ISE timing reports for an individual comparator and a set of sequentially connected comparators, the delays are not strictly proportional to the number of comparators in the chain. Also, the throughput estimates in Table 3 are not exact because the routing overhead has not been taken into account (and cannot be taken into account in our evaluation because it depends on particular synthesis tools). Thus, we will postpone the exact comparison until Section 7.2, where it will be done experimentally. Table 3 provides estimates of throughputs up to N =64 because for the microchips considered (xc7z020 and xc6slx45), the larger even–odd merge and bitonic merge networks cannot be implemented (see Table 2). At first glance the existing solutions seem to be faster than the proposed circuits. Indeed, the values of I s k / I s p range from 1.6 to 3.0 and if N is increased, these values are also increased. Additionally, pipelining permits even better results to be obtained for these networks. However, in practice, even if the existing solutions are faster, we cannot take advantage of such high speeds and circuits implemented in FPGAs are never as fast as we expect. The reasons for this conclusion are: (1) Even trivial experimental comparisons (see Table 1) show that the routing overhead is higher for the known networks than for the proposed solution. (2) The throughputs in Table 3 cannot be achieved in practical circuits because of communication overheads. Indeed, initial data need to be supplied to the sorter, the results have to be taken from the sorter, and the speed of communications is a bottleneck. The latter is more critical for existing networks because they can only be used for data sets with a very small number of items and thus more frequent data exchange is involved (since the number of transmitted data is actually very small it is difficult to apply full burst mode capabilities). Let us look once again at Table 2. Even for the modern, relatively advanced microchip xc7z020, the available resources allow only up to 64 items (M =32) to be sorted by the known networks in programmable logic. Thus, real-world sorting problems require a higher level processing system such as the ARM Cortex-A9 in the APSoC xc7z020 in order to sort larger data sets using pre-sorted subsets. Communication between the processing system and the programmable logic in the APSoC is done inside the microchip but the speed is limited so no advantage can be gained from the potential higher throughput values shown in Table 3. (3) Extensive communications between the processing system and the programmable logic in hybrid sorters that are implemented partially in software and partially in hardware do not allow the desired performance to be achieved because the processing system is frequently interrupted for necessary data exchange. Clearly, existing networks require more intensive communication than the proposed circuits because the latter allow data sets with a larger number of items to be sorted in the same FPGA (see Table 2). (4) Using the enable signal permits the performance of the proposed circuits to be increased (see Fig. 4b) although hardware resources will also be increased slightly. 5 Variations of the proposed network Let us analyze the network depicted in Fig. 4b assuming that there is one additional comparator which handles items with indices 0 and N −1 when they are written to the register R before sorting starts. This costs nothing but may reduce the number of steps. We will assume that items are sorted in descending order in such a way that after processing, the upper item is the largest and the bottom item is the smallest. We also assume that the comparators are built as shown in Fig. 3c. Since large values (keys) will move one or two positions upwards in every clock cycle while small values move downwards, we need N/2 iterations (clock cycles) in the worst case [11]. The additional comparator (see Fig. 4b) guarantees that the top value is not the smallest and the bottom value is not the largest. Hence, we can reduce processing by one or more iterations. Any iteration has the delay 2× D comp and signals from the register pass through two vertical lines in Fig. 4b. From the previous section we can see that the proposed circuit requires significantly smaller resources than the best known sorting networks and we will show later that it also provides sufficient throughput for practical applications. Variations of the proposed even–odd transition network with sequentially reusable segments permit a better compromise to be found between the resources required and performance. In Fig. 6 the reusable segments are composed of a larger number of vertical lines than in Fig. 4b. When the number of vertical lines is increased, the resources required also increase but a pipeline similar to Fig. 5c can be created enabling performance to be improved. There are two major reasons for increasing the number of vertical lines: (1) to sort several data subsets for subsequent merging; (2) to achieve a higher overall throughput if this is required. Fig. 7 depicts a pipelined implementation of the circuit in Fig. 6. There are four pipeline registers PLR1,…, PLR4 that are controlled by an FSM. It is assumed that the initial data are read from input memory and the sorted data are saved in the output memory, which is also controlled by the FSM. Thus, the output memory accumulates several sorted subsets which will be further merged. Fig. 8 demonstrates an example of the functionality of the circuit in Fig. 7 with more details. Input vectors composed of N items of size M are read from the input memory and saved in the register PLR1 of size N × M. Several vectors are received sequentially and shifted through vertical lines of comparators (see Fig. 8a). Shifts are controlled by the FSM which indicates when the results can be read from the rightmost PLR (PLR4) through the last vertical line of comparators. Thus, depending on signals from the FSM, outputs of the block composed of PLR4 and the odd line 3 are copied, either to the output data memory, or to PLR1. Now N + L −1 steps are needed to sort L N-item sets, where L is the number of vertical lines/registers in Fig. 8a. Fig. 8b demonstrates an example where 4 (L =4) subsets with 8-items each (N =8) are sorted in 11 clock cycles. So, throughput is 2.75 clock cycles per subset. The signal “subset is sorted”, similar to the enable signal considered above, can be taken from the rightmost odd line (odd line 3 in Fig. 8a). As soon as there is no swap in the line, the signal “subset is sorted” indicates that the sorted data items can be read from the rightmost block (composed of the register PLR4 and the odd line 3 in Fig. 8a). Hence, less than N + L −1 steps might be required to sort all the subsets. As soon as a subset is sorted and read, the next (new) subset can be loaded into the register PLR1. Thus, and this is very important, sorting can be executed continuously with new subsets added periodically. Such processing is controlled by the same FSM. Let us look at the example in Fig. 8b. One subset (150, 144, 119, 96, 55, 39, 21, 17) is sorted at step 3 (the step numbers are enclosed in circles in Fig. 8b). The sorted subset can be read from the register PLR4 through the odd line 3 at step 4 and a new subset can be loaded to the register PLR1 (see step 5 in Fig. 8b). Another subset is sorted at step 5 and can be read at step 6. 6 Practical applications The following practical applications can benefit from the proposed solutions: • FPGA-based autonomous circuits for sorting small data sets which consume significantly fewer resources than the best known sorting networks (e.g. even–odd merge and bitonic merge). • FPGA-based accelerators that sort subsets of data items received from host (higher-level) processors/computers while the remaining task is solved by software in the host system. Although data sorters implemented in general-purpose software exhibit high performance, they are slower than highly parallel hardware circuits. For example, programs written in the C/C++ language [28] sort large sets (100–200million data items) on a PC in about 10s, which is about 50–100ns per item. Sorting in embedded processors is usually slower than in PCs. From Sections 3 and 4 we can see that data processing in FPGAs might be significantly faster. Thus, the problem can be split into two parts, one executed in FPGA and the other in general-purpose/application-specific software. This is reasonable because FPGAs can sort small subsets of data considerably faster, but for large sets of data the same throughput either cannot be achieved, or requires substantial resources and is thus very expensive. • Applications that use the proposed circuits as components of sorting systems such as [7,9,10,29]. Let us discuss points (3 and 4) from Section 3, which suggest an optional pre-sorter that enables the number of iterations in an FPGA-based sorter to be reduced, and a merger that permits larger sorted sets to be built from subsets sorted in an FPGA. We found that pre-sorting and merging can be implemented easily in software on a host system that uses an FPGA as an accelerator. This is because the indicated operations are not very well parallelized in hardware and require additional resources that are typically very limited. Let us discuss these operations in more detail. In Fig. 4b the register contains N M-bit data items. Clearly, if the enable signal is used and the lower part contains larger values while the upper part holds smaller values, then sorting in descending sequence takes longer. The quicksort algorithm divides large sets of data items into two subsets containing smaller and larger elements. A similar separation can then be applied to the subsets recursively. We found that this technique can be helpful for the proposed sorter. Data with larger values are dispatched to the upper part of register R and items with smaller values to the lower part of register R. Let us call such processing pre-sorting (see Fig. 2). We carried out several experiments with C/C++ programs that implement this technique as simply as possible: the range of possible input values is divided into two halves and the middle value is considered to be a pivot. All data larger than the pivot are copied to the upper part of register R and all data smaller than the pivot are copied to the lower part. If either part is full, then all subsequent data are recorded in the other part. Input data were generated randomly by the C function, rand. Table 4 indicates the average number (from 100 runs) of sequential iterations needed for the circuits (1), (2) and steps for the circuit (3), where: (1) is the circuit in Fig. 4b without pre-sort; (2) is the circuit in Fig. 4b with pre-sort; (3) is the even–odd merge and bitonic merge networks. Note that the combinational delay within an iteration in the proposed circuit is twice as long as in a step in the known networks. This is because signals pass through two vertical lines of comparators/swappers in the proposed network (see Fig. 4b) whereas in the known network they pass through just one line (see Fig. 3a and b). This is explicitly indicated in Table 4 by the values 2× D comp and D comp in square brackets. We can see that although the distribution of input data between the upper and lower parts of register R is indeed trivial, the number of subsequent iterations is reduced by a factor of approximately 2 (compare columns (1 and 2) in Table 4). A more efficient pre-sort can be done similarly to the first few steps of the quicksort algorithm. This operation is not time consuming and it can be done in parallel for new subsets of data in a host system with sorting in FPGA. To get the final sorted sequence that is built from subsets of sorted sequences such as those shown in Fig. 8b, we need to merge the subsets. Note that merging is not the main target of the paper and the technique similar to [2,8] (see Fig. 9 ) is applied. The initial set of data that is to be sorted is divided into Z subsets of N items. Each subset is sorted in an FPGA using the proposed circuits. Merging is executed as shown in Fig. 9, in a host system that interacts with the FPGA. Two types of host systems were considered: (1) a desktop PC interacting with the board through a USB port (experiments were done with the Atlys prototyping board and Digilent software [21]), and (2) the processing system (PS) in the APSoC Zynq [26] interacting with the programmable logic (PL). In both cases, merging is done by software written in C. From column (3) of Table 4 we can see that the larger the value N, the fewer the steps that are required for the even–odd merge and bitonic merge sorting networks compared to the even–odd transition network shown in Fig. 4a. Merging is executed incrementally in the networks, as shown in Fig. 10 a for the even–odd merge. Initially, each 2-item subset is sorted. Then pairs of the resulting 2-item sorted subsets are merged to compose 4-item sorted subsets. Pairs of the 4-item sorted subsets are merged again and so on, until the complete sorted set of data is produced. The number of comparators/swappers required in any block is shown in the rectangles. The table in Fig. 10b gives the number of comparators/swappers at each last stage where sorted subsets are merged, and the number of comparators at all stages for N varying from 8 to 2048. From the previous discussion we can see that the proposed circuits are significantly less resource consuming than even–odd merge and bitonic merge networks when implemented in FPGA, but their complexity is still limited by the available FPGA resources. However, we can use the proposed circuits for sorting small subsets (let us say N ⩽512) and then apply even–odd and bitonic mergers implemented in other microchips (such as a GPU). This approach might be constructive for multi-stage (sequential) merging that is used in GPU-based sorters [12]. This technique reduces the number of memory transactions and comparison operations significantly. For instance, if subsets of N =256 items are pre-sorted, the number of comparators/swappers is decreased (see the numbers in bold font in Fig. 10b) by a factor of 15 (3839 are needed for even–odd merge vs. 255 needed for the circuit in Fig. 4b). The following advantages of such reduction can be pointed out: (1) Larger pre-sorted subsets (see Fig. 9) may be built in the same hardware (see the PL section in Fig. 9) while the remaining mergers are implemented in software (see the PS section in Fig. 9). This way permits the number of data transitions between software and memory in the PS section (see mergers in Fig. 9) to be reduced. Besides, burst mode may easier be applied to data exchange between the PS/memory and the PL. (2) The depth of the tree from mergers shown in Fig. 9 is reduced and, thus, the most time-consuming part of the sorter (implemented in the PS) becomes faster. (3) Fig. 10 permits the reduction of the depth of the tree of mergers to be evaluated. For example, if we compare the use of pre-sorters with N =16 and N =256 then the number of the tree horizontal levels is decreased by a factor of 4. The proposed technique can also be applied to non-comparison based methods that proved to be very efficient. Let us discuss two of them, the radix sort and the address-based sort. The radix sort implementation that relies on segmented scan primitives demonstrates very good results [29]. The address-based sort [10] is very fast, especially when N is close to 2 M , although the value of M is limited (to 32 or so). The main idea of the radix sort is to process individual digits, normally beginning from the least significant digit. Let us consider the example shown in Fig. 3: 144, 119, 150, 96, 39, 55, 17, 21, and apply a descending sort to the least significant digit. The result is: 119, 39, 17, 96, 55, 144, 21, 150. Now execute the same procedure for the second digit: 96, 55, 150, 144, 39, 21, 119, 17. Lastly the most significant digit is sorted, giving the final result: 150, 144, 119, 96, 55, 39, 21, 17. The original values in binary representation are: 10010000, 1110111, 10010110, 1100000, 100111, 110111, 10001, 10101. We can execute analogous steps for all 8 bits (the sorted bits at each iteration are shown in bold font): (1) 01110111, 00100111, 00110111, 00010001, 00010101, 10010000, 10010110, 01100000; (2) 01110111, 00100111, 00110111, 10010110, 00010001, 00010101, 10010000, 01100000; (3) 01110111, 00100111, 00110111, 10010110, 00010101, 00010001, 10010000, 01100000; (4) there is no change; (5) 01110111, 00110111, 10010110, 00010101, 00010001, 10010000, 00100111, 01100000; (6) 01110111, 00110111, 00100111, 01100000, 10010110, 00010101, 00010001, 10010000; (7) 01110111, 01100000, 00110111, 00100111, 10010110, 00010101, 00010001, 10010000; (8) 10010110, 10010000, 01110111, 01100000, 00110111, 00100111, 00010101, 00010001. The results at iteration 8 in decimal are: 150, 144, 119, 96, 55, 39, 21, 17. A similar technique can be applied to groups of bits. For example, the same result can be obtained if we apply 4 steps to groups of 2bits. Thus, the sorter proposed in this paper can be used as shown in Fig. 11 . It sorts items in each group G 0,…, GQ −1 iteratively. Note that each group is an n-bit slice within M-bit items (n < M), so fewer bits have to be compared. However, swapping (if needed) still has to be applied to the whole M-bit words (see Fig. 11b). Fig. 11c demonstrates an example. Experiments that we conducted showed that the results depend on the number of bits in the sub-vectors that need to be compared. FPGA resources may be decreased but not significantly. The sort time increases by a factor of ⌈ M / Q ⌉ , and an FSM that selects different groups sequentially (see Fig. 11a) has to be used, which requires additional resources. For the chosen FPGAs, this method does not give advantages. However, it may turn out to be advantageous for potential future alternative FPGA architectures. The address-based sort [10] can be applied to non-repeated integers. The idea is to allocate memory with 2 M zero filled one-bit words. Each new item, I, is recorded by writing the value 1 at address I. As soon as all data items have been processed, they are sorted, so the next task is to extract the addresses from the memory. This can be done by ordering the one-bit memory words and recording their addresses (see an example in Fig. 12 a). Comparators become very simple [30]. Data have to be swapped if and only if the first one-bit value is 0 and the second one-bit value is 1 (i.e. A=0 and B=1 in Fig. 3c). Processing is executed sequentially (or, possibly, in parallel) over segments S 0,…, SR −1 (see Fig. 12b). If segments are sorted from left to right (from S 0 to SR −1), then as soon as the first segment S 0 is sorted, the addresses can be output in ascending order (because all the segments S 0,…, SR −1 are also properly ordered after recording the data items in the memory). Let us assume that each segment has N items. Since data in each segment are positioned sequentially, the most significant bits in their addresses are the same for all items. Thus at any swap we need to exchange only the least significant bits and the number of such bits is less than M. Since the address-based sort is not a target of this paper, many details are not explained, but it can be evidently seen that the proposed circuits can be applied. 7 Experiments and comparisons This section presents a thorough evaluation and comparison of the proposed circuits that have been synthesized and implemented in the Xilinx ISE 14.6 from specification in VHDL, and tested in two prototyping boards: the Atlys with the Xilinx Spartan-6 xc6slx45 FPGA [27] and ZedBoard with the Xilinx Zynq xc7z020 APSoC microchip [26]. 7.1 Experimental setup Fig. 13 shows the organization of the experiments. Initially, the proposed and the competitive known circuits were tested in the xc6slx45 FPGA and in the PL section of the APSoC Zynq xc7z020. In the both cases the FPGA (PL section) was configured autonomously, i.e. the host systems running the software were not involved. Initial data are supplied internally from embedded ROM/RAM. At the next step two types of software/hardware interactions were considered: (1) Interaction with a desktop PC through a USB port using Digilent software and drivers [21] (see Fig. 13a). (2) On-chip interactions between the PS and the PL [20] (see Fig. 13b) through AXI (Advanced eXtensible Interface). The FPGA is responsible for sorting using the known and the proposed circuits (see Figs. 3, 4b, 5a, c and 7). The host system (either a desktop PC or the PS of the APSoC xc7z020) supplies initial data and provides support for further analysis and processing of the FPGA results. Fig. 14 shows the general structure of circuits implemented in FPGA (in the PL of the xc7z020). Initial (unsorted) data are stored in embedded FPGA block RAM, which is filled using two methods: (1) from text files that are read in VHDL and copied to embedded memories during synthesis or initialization by constants in VHDL code (see number 1i on the left-hand side of Fig. 14 enclosed in a circle); (2) from a host system, i.e. from a desktop PC or PS of the xc7z020 (see number 2i on the left-hand side of Fig. 14 enclosed in a circle). Data items from the input memory are preliminarily loaded to a register R in. Since the width of available block-RAMs in FPGAs is limited, items can be transferred to the register R in from more than one memory word. For example, the available 116 blocks of 18Kb each in the FPGA xc6slx45 of the Atlys board cannot be used to read 128 items (M =32) in parallel (since the maximum width of one block is 36 [27]). However, initial data items can be read sequentially in more than one clock cycle, such as 4 cycles for 32 items (M =32). Similar sequential transfers to the output memory from the register R out are used for the sorted data. These operations are exactly the same for the proposed and the competitive circuits so the data transmission time is not taken into account. We compare throughputs only for competitive circuits that are placed between the registers R in and R out in Fig. 14. Some sequential operations that are required outside of the circuits are controlled by a hierarchical FSM [31]. We implemented several modules that can easily be invoked, modified and replaced in the HFSM that was designed with the aid of the methods [31]. For all experiments, the resources of the HFSM are not taken into account because they are not used within the sorters in Fig. 14. For pure combinational circuits, the maximum combinational path delays are taken from the ISE reports. For sequential circuits, the sort time is measured as N cc × T mp, where N cc is the number of clock cycles reported by the FSM controller from receiving source data (reading the R in) to recording the results of sorting in the R out, T mp is the minimum clock period from the ISE reports (for the maximum attainable clock frequency F max). Clearly, potential additional delays caused by the FSM controller are taken into account in such measurements. Note that the HFSM [31] is used just outside of the analyzed circuits and only conventional FSM was used to control iterations and pipelines. We implemented and tested the following competitive designs: • The proposed circuit (see Fig. 4b) vs. the pure combinational even–odd merge network. Since the even–odd merge network (see Fig. 3a) has the same throughput as the bitonic merge network (see Fig. 3b) and slightly smaller hardware resources than the bitonic merge network, only the even–odd merge network has been implemented and compared. • The proposed pipelined circuits (see Figs. 5c and 7) vs. the pipelined even–odd merge network. The sorted results are tested either directly in R out or are transferred to embedded (output) block-RAM and examined further. Two verification methods were used: (1) autonomous testing (just in FPGA) in an additional supplementary circuit that verifies that the next item is less or equal to its predecessor (see number 1o on the right-hand side of Fig. 14 enclosed in a circle); (2) in a higher-level (host) system, i.e. in a desktop PC or the PS of the xc7z020 (see number 2o on the right-hand side of Fig. 14 enclosed in a circle). 7.2 Experimental comparison of the proposed and the best known networks Section 4 estimates two basic characteristics for the proposed and the competitive circuits: throughput (i.e. the number of sorted data items per second) and complexity (i.e. the number of FPGA slices required). However, supplementary circuits and routing overhead have not been taken into account. Thus, the results of Section 4 also need to be checked experimentally, which is done in this section. Fig. 15 presents the results of synthesis, implementation and testing (in FPGA of the Atlys board) of circuits that are a pure combinational even–odd merge network and the proposed network (see Fig. 4b). Fig. 16 gives similar results for the PL section in APSoC of ZedBoard. Figs. 15a and 16a depict the percentage of FPGA resources occupied. A comparison with Table 2 shows that although the resources are increased comparing to theoretical evaluations, the tendency is the same and the number of slices for the proposed designs is significantly less than for the even–odd merge network. Figs. 15b and 16b show throughputs. We did not use the enable signal shown in Fig. 4b. If this signal is involved, then the throughput can be increased. Hardware resources are also enlarged but insignificantly and the proposed solutions require essentially a smaller number of FPGA slices than the competitive networks. Since the even–odd merge network is not as regular as the proposed circuit, delays in wires become significant, increasing routing overheads. We have already mentioned in Section 4 that in practice it is very difficult or even impossible to take advantage of the speed measured in hundred millions of data items per second because other limitations restrict the achievable performance. On the other hand, the resources used become a bottleneck preventing additional circuits from being implemented in programmable logic. Besides, the significant reduction in resources required for the proposed designs permits larger data sets to be sorted in parallel and the number of horizontal levels in merging circuits (see Fig. 9) is decreased, thus allowing additional acceleration. For example, if we compare merging from 8-item sorted sets and 256-item sorted sets, then the number of horizontal levels in Fig. 9 is reduced by a factor of 5. Fig. 17 a shows the percentage of FPGA resources occupied and Fig. 17b shows throughputs for pipelined implementations of the even–odd merge (see the structure shown in Fig. 5a) and the proposed network. The latter is evaluated for the structure shown in Fig. 5c (indicated as L =2 pipeline) and in Figs. 7 and 8 (indicated as L =4 pipeline). The experiments were done with the Atlys board and the following conclusions can be drawn: 1. The best throughput is achieved in the pipelined even–odd merge network and N =32 (M =32). However this circuit occupies more than 65% of the FPGA resources. Throughput for the proposed circuit is not as good but the resources used are a factor of 3.3 (for L =4 pipeline) and 5.5 (for L =2 pipeline) less. Note once again, that much like [8] we only analyzed the isolated performance for sorting networks that can be achieved just for small number N of data items, without taking into account the communication overheads involved in data input/output. 2. To sort larger sets of data, an FPGA is frequently used as an accelerator [2,8] while a host system/processor merges sorted subsets for larger sets. Thus, data need to be transferred to and from the FPGA. According to [27] FPGA dedicated memory controller blocks support access rates for external DDR memory of up to 800Mb/s (or for M =32-bit items∼25 mega items per second) for the Spartan-6 FPGA, and up to 1333Mb/s (or for M =32-bit items∼41mega items per second) for the Zynq APSoC [26]. Thus, the potential performance of the sorting networks (up to 3158 mega items per second for the even–odd merge network) cannot be supported in practical applications. Data exchange in APSoC (such as Zynq) permits faster data transfer between on-chip programmable logic (PL) and processing system (PS) interacting through high-performance AXI ports. However, data need to be saved, and on-chip resources (embedded block-RAM) do not permit large data sets to be processed. Thus, once again, access to external memory (shared between the PS and the PL) is involved, causing similar problems and restricting performance. Using gigabit transceivers [26,27] also does not allow to benefit from the potential performance of the sorting networks. Only data rates up to 3200Mb/s (or for M =32-bit items∼100 mega items per second) for [27] and 12,500Mb/s (or for M =32-bit items∼390 mega items per second) for [26] are supported. 3. Autonomous sorters entirely implemented in FPGA can be practical for some applications and an on-chip merger can be built. There are at least three new limitations in such circuits. Firstly, FPGA resources as a rule, do not permit a large sorter (including also a merger) to be implemented on a single chip. Secondly, merging has to be executed sequentially over individual pre-sorted subsets and the maximum clock frequency for FPGAs is limited [26,27], so no benefit from the potential performance of the sorting networks can be obtained. Thirdly, after a sorter is implemented, the remaining FPGA resources are scarce and they are significantly more limited for the known even–odd merge network than for the proposed circuits. 4. Our methods allow a sensible compromise between resources and performance to be found more easily. For example, the pipelined circuit (L =2) can be implemented in the xc6slx45 FPGA for up to N =256 (see Fig. 17a) and, thus, 8-times more items than in the even–odd merge circuit can be processed. The pipelined circuit (L =4) can be implemented in the xc6slx45 FPGA for up to N =128 (see Fig. 17a). If we compare the throughputs of the pipelined even–odd merge and the proposed (L =4) circuits we can see that although the proposed circuits are slower, in any case, we cannot take advantage of the higher throughput in practical applications (see point 2 above). 5. There is one result that is hard to explain. The resources for pipelined even–odd merge networks are a bit smaller than for combinational even–odd merge networks. The difference is negligible but it exists. We found that similar results were obtained in [8, see Section 6.4.2], where it was also not quite clear, and it was assumed that this is a feature of the Xilinx synthesis tools. 6. The analysis above has shown that the resources needed become a bottleneck for practical applications that cannot benefit from very high performance of sorters operating over data with limited number of items because systems that use the sorters cannot support the required speed for input/output data. The proposed solutions clearly demonstrate very good compromise between resource consumption and performance and can be seen as more practical and widely applicable for both autonomous small size very fast sorters and FPGA-based accelerators for higher-level systems (such as implemented in the PS). In all the experiments above, the enable signal that decreases the number of sequential steps in the proposed circuit was not used, i.e. the worst (the slowest) case for the proposed circuits has been analyzed. Clearly this signal can be used to obtain additional performance improvements. Some experiments with the ZedBoard demonstrate the same chart tendencies as in Fig. 17. We were able to implement the even–odd merge network for up to N =64 (a similar result was reported in [8] for the Virtex-5 FPGA) and the proposed network for up to N =512. The majority of contemporary FPGAs possess embedded DSP slices (ex. DSP48E1 slice for Xilinx FPGAs [22]) and they can be used to implement comparators of the network through the execution of a subtraction operation. Let us consider Fig. 3c where operands A and B have to be compared. An operation A–B executed in a DSP gives a result that is negative if B is greater than A, zero if A=B, or positive if A is greater than B. We found that swapping A and B in Fig. 3c requires more slices than the comparator described above. For the APSoC Zynq xc7z020 (ZedBoard) and M =32, a comparator occupies just 5 of 17 slices needed for the circuit in Fig. 3c. Nevertheless, making use of embedded DSPs that are available in addition to logical slices in any event permits larger sorters to be implemented in the same FPGA. For example, the PL section in the APSoC xc7z020 embeds 220 DSP48E1 slices processing 48-bit operands (M =48) and the most advanced FPGAs contain thousands of such slices. Our experiments have demonstrated that the FPGA resources needed for comparators and swappers can be reduced by approximately 20%, although the maximum attainable frequency is also slightly reduced. The enable signal (see Fig. 4b) requires ORing N/2-1 signals and it can also be produced in a DSP slice. Indeed, the DSP48E1 [22] permits bitwise logical operations to be executed over 48-bit operands. Thus, two 48-bit operands can be ORed in one slice and the result can be tested for 0, which is the equivalent of verifying 96bits from the comparators. This operation is fast, simple, and does not use logical slices. 8 Conclusion The fastest known sorting networks (namely, the even–odd merge and the bitonic merge) consume very large hardware resources and can only be implemented in FPGAs for processing small number of items even in advanced devices. Furthermore, they require convoluted interconnection involving numerous multiplexing operations that lead to excessive propagation delays. We found that very regular even–odd transition networks with two sequentially reusable vertical lines of comparators are more practical because they operate with a higher clock frequency, provide sufficient throughput, and enable a significantly larger number of items to be sorted on the same microchip. Further, a pipeline can be constructed and the number of vertical lines increased, allowing a compromise between the performance and resources to be found. The emphasis is on the ability to implement the circuits in commercially available FPGAs and on a compromise between affordable hardware resources and attainable throughputs, taking into account not only the network performance, but also the constraints imposed by surrounding systems. Finally, the results of extensive experiments (evaluating both pure combinational and pipelined implementations of the known and the proposed networks) and comparisons are presented, which clearly demonstrate the significant advantages of the proposed technique, which can be used both autonomously and in combination with such popular methods as merge sort, address-based sort, quicksort, and radix sort. Acknowledgments The authors would like to thank Ivor Horton for his very useful comments and suggestions. This research was supported by FEDER through the Operational Program Competitiveness Factors – COMPETE and by National Funds through FCT – Foundation for Science and Technology in the context of Projects FCOMP-01-0124-FEDER-022682 (FCT reference PEst-C/EEI/UI0127/2011) and Incentivo/EEI/UI0127/2013. References [1] D.E. Knuth The Art of Computer Programming. Sorting and Searching vol. III 2011 Addison-Wesley [2] R. Mueller J. Teubner G. Alonso Sorting networks on FPGAs Int. J. Very Large Data Bases 21 1 2012 1 23 [3] J. Ortiz, D. Andrews, A configurable high-throughput linear sorter system, in: Proceedings of IEEE International Symposium on Parallel & Distributed Processing, April, 2010, pp. 1–8. [4] M. Zuluada, P. Milder, M. Puschel, Computer generation of streaming sorting networks, in: Proceedings of the 49th Design Automation Conference, San Francisco, June, 2012, pp. 1245–1253. [5] D.J. Greaves, S. Singh, Kiwi: Synthesis of FPGA circuits from parallel programs, in: Proceedings of the 16th IEEE International Symposium on Field-Programmable Custom Computing Machines – FCCM’08, USA, 2008, pp. 3–12. [6] S. Chey, J. Liz, J.W. Sheaffery, K. Skadrony, J. Lach, Accelerating compute-intensive applications with GPUs and FPGAs, in: Proceedings of the Symposium on Application Specific Processors – SASP’08, USA, 2008, pp. 101–107. [7] R.D. Chamberlain, N. Ganesan, Sorting on architecturally diverse computer systems, in: Proceedings of the 3rd International Workshop on High-Performance Reconfigurable Computing Technology and Applications – HPRCTA’09, USA, 2009, pp. 39–46. [8] R. Mueller, Data Stream Processing on Embedded Devices, Ph.D. Thesis, ETH, Zurich, 2010. [9] D. Koch, J. Torresen, FPGASort: a high performance sorting architecture exploiting run-time reconfiguration on FPGAs for large problem sorting, in: Proceedings of the 19th ACM/SIGDA International Symposium on Field Programmable Gate Arrays – FPGA’11, USA, 2011, pp. 45–54. [10] V. Sklyarov, I. Skliarova, D. Mihhailov, A. Sudnitson, Implementation in FPGA of address-based data sorting, in: Proceedings of the 21st International Conference on Field-Programmable Logic and Applications – FPL’11, Greece, 2011, pp. 405–410. [11] GPU Gems, Improved GPU Sorting. [12] G. Gapannini F. Silvestri R. Baraglia Sorting on GPU for large scale datasets: a thorough comparison Inf. Process. Manage. 48 5 2012 903 917 [13] X. Ye, D. Fan, W. Lin, N. Yuan, P. Ienne, High performance comparison-based sorting algorithm on many-core GPUs, in: Proceedings of the IEEE International Symposium on Parallel & Distributed Processing – IPDPS’10, USA, 2010, pp. 1–10. [14] N. Satish, M. Harris, M. Garland, Designing efficient sorting algorithms for manycore GPUs, in: Proceedings of the IEEE International Symposium on Parallel & Distributed Processing – IPDPS’09, Italy, 2009, pp. 1–10. [15] D. Cederman, P. Tsigas, A practical quicksort algorithm for graphics processors, in: Proceedings of the 16th Annual European Symposium on Algorithms – ESA’08, Germany, 2008, pp. 246–258. [16] C. Grozea Z. Bankovic P. Laskov FPGA vs. multi-core CPUs vs. GPUs R. Keller D. Kramer J.P. Weiss Facing the Multicore-challenge 2010 Springer-Verlag Berlin, Heidelberg 105 117 [17] M. Edahiro, Parallelizing fundamental algorithms such as sorting on multi-core processors for EDA acceleration, in: Proceedings of the 18th Asia and South Pacific Design Automation Conference – ASP-DAC’09, Japan, 2009, pp. 230–233. [18] K.E. Batcher, Sorting networks and their applications, in: Proceedings of AFIPS Spring Joint Computer Conference, USA, 1968, pp. 307–314. [19] S. Lacey R. Box A fast easy sort: a novel enhancement makes a bubble sort into one of the fastest sorting routines Byte 16 4 1991 315 316 318, 320 [20] ZedBoard (Zynq™ Evaluation and Development), Hardware User’s Guide. [21] Digilent Boards, Drivers, and VHDL Modules. [22] 7 Series DSP48E1 Slice User Guide UG479 (v1.5), April 3, 2013. [23] B. Cope P.Y.K. Cheung W. Luk L. Howes Performance comparison of graphics processors to reconfigurable logic: a case study IEEE Trans. Comput. 59 4 2010 433 448 [24] I. Skliarova A.B. Ferrari Reconfigurable hardware SAT solvers: a survey of systems IEEE Trans. Comput. 53 11 2004 1449 1461 [25] C. Alias B. Pasca A. Plesco FPGA-specific synthesis of loop-nests with pipelined computational cores Microprocess. Microsyst. 36 8 2012 606 619 [26] Zynq-7000 All Programmable SoC Overview. [27] Xilinx, Spartan-6 Family Overview. [28] Sorting Algorithms. [29] S. Sengupta, M. Harris, Y. Zhang, J.D. Owens, Scan Primitives for GPU Computing, GH’07, Eurographics Association, Switzerland, 2007. [30] S.J. Piestrak Efficient hamming weight comparators of binary vectors Electronic Lett. 43 11 2007 611 612 [31] V. Sklyarov FPGA-based implementation of recursive algorithms Microprocess. Microsyst. 28 5–6 2004 197 211 (Special Issue on FPGAs: Applications and Designs) Valery Sklyarov received the Engineering degree from the Technical University – UPI, Uljanovsk, Russia, in 1972, the Ph.D. degree in computer science from the Technical University – BSUIR, Minsk, Belarus, in 1978, the Doctor of Science degree in computer science from the Technical University – LETI, St. Petersburg, Russia, in 1986 and the Aggregation (Agregação) in electronic engineering from University of Aveiro, Portugal in 2001. From 1972 to 1978 he was with the Research Institute, Minsk. From 1978 to 1994 he was with the Belorussian State University of Informatics and Radioelectronics, Belarus as an Associate Professor, and from 1987 onwards, as a Professor and the Head of the Computer Science Department. Since 1994 he has been with the Department of Electronics and Telecommunications, University of Aveiro, Portugal, where he is currently a Professor of computer engineering. He has authored and co-authored 20 books and over 300 papers on subjects which include reconfigurable computing, data processing, digital design, computer architecture, and programming. The research interests include design and optimization of reconfigurable digital systems. Iouliia Skliarova received the M.Sc. degree, in Computer Engineering, from the Belorussian State University of Informatics and Radioelectronics, Minsk, Republic of Belarus, in 1998, and the Ph.D. degree, in Electrical Engineering, from the University of Aveiro, Portugal, in 2004. She is currently an Assistant Professor in the Department of Electronics, Telecommunications and Informatics, University of Aveiro and the head of laboratory of Embedded Systems, Computing and Control in the Institute of Electronics Engineering and Telematics of Aveiro. She has authored and co-authored three books and over 100 papers on subjects which include reconfigurable systems, data processing, digital design, and combinatorial optimization. Her research interests include reconfigurable digital systems, application-specific architectures, and computer-aided design. "
    },
    {
        "doc_title": "Hamming weight counters and comparators based on embedded DSP blocks for implementation in FPGA",
        "doc_scopus_id": "84901843912",
        "doc_doi": "10.4316/AECE.2014.02011",
        "doc_eid": "2-s2.0-84901843912",
        "doc_date": "2014-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "This paper is dedicated to the design, implementation and evaluation of fast FPGA-based circuits that compute Hamming weights for binary vectors and compare the results with fixed thresholds and variable bounds. It is shown that digital signal processing (DSP) slices that are widely available in contemporary FPGAs may be used efficiently and they frequently provide the fastest and least resource consuming solutions. A thorough analysis and comparison of these with the best known alternatives both in hardware and in software is presented. The results are supported by numerous experiments in recent prototyping boards. A fully synthesizable hardware description language (VHDL) specification for one of the proposed core components is given that is ready to be synthesized, implemented, tested and compared in any FPGA that contains embedded DSP48E1 slices (or alternatively DSP48A1 slices from previous generations). Finally, the results of comparisons are provided that include discussions of designs in an ARM processor combined with reconfigurable logic for very long vectors.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Fast matrix covering in all programmable systems-on-chip",
        "doc_scopus_id": "84901019834",
        "doc_doi": "10.5755/j01.eee.20.5.7116",
        "doc_eid": "2-s2.0-84901019834",
        "doc_date": "2014-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The paper suggests a technique for solving the matrix/set covering problem in all programmable systems-onchip. A novel very fast hardware accelerator is proposed and implemented in the programmable logic (PL) of a Xilinx Zynq microchip. The accelerator is managed by software running in the processing system (ARM Cortex-A9) available on the same microchip and communicating with the PL through high-speed interfaces. The results of implementation, experiments, and comparisons demonstrate significant speedup comparing to software running in general-purpose PC and in the ARM.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Optimization of address-based data sorting unit with external memory support",
        "doc_scopus_id": "84889594834",
        "doc_doi": "10.1145/2516775.2516807",
        "doc_eid": "2-s2.0-84889594834",
        "doc_date": "2013-12-11",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Human-Computer Interaction",
                "area_abbreviation": "COMP",
                "area_code": "1709"
            },
            {
                "area_name": "Computer Vision and Pattern Recognition",
                "area_abbreviation": "COMP",
                "area_code": "1707"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Data sorting",
            "Design constraints",
            "External memory",
            "Graphics processing units",
            "Reconfigurable computing"
        ],
        "doc_abstract": "Among numerous data processing tasks sorting is considered to be one of the most important. Sorting still poses a big challenge as it actually becomes harder to solve this problem efficiently and fast with the constant demand for processing of larger and larger data sets in a reasonable amount of time. Reconfigurable computing provides an attractive option for implementation of data processing in the context of hardware, as the use of Field Programmable Gate Arrays (FPGAs) allows to eliminate the design constraints of processors and graphics processing units (GPUs) with predefined architectures. In this paper a technique that improves the performance of the address-based data sorting unit with an external DDR3 flag memory is proposed. It is demonstrated that the proposed technique can efficiently reduce the communication penalties associated with the use of external memory. © 2013 ACM.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Address-based data processing over N-ary trees",
        "doc_scopus_id": "84888586028",
        "doc_doi": "10.1109/EUROCON.2013.6625220",
        "doc_eid": "2-s2.0-84888586028",
        "doc_date": "2013-12-04",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Computational algorithm",
            "Data processing algorithms",
            "Functional block",
            "Hardware implementations",
            "Hardware resources",
            "High-performance computing",
            "N-ary trees",
            "Search"
        ],
        "doc_abstract": "The existing trends and growing tendency to high-performance computing strongly require traditional computational algorithms to be revised in such a way that would permit optimal hardware implementations to be found. The latter can be done if algorithms can efficiently be mapped to hardware-specific functional blocks that require different style of thinking and manipulation by different operations and memory models. Besides, concurrency (pipelining and parallelism) can be widely applied. This paper focuses on data processing algorithms that use values of incoming data items as memory addresses with one-bit flags indicating presence or absence of data. The main problem of similar known methods is an appearance of huge number of memory cells with no data items (empty holes), which, nevertheless, have to be processed involving lots of unnecessary time. It is proposed to apply N-ary tree technique that enables data items to be stored and found very fast through executing special traversal procedure. Such trees completely differ from known tree-walk tables because they have pre-established configuration that does not require explicit addresses of subsequent (child) nodes. As a result the size of memory needed to keep data items is decreased in number of times. Finally, significantly more complicated problems can be solved faster and with smaller hardware resources. The presented results of numerous experiments clearly demonstrate advantages of the proposed method compared to known implementations. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Implementation of address-based data sorting on different FPGA platforms",
        "doc_scopus_id": "84893462933",
        "doc_doi": "10.1109/EWDTS.2013.6673195",
        "doc_eid": "2-s2.0-84893462933",
        "doc_date": "2013-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Data sorting",
            "Fpga platforms",
            "Hardware circuits",
            "Implementation platforms",
            "Large volumes",
            "Low costs"
        ],
        "doc_abstract": "Among numerous tasks that need to be solved, sorting is considered to be one of the most important. Since it is time consuming for large volumes of data, acceleration is greatly required for many practical applications. It is also important to discover such methods that take advantage of the implementation platform (due to its uniqueness) and consider not only the number of the required operations, but also efficiency of their implementation in hardware circuits. This paper evaluates implementations of address-based data sorting algorithms in field-programmable gate array (FPGA) circuits. It is demonstrated that the proposed technique can be used efficiently both in low cost FPGAs as well as in advanced FPGAs, and the number of sorted items (with sizes of up to 32 bits) can reach 232. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Implementation of parallel operations over streams in extensible processing platforms",
        "doc_scopus_id": "84893202535",
        "doc_doi": "10.1109/MWSCAS.2013.6674783",
        "doc_eid": "2-s2.0-84893202535",
        "doc_date": "2013-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electronic, Optical and Magnetic Materials",
                "area_abbreviation": "MATE",
                "area_code": "2504"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Advanced RISC machines",
            "Filtering problems",
            "Hamming weights",
            "High performance systems",
            "Parallel operations",
            "Processing platform",
            "Programmable logic",
            "Proposed architectures"
        ],
        "doc_abstract": "The paper discusses the use of extensible processing platforms for the design of high-performance systems which combine fast parallel operations over data streams in programmable logic and problem-specific software running in advanced RISC machine. The streams contain information that needs to be analyzed and filtered. The main idea is to digitalize frequently changed data from numerous sensors and to represent each data item in form of a binary vector. It is shown that many analysis and filtering problems can be solved through Hamming weight counting for the vectors and comparison of the results with pre-given bounds (thresholds). The proposed architecture takes advantages from fixed plus variable computations and implements novel methods. The results of experiments and evaluations of the architecture in two Zynq-based prototyping boards are also presented. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Using mobile technology to enhance teaching reconfigurable systems",
        "doc_scopus_id": "84892657435",
        "doc_doi": "10.1109/TALE.2013.6654485",
        "doc_eid": "2-s2.0-84892657435",
        "doc_date": "2013-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Education",
                "area_abbreviation": "SOCI",
                "area_code": "3304"
            }
        ],
        "doc_keywords": [
            "Animated tutorials",
            "Educational process",
            "Electrical and computer engineering",
            "Engineering practices",
            "Engineering resources",
            "International collaborations",
            "Reconfigurable computing",
            "Reconfigurable systems"
        ],
        "doc_abstract": "Nowadays, reconfigurable computing constitutes an essential part of engineering practice. This undoubtedly requires huge qualified engineering resources. To assist the educational process in the scope of reconfigurable systems, animated tutorials, mini-projects, language templates, and a course-oriented library have been developed and reported in previous publications. This paper discusses further improvements and international collaboration in relevant courses based on the results of the project 'Using HP mobile technology to enhance teaching reconfigurable systems in electrical and computer engineering curricula' running in 2009-2012. Assessment results are presented proving that the innovations have led to improved student learning. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Digital Hamming weight and distance analyzers for binary vectors and matrices",
        "doc_scopus_id": "84886425789",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84886425789",
        "doc_date": "2013-12-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            }
        ],
        "doc_keywords": [
            "Combinatorial search",
            "Hamming weights",
            "Hardware implementations",
            "Parallel system",
            "Performance/resources analysis",
            "Processing platform",
            "Reconfigurable logic",
            "Sorting and searching"
        ],
        "doc_abstract": "In this paper vie explore modules that can analyze binary vectors and matrices and efficiently solve a wide range of problems that involve the computation of Hamming weights or Hamming distances, producing counts and/or comparisons of these, as well as sorting and searching. A set of designs for such modules is proposed and all the designs have been evaluated both theoretically and practically. The practical evaluation involved numerous experiments with hardware implementations using the most recent extensible processing platform that incorporates reconfigurable logic. The objective was to achieve high performance within reasonable resources. As a result, novel solutions for Hamming weight counters/comparators have been identified that have better cost and latency than the best known alternatives. Network-based sorters and searchers with reusable cores are also discussed and these enable high throughput to be achieved with relatively modest resources. The paper shows that similar results cannot be obtained using the best known and most frequently used even-odd merge and bitonic merge networks. Finally, a complete architecture for an analyzer is presented, part of which (covering the modules indicated above) has been completely implemented and prototyped in hardware. © 2013 ICIC International.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Fast regular circuits for network-based Parallel data processing",
        "doc_scopus_id": "84890199222",
        "doc_doi": "10.4316/AECE.2013.04008",
        "doc_eid": "2-s2.0-84890199222",
        "doc_date": "2013-11-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "This paper is dedicated to the design, implementation, and evaluation of fast circuits executing operations that are frequently required in data processing which are: 1) discovering the maximum and minimum values in a given set of data; and 2) sorting data items. We found that minimizing the number of circuit components does not guarantee minimal hardware resources. This is because interconnections also influence the complexity significantly. Network-based circuits are often considered to be combinational. However, this does not mean that they are faster than sequential circuits solving the same problem because propagation delays can be considerable. We revised the existing network-based solutions and proposed regular circuits which provide a good compromise between hardware resources and performance. © 2013 AECE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis of parallel hierarchical finite state machines",
        "doc_scopus_id": "84886900400",
        "doc_doi": "10.1109/IranianCEE.2013.6599683",
        "doc_eid": "2-s2.0-84886900400",
        "doc_date": "2013-10-25",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Hardware accelerators",
            "Hierarchical finite state machines",
            "Hierarchy",
            "Programming technique",
            "Recursions",
            "State transition diagrams"
        ],
        "doc_abstract": "This paper presents a novel model and method for synthesis of parallel hierarchical finite state machines (PHFSM) that permit to implement such algorithms, which are: 1) composed of modules; 2) the modules can be activated from other modules; 3) more than one module can be activated in parallel. The synthesis involves three basic steps: 1) conversion of a given specification to special state transition diagrams; 2) use of the proposed hardware description language templates; 3) synthesis of the circuit from the templates. The results of experiments have proven the effectiveness and practicability of the proposed technique. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware implementations of software programs based on hierarchical finite state machine models",
        "doc_scopus_id": "84885601459",
        "doc_doi": "10.1016/j.compeleceng.2013.07.019",
        "doc_eid": "2-s2.0-84885601459",
        "doc_date": "2013-10-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Electronic systems",
            "General-purpose programming language",
            "Hardware implementations",
            "Hierarchical finite state machines",
            "Micro-electronic devices",
            "Multi-core processor",
            "Programming technique",
            "Software and hardwares"
        ],
        "doc_abstract": "Advances in microelectronic devices have dissolved the boundary between software and hardware. Faster hardware circuits that enable significantly greater parallelism to be achieved have encouraged recent research efforts into high-performance computation in electronic systems without the direct use of processing cores. Standard multi-core processors undoubtedly introduce a number of constraints, such as pre-defined operand sizes and instruction sets, and limits on concurrency and parallelism. This paper suggests a way to convert methods and functions that are defined in a general-purpose programming language into hardware implementations. Thus, conventional programming techniques such as function hierarchy, recursion, passing arguments and returning values can be entirely implemented in hardware modules that execute within a hierarchical finite state machine with extended capabilities. The resulting circuits have been found to be faster than their software alternatives and this conclusion is confirmed by numerous experiments in a variety of application areas. © 2013 Elsevier Ltd. All rights reserved.",
        "available": true,
        "clean_text": "serial JL 271419 291210 291718 291869 291883 31 Computers & Electrical Engineering COMPUTERSELECTRICALENGINEERING 2013-08-19 2013-08-19 2013-10-09T16:47:03 S0045-7906(13)00204-8 S0045790613002048 10.1016/j.compeleceng.2013.07.019 S300 S300.1 FULL-TEXT 2015-05-15T01:11:01.957214-04:00 0 0 20131001 20131031 2013 2013-08-19T00:00:00Z articleinfo crossmark dco dateupdated tomb dateloaded datesearch indexeddate issuelist volumelist yearnav absattachment articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids contenttype copyright dateloadedtxt docsubtype doctype doi eid ewtransactionid hubeid issfirst issn issnnorm itemstage itemtransactionid itemweight openaccess openarchive pg pgfirst pglast pii piinorm pubdateend pubdatestart pubdatetxt pubyr sectiontitle sortorder srctitle srctitlenorm srctype subheadings volfirst volissue figure table body mmlmath acknowledge affil articletitle auth authfirstini authfull authlast highlightsabst primabst ref specialabst vitae alllist content subj ssids 0045-7906 00457906 true 39 39 7 7 Volume 39, Issue 7 18 2145 2160 2145 2160 201310 October 2013 2013-10-01 2013-10-31 2013 Regular Papers article fla Copyright © 2013 Elsevier Ltd. All rights reserved. HARDWAREIMPLEMENTATIONSSOFTWAREPROGRAMSBASEDHIERARCHICALFINITESTATEMACHINEMODELS SKLYAROV V 1 Introduction 2 Related work 3 Hierarchical finite state machines 4 From software to hardware 5 Optimization technique 6 Parallel HFSM 7 Experiments and comparisons 7.1 New contributions 7.2 Software/hardware co-design 7.3 Performance and resources evaluation 8 Conclusion Acknowledgments References SANTARINI 2011 M LATIF 2011 1043 1057 K AZIZ 2009 790 802 S SABAEI 2001 333 343 M GUO 2008 Z HOLLSTEIN 2007 S.310 S.319 T SKLYAROV 2013 V PARALLELPROCESSINGINFPGABASEDDIGITALCIRCUITSSYSTEMS SKLYAROV 2002 1043 1064 V MIHHAILOV 2011 51 56 D MUNOZ 2008 1309 1320 D HAREL 1987 231 274 D SKLYAROV 2004 197 211 V ZAKREVSKIJ 2008 A COMBINATORIALALGORITHMSDISCRETEMATHEMATICS MUELLER 2012 1 23 R SKLYAROVX2013X2145 SKLYAROVX2013X2145X2160 SKLYAROVX2013X2145XV SKLYAROVX2013X2145X2160XV item S0045-7906(13)00204-8 S0045790613002048 10.1016/j.compeleceng.2013.07.019 271419 2013-10-09T14:24:48.221925-04:00 2013-10-01 2013-10-31 true 1792274 MAIN 16 52580 849 656 IMAGE-WEB-PDF 1 si9 246 19 19 si8 249 19 19 si7 246 19 19 si6 246 19 19 si5 246 19 19 si49 223 14 19 si48 223 14 19 si47 223 14 19 si46 223 14 19 si45 319 20 36 si44 379 19 64 si43 297 18 33 si42 297 18 33 si41 319 20 36 si40 379 19 64 si4 246 19 19 si39 297 18 33 si38 223 14 19 si37 223 14 19 si36 223 14 19 si35 223 14 19 si34 223 14 19 si33 223 14 19 si32 223 14 19 si31 246 19 19 si30 246 19 19 si3 246 19 19 si29 246 19 19 si28 246 19 19 si27 246 19 19 si26 246 19 19 si25 350 20 48 si24 246 19 19 si23 246 19 19 si22 244 19 19 si21 246 19 19 si20 244 19 19 si2 246 19 19 si19 244 19 19 si18 244 19 19 si17 244 19 19 si16 244 19 19 si15 244 19 19 si14 246 19 19 si13 244 19 19 si12 246 19 19 si11 244 19 19 si10 246 19 19 si1 223 14 19 gr1 13964 126 420 fx1 true 38023 200 487 gr9 25811 173 490 gr8 16829 153 267 gr7 13317 143 322 gr6 64583 343 492 gr5 35508 319 425 gr4 10474 96 357 gr3 31136 212 477 gr2 20574 148 374 gr11 40620 370 506 gr10 18823 151 423 gr1 3384 66 219 fx1 true 8313 90 219 gr9 4543 77 219 gr8 6465 126 219 gr7 4633 97 219 gr6 10007 153 219 gr5 6891 164 219 gr4 3113 59 219 gr3 5437 98 219 gr2 5248 87 219 gr11 5886 160 219 gr10 4209 78 219 CAEE 1280 S0045-7906(13)00204-8 10.1016/j.compeleceng.2013.07.019 Elsevier Ltd Fig. 1 Nodes of a hierarchical graph-scheme. Fig. 2 HFSM, which provides support for hierarchy and recursive computations. Fig. 3 Description of Java methods by sequentially executed HGSs. Fig. 4 Using additional elements for passing arguments and returning values/pointers. Fig. 5 (a) Single block of embedded/distributed RAM for the three stacks in Fig. 4, (b) active stack register, and (c) state transitions and hierarchical calls through the FSM conventional register. Fig. 6 Three types of stack transitions in HFSM: (a) hierarchical calls; (b) conventional transitions, and (c) hierarchical returns. Fig. 7 Examples of parallel operations. Fig. 8 An example of N -ary tree (N =4). Fig. 9 A pipeline controlled by an HFSM module. Fig. 10 Implemented interaction between the PS and PL. Fig. 11 Resource (a) and performance (b) evaluation for different circuits implemented and tested in the Atlys board. Table 1 The results of experiments. Problem Handel-C projects [21] VHDL projects [21] New VHDL projects Recursive Iterative Recursive Iterative Recursive Iterative P 1 (ns) 1293/1957 750/1341 475/963 463/1293 408/718 436/797 P 2 (μs) 5118/7280 5118/7280 2073/920 1911/912 1719/636 1659/601 Table 2 Experiments with pure parallel and sequential circuits. N s F max (MHz) ET (ns) Even–odd merge sorting network 474 (6%) a 21.0 47.5 Bitonic merge sorting network 584 (8%) a 21.4 46.7 HFSM-based circuit 279 (4%) a 122.3 32.8 a Resources used include also circuits for interactions with the host computer. Table 3 The results of the projects calculating the greatest common divisor of κ unsigned 32-bit integers (see Sections 4-6 above for details). Project (κ =4 for the first four lines and κ =8 for the last line) Atlys prototyping board (Xilinx FPGA Spartan-6) N s F max (MHz) The best previous result 737 62.9 Sequential (without memory blocks) 616 64.2 Sequential (with memory blocks) 343 74.7 Parallel1 (with memory blocks) 446 70.9 Parallel2 (with memory blocks) 721 66.2 ☆ Reviews processed and recommended for publication to Editor-in-Chief by Associate Editor Dr. Rene Cumplido. Hardware implementations of software programs based on hierarchical finite state machine models Valery Sklyarov ⁎ Iouliia Skliarova Department of Electronics, Telecommunications and Informatics/IEETA, University of Aveiro, Aveiro 3810-193, Portugal Department of Electronics, Telecommunications and Informatics/IEETA University of Aveiro Aveiro 3810-193 Portugal ⁎ Corresponding author. Tel.: +351 234401539. Graphical abstract Advances in microelectronic devices have dissolved the boundary between software and hardware. Faster hardware circuits that enable significantly greater parallelism to be achieved have encouraged recent research efforts into high-performance computation in electronic systems without the direct use of processing cores. Standard multi-core processors undoubtedly introduce a number of constraints, such as pre-defined operand sizes and instruction sets, and limits on concurrency and parallelism. This paper suggests a way to convert methods and functions that are defined in a general-purpose programming language into hardware implementations. Thus, conventional programming techniques such as function hierarchy, recursion, passing arguments and returning values can be entirely implemented in hardware modules that execute within a hierarchical finite state machine with extended capabilities. The resulting circuits have been found to be faster than their software alternatives and this conclusion is confirmed by numerous experiments in a variety of application areas. 1 Introduction Nowadays, the development of software and hardware becomes more and more interrelated. The emphasis has significantly shifted from general-purpose to application-specific products in the form of embedded processing modules in various areas such as communications, industrial automation, automotive computers, and home electronics. To support application-specific computations, a number of new engineering solutions and technological innovations have been proposed. There is a tendency to integrate components on a chip that not so long ago were separated and implemented as autonomous ASICs (application-specific integrated circuits) or ASSP (application-specific standard products). A few years ago, individual ASICs/ASSPs were assembled together with the surrounding logic, often implemented in autonomous FPGAs (field-programmable gate arrays); today all these components are coupled within the same micro-chip. For example, the Zynq-7000 [1] extensible processing platform (EPP) incorporates a processing system (PS) that combines the industry-standard ARM dual-core Cortex™-A9 32-bit RISC processor and a number of peripherals such as memory controllers, USB (universal serial bus), Gigabit Ethernet, and UART (universal asynchronous receiver/transmitter). The same micro-chip contains a built-in gate array (programmable logic – PL) from the Artix-7 or Kintex-7 FPGA families that is linked with the PS through the AXI (advanced extensible interface). EPPs like Zynq [1] can run software that interacts with parallel processing elements (PE) that have been mapped to hardware. The main objective of any PE is to provide greater performance than an equivalent software component with similar functionality that is typically composed of a set of functions in C, or methods in Java. The relative effectiveness (e.g. performance) of software modules that have been mapped to hardware PEs needs to be tested, analyzed and compared. Thus, it is important to be able to create the functionality of typical software constructions directly in hardware circuits. This paper addresses the provision of modularity, hierarchy (including recursion), and parallelism in hardware. Modularity and hierarchy are very widely used techniques in general-purpose programming. They are supported by the majority of application-specific development systems for the design of software in single/multi-core autonomous and built-in microcontrollers, mainly originating from specifications in C, and less frequently in Java. In many practical cases, there is a need for hardware accelerators to achieve higher performance by parallelizing the most critical parts of the programs in hardware circuits. Thus, mapping such processor-intensive software fragments to hardware by applying potential parallelism becomes very important. There are many known methods that allow modularity, hierarchy and parallelism to be realized in hardware and a survey of some of these is presented in [2]. Our approach is based on a hierarchical finite state machine (HFSM) model, which is less constrained than potential alternatives [2], can easily be implemented in hardware, and is very consistent with the corresponding software technique. The model is also supported by known templates that are fully synthesizable [2] in commercial computer-aided design (CAD) systems. The next sections provide additional details of the model, review and compare existing alternatives, and explicitly indicate innovations proposed in the paper through the following contributions: 1. A new HFSM model with datapath based on optimized stacks built from memory blocks (see Sections 4 and 5). 2. A regular technique permitting the values of signals (as well as pointers) to be supplied to the invoked HFSM modules and the returned values (pointers) to be accessed after terminating the modules, which makes easier to generate hardware from software procedures (see Sections 4 and 5). 3. Concurrent execution of HFSM modules permitting broad parallelism to be supported (see Section 6). 4. Examples of practical applications clearly demonstrating benefits that are gained from the proposed extended HFSM capabilities through experiments and comparisons (see Section 7). The remainder of the paper is organized in seven sections. Section 2 analyzes the related work aimed at the acceleration of software through hardware, but not necessarily based on the technique proposed in this paper. Section 3 describes the HFSM model and demonstrates how this enables software methods and functions to be mapped to electronic circuits. Special attention is paid to the advantages and distinctive features of this model. Section 4 discusses the tradeoffs between software and hardware and presents in detail the proposed novel technique for converting methods and functions from general-purpose languages to hardware. Section 5 suggests a method for the optimization of HFSM memory. Section 6 considers regular solutions for parallel implementations. Section 7 is dedicated to practical applications, experiments, and comparisons. The conclusion is given in Section 8. 2 Related work Combining the capabilities of software and hardware permits many characteristics of existing applications to be improved. The earliest work on this was done at the University of California in Los Angeles [3]. The idea was to create a computer with a fixed + variable structure by augmenting a standard processor with an array of reconfigurable logic, assuming that this logic can be utilized to solve some processor tasks faster and more efficiently. Such a combination of the flexibility of software and the speed of hardware was considered to be a new way to evolve higher performance computing from any general purpose computer. The level of technology in 1959–1960 prevented this idea from being put in practice. Today a very similar technique has been implemented on a chip that combines multi-core processors, embedded blocks, and advanced reconfigurable logic. For example, the Xilinx Zynq xc7z020 EPP [1] permits the implementation and testing of: (1) systems requiring the development of software and invoking the on-chip PS; (2) application-specific hardware in PL using embedded blocks such as DSPs (digital signal processors) and memories, and arbitrary logic composed of FPGA slices; and (3) a fixed + variable structure computational system combining the PS and the PL with high-speed data exchange between them. Let us discuss a potential scenario for interactions between the PS and the PL. The PL implements a set of modules that are activated from the PS. A module is a hardware circuit that executes a dedicated task. It is an entity in a hardware description language (HDL) such as VHDL that potentially invokes other entities. Data exchange is provided either directly between the PS and the PL, or through a shared window in memory that is accessed from the both the PS and the PL. As soon as the PS needs to initiate accelerated operations, it sends a request to the PL and either transfers data associated with the operations to the PL, or indicates an address and size for the shared memory area in which the data are stored. The PL executes the operations and informs the PS as soon as the operations have been completed. Finally, the results are transferred back, either directly or through the shared memory window. Clearly the PS and the modules implemented in the PL can work in parallel. To accelerate software running on the PS, we need to be able to replace time-consuming software procedures (functions in C) with functionally equivalent hardware modules that are faster and to apply parallelism and pipelining. Thus, we need fast mechanisms that enable selected software functions to be converted to hardware modules that provide the equivalent functionality, and thus execute exactly the same operations as the software functions, but faster. This problem has been widely investigated and several common techniques have been applied. A direct approach is to take an entire software program and apply an automatic conversion to hardware. The program can be written in a general-purpose language (GPL) (most often in C), or in a system-level specification language (SLSL), which is a modified GPL that provides hardware-targeted constructions such as variable operands sizes and parallelism to be described more efficiently. For example, Impulse-C and Handel-C add explicit constructs to the C language that specify parallelism and timing in order to create hardware. A compiler [4] generates circuits from high-level languages that support a modular bottom-up construction. It takes a subset of C without the addition of explicit parallelism and produces hardware accelerators. An alternative technique is used in such toolsets as Catapult-C and Dime-C. These target particular platforms and optimize selected subsets of C to benefit from their implementation in hardware. The tools referenced above are undoubtedly effective and they have been widely used in engineering practice. They are commonly applied to a register-transfer level (RTL). Optimization of control dominated applications that involve sophisticated finite state machines (FSM) is limited. For example, in Celoxica Handel-C, FSMs were realized in a very simple way and such features as hierarchy and recursion in the FSMs were not supported. The paper [5] demonstrates that the effective use of FPGA dedicated resources allows clock rates to be speeded up and the microchip area to be reduced significantly. The proposal in [5] was to apply application-targeted HDL constructs. Optimization techniques are presented with implementation examples and the corresponding quantitative performance evaluation. In most cases a 50% reduction in chip area was achieved with a simultaneous speed-up. Thus, we need not only a conversion technique, but also methods that enable FPGA resources (look-up tables – LUTs, flip-flops, embedded blocks) to be used efficiently. The paper [6] demonstrates that although directly constructed models based on HDL provide cycle-accurate performance estimates, these models are very slow. SLSL SystemC has been used to enhance model performance. Simulation can be done in one (high-level) language and the final synthesizable implementation is done in HDL. For such purposes, an exact transformation is required from the high-level functions to the lower-level modules and vice versa. There have been many efforts to convert from software to hardware locally i.e. to convert a selected piece of code, which is either the most time consuming or needs to be implemented in hardware for some reason, and targeting a particular area, such as communications. For example, in [7] a method called homogeneous co-simulation was proposed, where hardware and software were modeled in VHDL. This method was applied to a typical communication system. Software was converted to hardware and vice versa. The technique [8] is applied to hardware/software interfaces and it is also application-targeted. The paper [9] claims that FPGAs achieve a significant speedup over microprocessors and their configurability offers an advantage over traditional ASICs. However, FPGAs do not enjoy high-level language programmability, as microprocessors do, which is the main obstacle. The compiler that is described generates circuits from C source code to execute on FPGAs. A comparison done in [10] for two applications (video processing algorithms that analyze the motion of objects and object features within a scene, and a wireless communication receiver that includes classical communications blocks) shows that the synthesis of FPGA-based circuits can be done from high-level tools but it produces less optimized (by a factor of at least 2–3 times) hardware circuits. A number of publications are dedicated to hardware/software co-design for particular architectures. For example, in [11] a dynamic system reconfiguration for networks-on-chip (NoC) is proposed, which involves databases (that need to be extended for new applications) from which mapping of NoCs is provided. The database includes existing component implementations composed of hardware and software modules. This differs from the methods that will be considered in this paper that allow formally hardware modules to be constructed from the existing software functions. However, the constructed modules may extend the library [11], so the proposed and the existing methods complement each other. The following general conclusion can be drawn from the analysis presented above: 1. We will consider methods that permit the direct conversion of software procedures (such as C functions) to hardware. This means that we will replicate mechanisms used in software procedures, taking advantages of faster implementations in hardware (i.e. if a hierarchy/recursion is used in a software function, the corresponding hardware module will use the same hierarchy/recursion). This approach differs from all the alternatives described above and enables rapid conversion in either direction (i.e. from software to hardware and vice versa). 2. We will apply parallelism and pipelining where explicitly identified as possible, i.e. the software designer explicitly indicates functions that can be executed concurrently and specifies under which conditions. For example, in traversing N -ary trees, different branches may be indicated to be processed in parallel, or a sorting network is requested to be pipelined (many examples can be found in [12]). This approach differs from the methods described above and gives more flexibility to the designers. 3. We allow run-time changes of the hardware modules with the aid of the methods described in [13]. This approach is easily applied to the technique proposed; it is either not valid or very limited for the methods referenced above. 4. The proposed technique is especially beneficial for software/hardware co-design and experiments in devices such as the Zynq EPP (some examples will be given in Section 7). This is because the “try, test and compare” approach may be used directly. Indeed, some software functions can be parallelized and replaced with hardware modules without modifying the rest of software. The results can be compared and the conclusion can be drawn. 3 Hierarchical finite state machines The HFSM model was proposed in [14]. The model was realized in hardware and successfully tested in a number of industrial products. Further improvements were made and consequently new practical applications have been implemented, tested and evaluated. Theoretical and practical issues of HFSMs have been analyzed in [15–17] and taken as a comparison base for further application-specific improvements [18]. It is important that HFSMs can be used at different levels both in hardware and software, for example for local control in [19] and in the implementation of relatively complex embedded systems. Statecharts [20] specifications are also applicable to HFSMs, and they were adapted for object-oriented programming and used as part of a unified modeling language (UML). The main objective of this paper is to develop an approach to the synthesis of digital circuits and systems from software functions/procedures in hardware modules that are executed hierarchically (also allowing recursive invocations) and, if necessary, in parallel. Since the behavior of software functions/procedures is often described by flow charts we will use a similar specification in the form of hierarchical graph-schemes (HGSs) with the following formal description (see Fig. 1 ). An HGS is a directed connected graph containing rectangular (Fig. 1a), rhomboidal (Fig. 1b), and triangular (Fig. 1c) nodes. Each HGS has one entry point, which is a rectangular node named Begin (Fig. 1d) and one exit point, which is a rectangular node named End (Fig. 1e). Other rectangular nodes contain either micro instructions (Fig. 1f) or macro instructions (Fig. 1g) or both (Fig. 1h). We will also allow micro instructions to be assigned to the nodes Begin and End if required. Any micro instruction Yj (Fig. 1f) includes a subset of micro operations from the set Y ={y 1,…, yN }. A micro operation is an output binary signal. Any macro instruction Zk incorporates a subset of macro operations from the set Z ={z 1,…,zQ } (Fig. 1g). Each macro operation is described by another HGS of a lower level called a module. If a macro instruction includes more than one macro operation then these macro operations have to be executed in parallel (Fig. 1i). Each rhomboidal node contains one element from the set X ∪ Θ, where X ={x 1,…, xL } is the set of logic conditions, and Θ ={θ 1,…, θI } is the set of logic functions. A logic condition is an input signal, which communicates the result of a test. Each logic function is calculated by performing a predefined set of sequential steps that are described by an HGS (a module) of a lower level. Directed lines (arcs) connect the inputs and outputs of the nodes in the same manner as for an ordinary graph-scheme. Each triangular node contains an expression which can produce a set of one-hot values associated with the outputs of this node. As soon as the control flow passes a triangular node, exactly one output must be selected enabling the control flow to proceed (see examples in Fig. 1c and j). The output of a rectangular node k with more than one element zi , zj , … from the set Z is called a merging point (Fig. 1i). Control flow passes the merging point if and only if all the elements zi , zj , … have been completed. This means that a node following the node k is only activated after terminating all the macro operations zi , zj , … Using HGSs enables any complex control algorithm to be developed step by step, concentrating the efforts at each stage on a specified level of abstraction. Each separate HGS (i.e. module) can be tested independently. It is known that a set of HGSs can be implemented in an HFSM with stack memory, which permits the execution of hierarchical algorithms. We will skip the formal mathematical definition and will describe the HFSM model informally. Let x 1,…, xL /y 1,…, yN be sets of input/output signals. Structurally, an HFSM contains one or two stacks. In case of two stacks one of them (FSM_stack) keeps states and the other (M_stack) enables transitions between modules to be done. Any module is considered to be either a FSM or an HFSM. The stacks are managed by a circuit (C) that is responsible for new module invocations and state transitions in active modules that are designated by the outputs of the M_stack. Since each particular module has a unique identification code, the same HFSM states can be repeated in different modules. Any non-hierarchical (conventional) transition is performed through the change of a code only on the top register of the FSM_stack (see Fig. 2 and the mark •). Any hierarchical call activates a push operation and alters the states of the both stacks in such a way that the M_stack will store the code for the new (called) module and the FSM_stack will be set to an initial state of the called module (see Fig. 2 and the mark ■). Any hierarchical return just activates a pop operation without any change in the stacks (see Fig. 2 and the mark ♦). As a result, a transition to the state following the state where the terminated module was called will be executed. The stack pointer is common to the both stacks. In the explored here HFSM with datapath the circuit C has RTL structure (see Fig. 2) enabling operations of high-level languages to be either mapped directly or in a slightly altered manner and consequently to be executed in hardware. The model depicted in Fig. 2 possesses the following advantages: • It does not have the limitations that exist for processing cores, such as the constrained size of operands, a predefined set of instructions, limited parallelism, the impossibility of fast combinational operations. • It is entirely synthesizable. • It implements hierarchy (including potential recursion) faster than in software [21,22], i.e. a smaller number of clock cycles is required. 4 From software to hardware It is known that hierarchy and recursion are extremely powerful problem-solving techniques supported by HFSMs. This paper presents further improvements and describes enhanced models of HFSMs that allow different types of arguments to be passed to hardware modules and to be returned from the modules, much as in software programs. Let us consider some examples. The following Java code (where the method gcd is called recursively) finds the greatest common divisor of four positive integers A, B, C, and D: public static int gcd(int A, int B, int C, int D) { return gcd(gcd(A,B),gcd(C,D)); } public static int gcd(int A, int B) { if (B>A) return gcd(B,A); else if (B==0) return A; else return gcd(B,A%B); } Fig. 3 depicts HGSs for the gcd method and you can see that the HGSs look similar to the corresponding flow charts. The first HGS (Fig. 3a) sequentially executes modules Z 1 2 (A,B), Z 1 2 (C,D) and Z 1 2 (R1,R2), where R1/R2 are the results returned by the modules Z 1 2 (A,B)/ Z 1 2 (C,D). The module Z 1 2 calls the module Z 2 2 (A,B) (see Fig. 3b), which returns the remainder after division of A by B (i.e. A%B). In Section 6 we will show how modules (such as Z 1 2 (A,B) and Z 1 2 (C,D)) can be executed in parallel. A HGS is a synthesizable specification [22]. However, we need HFSM modules with arguments and returned values to be synthesized. To provide this functionality in hardware it is essential to: (a) implement recursive calls of the function gcd with different numbers of arguments (see the modules Z 1 4 and Z 1 2 that will be further explained later) and (b) return values (of type int for our particular example). The following C code (where the function treesort is called recursively) constructs and returns a sorted list from a binary tree (such as that studied in [22]): ValueAndCounter ∗treesort(treenode ∗node) {/∗ node is a pointer to the root of the tree ∗/ ValueAndCounter ∗tmp; /∗ tmp is a temporary pointer to a list item ∗/ static ValueAndCounter ∗ttmp=NULL; /∗ at the beginning the list is empty ∗/ if(node!=NULL) {/∗ if the node exists ∗/ treesort(node->lnode); /∗ Sort left sub-tree ∗/ tmp = new ValueAndCounter; /∗ allocate memory for a new list item tmp ∗/ tmp->next=ttmp; /∗ store pointer to the previous list item ∗/ tmp->val = node->val; /∗ save the value ∗/ tmp->count = node->count; /∗ save the number of repetitions of the value node->val ∗/ ttmp = tmp; /∗ extend the list ∗/ treesort(node->rnode); /∗ Now sort right sub-tree ∗/ return ttmp; } } Any tree node has the following structure: struct treenode { int val; /∗ value of an item of type int ∗/ int count; /∗ number of items with the value val ∗/ treenode ∗lnode; /∗ pointer to left sub-node ∗/ treenode ∗rnode; /∗ pointer to right sub-node ∗/}; Any list item has the following structure: struct ValueAndCounter { int val; /∗ value of an item of type int ∗/ int count; /∗ number of items with the value val ∗/ ValueAndCounter ∗next; /∗ pointer to the next item of type ValueAndCounter ∗/ }; We assume here that the tree has already been built (using, for example, the method [22]). The nodes of the tree contain four fields: a pointer to the right child node, a pointer to the left child node, a counter, and a value (an integer in our case). The nodes are maintained so that at any node, the left sub-tree contains only values that are less than the value at the node, and the right sub-tree contains only values that are greater. The counter indicates the number of occurrences of the value associated with the respective node. If we call the function with the statement beginning=treesort(root);, it returns a pointer to a list of the sorted data items. To provide similar functionality in hardware, we need to be able to: (a) pass arguments through pointers and (b) return pointers. The C function above can easily be described in the form of HGSs and similarly, the given HGSs can be almost directly coded in programming languages (Java and C for our examples). A C function call with arguments and a returned value can be represented by an HGS rectangular node but the existing methods do not allow such a function to be implemented in a regular way in HFSM modules. To overcome this problem, we suggest that a third stack memory (AR_stack) be introduced for arguments (A) together with an additional register for the returned value (R) as shown in Fig. 4 . Now the method gcd can be converted to an HFSM as follows: 1. Stacks are described in an HDL such as VHDL using templates from [22]. 2. Other blocks are described based on the HDL template from [22] and using the following additional rules: a. Arguments passed by value are stored in the AR_stack when a module (for a method/function) is being activated. b. Different numbers of arguments passed to the same function are recognized by specifying a different HDL module depending on the actual number of arguments. This can be seen as a hardware technique for replicating method/function overloading in software. c. For each argument that is a pointer, the address is stored in the AR_stack when a module (for method/function) is being activated. d. A single returned value/pointer is copied to a specially allocated register when a module is terminated and all arguments previously passed to this module are destroyed. Let us continue our examples. Note, that in the calls gcd(A,B,C,D) and gcd(gcd(A,B), gcd(C,D)) above, the hardware modules are different. They are designated Z 1 4 (for four arguments) and Z 1 2 (for two arguments) as shown in Fig. 3. When the module Z 1 4 is activated, the following statement has to be performed in VHDL (designated Z 1 4 because subscripts and superscripts are not allowed in HDLs): when stateWhereTheModuleZ1_4IsActivated => push <= ‘1’; NextModule <= Z1_4; pass_arguments <= A & B & C & D; -- preparing arguments for the AR_stack Here, the signal push is used in another (concurrent) process to increment the stack pointer that is common to all three stacks; NextModule is also used in the other process to indicate the transition to the next module ( Z 1 4 in our example); pass_arguments is a signal of type std_logic_vector that enables the arguments A, B, C, and D of a specified size to be kept. The statement above is included in the process RTL for the relevant block in Fig. 4. All three stacks are described in the following VHDL process MEMORY: MEMORY: process(clock) begin if rising_edge(clock) then -- a0 is an initial state; z0 is a top-level module if reset = ‘1’ then stack_pointer <= 0; FSM_stack(0) <= a0; -- synchronous reset M_stack(0) <= z0; stack_overflow <= ‘0’; AR_stack(0) <= (others => ‘0’); else if push = ‘1’ then -- TYPE 1 if stack_pointer = stack_size then -- handling stack overflow else stack_pointer <= stack_pointer + 1; FSM_stack(stack_pointer+1) <= a0; -- initial state is always a0 FSM_stack(stack_pointer) <= N_S; -- N_S is the next state in the calling module M_stack(stack_pointer+1) <= NextModule; -- NextModule is the next module AR_stack(stack_pointer+1) <= pass_arguments; -- passing arguments end if; elsif pop = ‘1’ then -- TYPE 2 stack_pointer <= stack_pointer – 1; -- decrementing the stack_pointer when the -- module is terminated else -- TYPE 3 FSM_stack(stack_pointer) <= N_S; -- conventional state transition to N_S end if; end if; end if; end process MEMORY; Here, clock and reset are hardware synchronization and initialization signals, pop is the signal that decrements the stack pointer (stack_pointer) during a hierarchical return (when the called module is being terminated and control has to be passed to the calling module). There are three potential transitions here: TYPE 1: hierarchical call – when the calling module activates a called module; TYPE 2: hierarchical return – when the called module is being terminated; TYPE 3: conventional state transition – common to non-hierarchical FSMs. Since there is just a single value returned, it is kept in a signal that is declared as: signal return_value: std_logic_vector(size_of_operands-1 downto 0); where size_of_operands is a generic constant. Two processes, RTL and MEMORY, are executed concurrently (i.e. in parallel). Thus, the RTL process prepares data for the MEMORY process and the latter activates the module Z 1 4 for the Java method gcd(int A, int B, int C, int D) shown above, i.e. the module Z 1 4 begins execution from the next clock cycle and receives the arguments A, B, C, D through the AR_stack. The calls of the other modules shown in Fig. 3a are exactly the same but only the first two fields of the AR_stack are used, i.e., for example: when stateWhereTheModuleZ1_2IsActivated => push <= ‘1’; NextModule <= Z1_2; pass_arguments(<index range>) <= A & B; -- preparing arguments for the AR_stack Both modules Z 1 4 and Z 1 2 have to return a value. This is done in the following statements: when stateWhereTheResultIsProduced => N_S <= indicatingTheNextState; return_value <= signalThatKeepsTheResult; when stateWhereTheCalledModuleIsTerminated => pop <= ‘1’; Here, the first when statement prepares the returned value, the second when statement activates the signal pop, and the MEMORY process decrements the stack pointer that is common to all three stacks. The complete VHDL code for the RTL process for the module Z 1 4 looks like this: case M_stack(stack_pointer) is when Z1_4 => case FSM_stack(stack_pointer) is when a0 => N_S <= a1; -- initialization (this state can be skipped if it is not needed) when a1 => push <= ‘1’; NextModule <= Z1_2; N_S <= a2; -- call of gcd(A,B) pass_arguments <= -- arguments A and B; when a2 => push <= ‘1’; NextModule <= Z1_2; N_S <= a3; -- call of gcd(C,D) pass_arguments <= -- arguments C and D; -- below the call of gcd(R1=gcd(A,B),R2=gcd(C,D)) when a3 => push <= ‘1’; NextModule <= Z1_2; N_S <= a4; pass_arguments <= -- arguments R1 and R2 where R1 is a saved return_value from -- the module Z1_2 with arguments A,B, and R2 is a saved -- return_value from the module Z1_2 with arguments C,D; when a4 => pop <= ‘1’; return_value <= -- the final result; when others => null; end case; -- description of the module Z1_2 and other potentially available modules There are three hierarchical calls here in the states a1, a2, and a3 (see Fig. 3a). A hierarchical return is executed in the state a4. Note that there is no data dependency in the calls gcd(A,B) and gcd(C,D). Thus, the corresponding modules (i.e. gcd(A,B) and gcd(C,D)) can be executed in parallel which will be shown in Section 6. Similarly, other methods/functions can be executed concurrently and the number of parallel modules is only limited by the hardware resources available. 5 Optimization technique The MEMORY process from the previous section requires excessive hardware resources when it is built as a logic block. However, it can also be constructed from embedded or distributed memories. Since the signals push, pop, clock, reset, stack_pointer are common to all the stacks, the memory can be organized as shown in Fig. 5 . The VHDL code for the stacks constructed from block RAM (see RAM_block in Fig. 5) looks like this: EMBEDDED_or_DISTRIBUTED_MEMORY: process(clock) begin -- states and modules are represented below explicitly by binary codes if rising_edge(clock) then if reset = ‘1’ then stack_pointer <= 0; stack_overflow <= ‘0’; -- see Fig. 5 a FSM_Register <= (others => ‘0’); -- see Fig. 5 c else if push = ‘1’ then -- hierarchical call if stack_pointer = 2∗∗ram_addr_bits-1 then stack_overflow <= ‘1’; else stack_pointer <= stack_pointer + 1; -- the arguments are passed through the signal to_AR FSM_Register <= to_AR & N_M & (size_of_FSM_stack_words-1 downto 0 => ‘0’); RAM_block(stack_pointer) <= to_AR & C_M & N_S; end if; elsif pop = ‘1’ then -- hierarchical return stack_pointer <= stack_pointer - 1; FSM_Register <= RAM_block(stack_pointer-1); else -- convenional transition FSM_Register(size_of_FSM_stack_words-1 downto 0) <= N_S; end if; end if; end if; end process EMBEDDED_or_DISTRIBUTED_MEMORY; RAM_block is declared as an array: constant ram_width: integer:= -- size of words for the single stack shown in Fig. 5 a,b constant ram_addr_bits: integer:= -- size of RAM addresses type DistributedRAM is array (2∗∗ram_addr_bits-1 downto 0) of std_logic_vector (ram_width-1 downto 0); signal RAM_block: DistributedRAM; -- Block RAM is declared similarly to distributed RAM Fig. 6 illustrates different types of transitions in the HFSM for hierarchical calls (Fig. 6a), conventional state transitions (Fig. 6b), and hierarchical returns (Fig. 6c). Note, that the stack is passive in a hierarchically called module (the stack is needed just for a hierarchical return from the called module). Thus, just a register (FSM_Register) can be used for passing arguments and executing state and module transitions. As soon as a transition to the next module has to be done (in the case of a hierarchical call), a binary vector (BVc = to_AR & N_M & <first state with all zeros>) with the arguments (to_AR) and the codes of the called module (N_M) with its initial state (all zeros) is copied to the register as shown in Fig. 6a. Conventional state transitions are executed similarly to an ordinary FSM using the register FSM_Register (see Fig. 6b). The arguments are taken directly from the register (FSM_Register). As soon as a hierarchical return has to be done, the binary vector (BVr) from the stack shown in Fig. 6c (containing the arguments, the code of the calling module and the code of the next state in the calling module after termination of the called module) is copied to the FSM_Register (FSM_Register <= RAM_block(stack_pointer-1);). Thus, the calling module will continue its execution. The line RAM_block(stack_pointer) <= to_AR & C_M & N_S; in the EMBEDDED_or_DISTRIBUTED_MEMORY process above sets the code of the next state N_S that is needed after the termination of the called module. As a result, after the corresponding hierarchical return, the transition to the proper HFSM state occurs (FSM_Register <= RAM_block(stack_pointer-1);). Since the next state is determined before the invocation of a module, the called module cannot change the predetermined state transition. For the majority of practical applications this does not create a problem. However, in some cases it is a problem, which must be resolved. This can be done by replacing the line above with the statement: RAM_block(stack_pointer) <= to_AR & C_M & C_S; where C_S (the current state in the calling module) has to be further replaced with such N_S in the calling module that is found taking into account potentially changed conditions in the called module(s). 6 Parallel HFSM We have already mentioned in Section 4 that some modules (such as Z 1 2 (A,B) and Z 1 2 (C,D) in Fig. 3a) can be executed in parallel (see Fig. 7 ). Let us take for further study only HGS rectangular nodes with more than one macro operation making up sub-sets Z 1, Z 2, … Thus, parallel execution of the macro operations assigned to each sub-set has to be provided. For example in Fig. 7b there are three sub-sets: Z 1 ={z 1, z 2, z 3}, Z 2 ={z 1, z 4}, and Z 3 ={z 2, z 3, z 4}. The main module Z 0 ={z 0} also needs to be implemented and up to three modules (see sets Z 1 and Z 3) need to be executed in parallel. According to the proposal in this paper, a parallel HFSM (PHFSM) can be designed by applying the following rules: 1. Macro operations from each sub-set Zi are assigned to different HFSMs running in parallel. The HFSM implementing the calling module is responsible for the parallel activation of the called modules and for verification that all called modules from the same set have been completed (i.e. execution can proceed after the relevant merging point such as that is shown in Fig. 1i). For our example in Fig. 7b, the assignment can be done as follows: HFSM1 ← z 0, z 1, z 2; HFSM2 ← z 2, z 3, z 4; HFSM3 ← z 3, z 4. For the example in Fig. 7a: HFSM1 ← Z 1 4 , Z 1 2 (A,B), Z 1 2 (R1,R2); HFSM2 ← Z 1 2 (C,D). 2. Each HFSMp is described as a VHDL component with three additional signals that are introduced in the next point. 3. If a calling (z q→) and a called (→z p) module (z q → z p) belong to the same HFSM component, then functionality is exactly the same as for a non-parallel HFSM (see Sections 4 and 5). Suppose now that z q → z p and the modules z q→, →z p belong to different components HFSMq and HFSMp. To trigger a macro operation →z p from z q→, the following three additional signals are involved: (1) startp to activate the HFSMp (HFSMq →HFSMp); (2) z p to choose the module →z p in the HFSMp; (3) finishp to indicate that the module →z p is completed. The signals startp and z p are formed (assigned) in z q→ and used (tested) in →z p. The signal finishp is assigned in →z p and tested in z q→. 4. Finally parallel execution of macro operations in the sets Z 1, Z 2, Z 3 in Fig. 7b will be provided in the following three HFSM components: Z 1 →{HFSM1(z 1),HFSM2(z 2),HFSM3(z 3)}; Z 2 →{HFSM1(z 1),HFSM2(z 4)}; Z 3 →{HFSM1(z 2),HFSM2(z 3),HFSM3(z 4)}. Parallel execution of macro operations from the set Z 1 ={ Z 1 2 (A,B), Z 1 2 (C,D)} in Fig. 7a will be provided in two HFSM components: {HFSM1( Z 1 2 (A,B)), HFSM2( Z 1 2 (C,D)). The technique described above enables any reasonable number of HFSMs mapped to VHDL components to be executed at the same time. All the HFSM features discussed in Sections 4 and 5 are entirely provided. Concurrent execution of VHDL components is combined with modularity and recursion within individual HFSMs. However, parallel calls from recursively activated modules are not allowed. The maximum number of concurrent HFSMs has to be known in advance to provide the necessary mapping to VHDL components. The graph of parallel invocations (such as Z 1 →{z 1, z 2, z 3}; Z 2 →{z 1, z 4}; Z 3 →{z 2, z 3, z 4}) has to be a tree (i.e. cycles are not allowed for parallel invocations but they are allowed for sequential invocations considered in Sections 3-5). Thus, any called module cannot call any of its predecessors with parallel calls. 7 Experiments and comparisons Four types of experiments have been carried out. Firstly, we tested selected applications in software (in C and Java). Secondly, the synthesis and implementation of the circuits from a specification in VHDL were done in the Xilinx ISE 14.4 for Spartan-6 FPGA and Zynq xc7z020 EPP (prototyping boards Atlys and ZedBoard). Thirdly, fixed+variable structure computational systems that combine the PS and the PL (see Section 2) were tested in the Zynq xc7z020 EPP. Finally, comparison was made with some applications analyzed in the previously published papers [21,22]. The following sub-sections discuss the outcomes taking into account performance of the tested circuits and their hardware resources. The results are shown for a number of practical applications and one of these applications (for processing N -ary trees) is described below in its entirety. An N -ary tree is a rooted connected graph that does not contain cycles and for which any internal node has at most N children. Fig. 8 depicts an example of an N -ary tree (N =4) that can be seen as a graph representing operations A, B, C, D, E, …, M associated with the tree nodes a, b, c, d, e, …, m and relationships between the operations are shown by tree edges. Alternatively this tree can store a set of data that are linked in accordance with given relationships. For example, the tree in Fig. 8 holds the following set of integers: 60, 12, 31, 56, 0, 9, 63, 28, 6, 1, 58, 15, 2, 62, 48, 49, 7, 29, 50, 5, 3, 30, 59, 23. Let us consider the binary codes of the integers decomposed in G-bit groups (G =2): 1 1 1 1 00, 0 0 1 1 00, 0 1 1 1 11, 1 1 1 0 00, 0 0 0 0 00, 0 0 1 0 01, 1 1 1 1 11, 0 1 1 1 00, 0 0 0 1 10, 0 0 0 0 01 1 1 1 0 10, 0 0 1 1 11, 0 0 0 0 10, 1 1 1 1 10, 1 1 0 0 00, 1 1 0 0 01, 0 0 0 1 11, 0 1 1 1 01, 1 1 0 0 10, 0 0 0 1 01, 0 0 0 0 11, 0 1 1 1 10, 1 1 1 0 11, 0 1 0 1 11. The first group on the left-hand side is shown in italic. Let us use this group to allocate three children of the root for all the codes found: 0 0, 0 1, and 1 1 leading to the children b, c and d, accordingly. Now the nodes b, c and d can be considered as roots of sub-trees for which the same rules have to be applied. Items from the last group are not expanded for new tree nodes, but are just associated with the leaves at depth 2 (these are the leaves e–m). Such a tree can be traversed by applying either an iterative or a recursive procedure. Data attached to the leaves are ordered (the leftmost leaf contains the smallest set and the rightmost leaf – the greatest set of data items). Thus, the tree can be used for data sorting, or for searching for particular items. For example, to check if the data item 28 (0 1 1 1 00) is in the set you can execute three tests: one for the tree root and others for the nodes c and j (see underlined codes in Fig. 8). N -ary trees are involved in numerous practical applications and we will use them for sorting data by applying two types of modules: (1) for traversing the tree enabling all leaves to be found and (2) for fast sort of data associated with leaves. The first module will have two alternative implementations: iterative and recursive. The second module executes sequential (non-recursive) operations enabling reusable sorting networks [12] to be involved. The experiments were carried out for 16-bit items decomposed in two parts. The first part is divided in four two-bit groups represented by an N -ary tree of depth 4 and N is also chosen to be four. Binary codes from the second part are associated with the tree leaves and, thus, any leaf can have up to 256 unique items attached. Both types of the modules were implemented and tested in software and in hardware. Note that hardware implementation can also be done using the previously published and known results. For this reason we will start in the next sub-section with the original contributions of this paper and the advantages which can be gained from these. 7.1 New contributions Suppose an N -ary tree for sorting data has been built and it is necessary to extract the sorted data from the tree. The following recursive C function does this: void traverse_tree(treenode ∗root, int depth) { depth++; if (root == NULL) { depth--; return; } if (depth == max_depth) { sort_and_print_leaf_data(root); depth--; return; } for (int i = 0; i < N; i++) traverse_tree(root->node[i],depth); /∗ recursive call ∗/ depth--; } where treenode is the following C structure (N is a constant N ): struct treenode { int ∗arrayTOsort; int count; treenode ∗node[N]; }; Similarly, an iterative function void iterative_traverse_tree(treenode ∗root, int depth) can be built for which the treenode structure has an additional field with a pointer to the parent node. The functions traverse_tree and iterative_traverse_tree can be transformed to hardware circuits using the known methods and tools described in Section 2. However neither of them enables implementations in hardware similar to software mechanisms. In our case direct conversion is done and the relevant reverse conversion is also possible. This feature is important for various types of simulation [6] and permits the interface between software and hardware to be unified and simplified. In contrast to previous publications, the stacks of the HFSMs were optimized and built from embedded memories and any module can accept arguments (such as (treenode ∗root, int depth) in C code above) and return a value. Let us look again at Fig. 8. Different branches of the tree (such as with the local roots b–d) can be traversed concurrently and, thus, the PHFSM described in Section 6 can be applied directly allowing different modules to be executed in parallel. Eventual data dependency between the modules is avoided by storing sub-trees in different memory blocks. Also, any module allows a pipeline to be created. For example, the function sort_and_print_leaf_data(root); in the C code above sorts data associated with the tree leaves. Examples of circuits that execute similar operations are given in [12]. Fig. 9 demonstrates a pipeline implemented in an HFSM module. As soon as the function traverse_tree finds the sub-set of data with the smallest values (e.g. node e in Fig. 8), all items are transferred to the input of the leftmost pipeline register in Fig. 9. At the next iteration, a subsequent sub-set (e.g. node f in Fig. 8) is transferred and the results of operations with the first sub-set are stored in the rightmost pipeline register of Fig. 9. It is known [12] that this type of pipeline allows the sorting of multiple sub-sets (in our case they are associated with different leaves) to be accelerated significantly. Thus, the methods proposed enable any module that is directly built from a software function to be further improved by applying various acceleration techniques (e.g. parallelism and pipelining) without changes in the interface with the rest of the implemented system, just adjusting timing characteristics. Any HFSM module has a unified interface that is the same as the interface of the corresponding software procedure (C function in particular). However, the implementations of modules may be different. For example, the recursive function traverse_tree(treenode ∗root, int depth) can easily be replaced by the iterative function iterative_traverse_tree(treenode ∗root, int depth). Such a technique is indispensable for experiments and comparisons. 7.2 Software/hardware co-design Combining the capabilities of software and hardware permits many characteristics of applications to be improved. Nowadays this technique can be implemented on a chip such as the Zynq EPP and we used this for experiments (xc7z020 microchip available on the ZedBoard) as follows: the PS executes software programs that have been developed in C language. The PL exchanges data with the PS using AXI-based high-bandwidth connectivity and executes problem-specific algorithms. Fig. 10 gives more details of the interaction which is organized with the aid of Xillybus Lite IP core [23]. The user software applications run in the ARM Cortex-A9 under Linux. HFSM modules are designed in Xilinx ISE 14.4 and they may interact with the Xillybus IP core as shown in Fig. 10. The latter provides data exchange with the PS through the AXI. Let us consider a particular practical application. Suppose we want to find a minimal row cover of a given binary matrix, i.e. the minimum number of rows such that in conjunction they have at least one value ‘1’ in each column. The approximate algorithm [24] that allows this problem to be solved requires the following sequence of steps: (1) discovering a matrix column Cmin, with the minimal Hamming weight N min 1 (if N min 1 = 0 then the covering does not exist); (2) discovering a row Rmax, with the value ‘1’ in the column Cmin, with the maximum Hamming weight N max 1 ; (3) including the row Rmax in the solution and removing this row and all the columns, which have values ‘1’ in the Rmax; and (4) repeating the steps 1–3 until the matrix is empty. The following application has been designed, implemented and tested: (1) the PS receives the given matrix from the host PC; (2) the matrix is transmitted to the PL and all horizontal and vertical masks (which mark the deleted rows and columns) are reset to zero; (3) the PL searches for the column Cmin with the minimal Hamming weight N min 1 and sends the values N min 1 and Cmin to the PS; (4) if N min 1 = 0 , the PS informs the host PC that there is no solution, otherwise it indicates for which rows the value N max 1 has to be found in the PL; (5) the PL finds Rmax and sends it to the PS; (6) the PS updates masks in the PL. The masks are used to indicate the rows and columns that have been removed and, thus, the same masked (reduced) matrix is taken for subsequent processing. The steps above are repeated until either the covering is found or it is concluded that the solution does not exist. 7.3 Performance and resources evaluation Experiments with N -ary trees built from arbitrary generated data sets have demonstrated that the result is found faster than in software. If we compare recursive and iterative modules, then the former have a little bit better performance. This can be explained as follows. Traversing N -ary trees is directly supported by recursive calls/returns whereas in an iterative module backtracking (traveling back from children to parents) needs to be done through additional operations over pointers (from children to parents) in the treenode structure. This is inherent to tree-based graphs for which recursive procedures are often more preferable. When we replace cycles by recursive function invocations (see examples with the greatest common divisor in Section 4), performance for the two types of implementations indicated above is almost the same. Thus, the recursive technique can be justified just by a clearer and more understandable specification. It should be noted that the paper promotes hierarchy and modularity in circuit design, and recursion is not a primary objective. The main target is hierarchy, and as a consequence, the unification and reusability of modules. The latter are not necessarily recursive but provide support for recursion. If parallel processing of N -ary trees branches (sub-trees) is applied, then acceleration is increased. Maximum acceleration is obtained for sub-trees having almost equal numbers of nodes. The speedup is achieved because: (1) software functions were accelerated in HFSM modules; (2) HFSM modules can run in parallel; (3) HFSM modules can incorporate a pipeline; and (4) HFSM modules can improve known sorting networks allowing for reuse of network segments and, thus, combinational operations are optimized through their rational combination with sequential operations. We mentioned at the beginning of this section that comparison was also done with some applications that were analyzed in previously published papers [21,22]. Experiments have been carried out for the following problems: P 1 – sorting based on a binary tree; P 2 – approximate method for discovering a minimal row cover of a binary matrix. In [21] synthesis from a specification in Handel-C was done in the DK3 design suite for xc2v1000–4fg456 FPGA (Virtex-II family of Xilinx) that is available on the RC200 prototyping board. Thus, comparison with synthesis from an SLSL can also be performed. All VHDL projects from [21,22] were re-synthesized in ISE 14.4 of Xilinx. The results are shown in Table 1 in form N s/ET, where N s is the number of FPGA slices and ET is the execution time in nanoseconds for the problem P1 and in microseconds for the problem P2. All VHDL projects were implemented in a Spartan-6 FPGA for the Atlys prototyping board. Initial data were taken in exactly the same way as in [21]. Handel-C projects gave the worst results and this confirms the conclusions that were arrived at in Section 2. The best execution time is underlined in Table 1 and the best performance is achieved with the methods proposed in this paper. It is known that FPGAs give the best results for highly parallel implementations. Sorting networks can be seen as good examples. The main problem is very excessive FPGA resources. For example, the results of [25] show that even in the relatively advanced and expensive FPGA XC5VFX130T from the Xilinx Virtex-5 family, the maximum number of sorted data items (of size M =32bits) is 64. To overcome this problem we combined combinational and sequential operations [12] making it possible the number of data items to be increased. We synthesized three circuits implementing the fastest known combinational even–odd merge and bitonic merge sorting networks and compared the results with circuits that sequentially reuse even–odd transition segments implemented in a dedicated HFSM module. Tests were done in the Atlys prototyping board for eight 32-bit data items. Table 2 presents the results. At first glance it looks strange that the sequential circuit gives the best results but it is true because propagation delays in FPGA have been significantly reduced. Thus, sequential circuits might be better than pure parallel combinational circuits. Let us look now at an HFSM module that implements the pipeline depicted in Fig. 9 and compare the results with the best known sorting networks (see Fig. 11 where L is the number of pipeline registers). The even–odd merge network (which is one of the least resource consuming of the known pure combinational sorting networks) can be implemented in the chosen FPGA only for up to 32 items (M =32) and for a bigger number of items, the resources of the FPGA are not sufficient. On the other hand, we were able to implement circuits for up to 256 items, i.e. eight times larger (see Fig. 11). Table 3 gives comparison results for Xilinx projects calculating the greatest common divisor of κ unsigned 32-bit integers. Here, Fmax is the maximum attainable clock frequency in MHz. The best previous result achieved by the authors is shown in the first line of the table. The recursive algorithm described in Section 4 was used. Clearly, the previous results are improved upon. We believe that in future work it might be possible to automate the process of generating the compiled code/hardware module combination by adding a pre-processor to a C compiler. Then the original programmer would only need to know how to flag functions that potentially could be in hardware and/or executed in parallel. The programmer could then use the PS/PL facility without needing to understand in detail how the hardware modules were created. We do hope that such feature can be very important for methods described in [11]. 8 Conclusion The paper presents new methods that enable software modules to be converted to hardware implementations. The proposed technique is based on the known model of a hierarchical finite state machine and it permits more complicated cases of hierarchy and parallelism to be realized in electronic circuits, namely: HFSM modules can accept and return data much as in software; different modules can be executed concurrently; better optimization methods can be applied. The results of numerous experiments with applications from different areas have clearly demonstrated the advantages of the proposed technique (namely, an increase in performance and a decrease in hardware resources) and its broad applicability to both autonomous devices and hardware accelerators for software products. Acknowledgments The authors would like to thank Ivor Horton for his very useful comments and suggestions and Artjom Rjabov for making some experiments in EPP. This research was supported by FEDER through the Operational Program Competitiveness Factors – COMPETE and National Funds through FCT – Foundation for Science and Technology in the context of the Projects FCOMP-01-0124-FEDER-022682 (FCT reference PEst-C/EEI/UI0127/2011) and Incentivo/EEI/UI0127/2013. References [1] M. Santarini Zynq-7000 EPP sets stage for new era of innovations Xcell J 75 2011 [second quarter] [2] Skliarova I, Sklyarov V. Recursion in reconfigurable computing: a survey of implementation approaches. In: Proceedings of the 19th international conference on field-programmable logic and applications – FPL’2009, 2009. p. 224–9. [3] Estrin G. Organization of computer systems – the fixed plus variable structure computer. In: Proceedings of western joint IRE-AIEE-ACM computer conference, 1960. p. 33–40. [4] Villarreal JR, Park A, Najjar WA, Halstead R. Designing modular hardware accelerators in C with ROCCC 2.0. In: Proceedings of the 18th annual international IEEE symposium on field-programmable custom computing machines – FCCM 2010, 2010. p. 127–34. [5] K. Latif A. Aziz A. Mahboob Optimal utilization of available reconfigurable hardware resources Comput Electr Eng 37 6 2011 1043 1057 [6] S.M. Aziz A cycle-accurate transaction level SystemC model for a serial communication bus Comput Electr Eng 35 5 2009 790 802 [7] M. Sabaei M. Dehghan K. Faez M. Ahmadi A VHDL-based HW/SW cosimulation of communication systems Comput Electr Eng 27 2001 333 343 [8] King M, Dave N, Arvind. Automatic generation of hardware/software interfaces. In: Proceedings of XVII international conference on architectural support for programming languages and operating systems, 2012. p. 325–36. [9] Z. Guo W. Najjar B. Buyukkurt Efficient hardware code generation for FPGAs ACM Trans Architec Code Optim 5 1 2008 [10] Berkeley Design Techn., Inc., An independent evaluation of high-level synthesis tools for Xilinx FPGAs, 2010. [11] T. Hollstein M. Glesner Advanced hardware/software co-design on reconfigurable network-on-chip based hyper-platforms Comput Electr Eng 33 4 2007 S.310 S.319 [12] V. Sklyarov I. Skliarova Parallel processing in FPGA-based digital circuits and systems 2013 TUT Press [13] V. Sklyarov Reconfigurable models of finite state machines and their implementation in FPGAs J Syst Architec 47 2002 1043 1064 [14] Sklyarov V. Finite state machines with stack memory and their automatic design. In: Proceedings of USSR conference on computer-aided design of computers and systems, Part 2; 1983. p. 66–7 [in Russian]. [15] Neishaburi MH, Zilic Z. Hierarchical Trigger generation for post-silicon debugging. In: Proceedings of the international symposium on VLSI design, automation and, test – VLSI-DAT’2011, 2011. p. 1–4. [16] Hu W, Zhang Q, Mao Y. Component-based hierarchical state machine – a reusable and flexible game AI technology. In: Proceedings of the 6th IEEE joint international conference on information technology and artificial intelligence – ITAIC, 2011. p. 319–24. [17] D. Mihhailov V. Sklyarov I. Skliarova A. Sudnitson Acceleration of recursive data sorting over tree-based structures Electron Electr Eng 7 113 2011 51 56 [18] Ninos S, Dollas A. Modeling recursion data structures for FPGA-based implementation. In: Proceedings of the 18th international conference on field-programmable logic and applications – FPL’2008, 2008. p. 11–6. [19] D.M. Muñoz C.H. Llanos M. Ayala-Rincón R.H. van Els Distributed approach to group control of elevator systems using fuzzy logic and FPGA implementation of dispatching algorithms Eng Appl Artif Intell 21 2008 1309 1320 [20] D. Harel Statecharts: a visual formalism for complex systems Sci Comput Programm 8 1987 231 274 [21] Sklyarov V, Skliarova I, Pimentel B. FPGA-based implementation and comparison of recursive and iterative algorithms. In: Proceedings of the international conference on field-programmable logic and applications – FPL’05, 2005. p. 235–40. [22] V. Sklyarov FPGA-based implementation of recursive algorithms Microprocess Microsyst 28 5–6 2004 197 211 [Special Issue on FPGAs: Applications and Designs] [23] Xillybus, Xillybus Lite for Zynq-7000: easy FPGA registers with Linux. [24] A. Zakrevskij Yu. Pottoson L. Cheremisiniva Combinatorial algorithms of discrete mathematics 2008 TUT Press Tallinn [25] R. Mueller J. Teubner G. Alonso Sorting networks on FPGAs Int J Very Large Data Bases 21 1 2012 1 23 Valery Sklyarov received the Ph.D. degree in computer science in 1978, the Doctor of Science degree in computer science in 1986, and the aggregation (agregação) in electrical engineering in 2001. He is currently a professor in the Department of Electronics, Telecommunications and Informatics, University of Aveiro, Portugal. He has authored and co-authored 19 books and over 300 papers. Iouliia Skliarova received the M.Sc. degree in computer engineering in 1998, and the Ph.D. degree in electrical engineering in 2004. She is currently an assistant professor in the Department of Electronics, Telecommunications and Informatics, University of Aveiro, Portugal. She has authored and co-authored two books and over 100 papers on subjects which include reconfigurable systems, digital design, and combinatorial optimization. "
    },
    {
        "doc_title": "Processing N-ary trees in reconfigurable hardware",
        "doc_scopus_id": "84896772624",
        "doc_doi": "10.1109/ICM.2013.6734988",
        "doc_eid": "2-s2.0-84896772624",
        "doc_date": "2013-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Application problems",
            "Block rams",
            "Clear specifications",
            "Coding",
            "Hardware resources",
            "N-ary trees",
            "Recursive techniques"
        ],
        "doc_abstract": "The paper discusses effectiveness of N-ary trees for solving different application problems with case studies on search and sort. A new method for representation of trees in memory, which takes advantages of widely available in commercial Field-Programmable Gate Array (FPGA) built-in block RAM, is proposed. It is shown that N-ary trees can be coded in such a way that enables the required size of memory to be significantly reduced with practically the same performance as in the previously developed methods. Thus, larger trees can be stored and further handled in FPGAs with equal hardware resources. It is also shown that the trees can be processed using both iterative and recursive techniques. The latter is discussed in detail due to opportunities for more compact and clear specifications, and comparison is done with the previous results permitting very good performance to be achieved. © 2013 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Performance evaluation for FPGA-based processing of tree-like structures",
        "doc_scopus_id": "84874587606",
        "doc_doi": "10.1109/ICECS.2012.6463762",
        "doc_eid": "2-s2.0-84874587606",
        "doc_date": "2012-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Computational core",
            "Data representations",
            "Data sorting",
            "FPGA circuits",
            "Hierarchical finite state machines",
            "Memory requirements",
            "N-ary trees",
            "Performance evaluation",
            "Sorting algorithm",
            "Tree-based",
            "Tree-like structures"
        ],
        "doc_abstract": "The paper evaluates tree-based implementations of data sorting algorithms in FPGA circuits using hierarchical finite state machine (HFSM) as a computational core. We focus here on experiments which show effectiveness of sorting algorithms over data structures represented in form of N-ary trees (N≥2). The presented results compare different types of data representation and processing in terms of performance and memory requirements. It is shown that using advanced FPGAs and the proposed address-based methods the number of sorted items with size 32-64 bits can reach 232. © 2012 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hierarchy and recursion in software and hardware",
        "doc_scopus_id": "84874125970",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84874125970",
        "doc_date": "2012-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Application area",
            "Direct use",
            "Electronic systems",
            "General-purpose languages",
            "Hardware accelerators",
            "Hardware circuits",
            "Hardware implementations",
            "Hardware modules",
            "hierarchy",
            "Micro-electronic devices",
            "Processing core",
            "Programming technique",
            "Recent researches",
            "Recursions",
            "Software and hardwares"
        ],
        "doc_abstract": "Advances in microelectronic devices have dissolved the boundary between software and hardware. Since hardware circuits are generally faster and enable significantly broader parallelism to be provided, a number of recent research works are dedicated to high-performance computations in electronic systems without direct use of processing cores which introduce a number of constraints (e.g. pre-defined size of operands, pre-given sets of instructions, limits for concurrency and parallelism, etc.). This paper suggests a regular way enabling methods and functions from general-purpose languages to be converted to hardware implementations. Consequently, such conventional programming techniques as hierarchy, recursion, passing arguments, and returning values were entirely implemented in hardware modules. The resulting circuits are faster than their software alternatives and this is confirmed by examples and numerous experiments from different application areas. © 2012 AICIT.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Solving Sudoku in reconfigurable hardware",
        "doc_scopus_id": "84873960540",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84873960540",
        "doc_date": "2012-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Backtracking search algorithms",
            "Breadth first search algorithms",
            "Breadth-first search",
            "Computationally intensive problems",
            "Parallel processing",
            "Search trees",
            "Sudoku"
        ],
        "doc_abstract": "In this paper we explore the effectiveness of solution of computationally intensive problems in FPGA (Field-Programmable Gate Array) on an example of Sudoku game. Three different Sudoku solvers have been fully implemented and tested on a low-cost FPGA of Xilinx Spartan-3E family. The first solver is only able to deal with simple puzzles with reasoning, i.e. without search. The second solver applies breadth-first search algorithm and therefore has virtually no limitation on the type of puzzles which are solvable. We prove that despite the serial nature of implemented backtracking search algorithms, parallelism can be used efficiently. Thus, the suggested third solver explores the possibility of parallel processing of search tree branches and boosts the performance of the second solver. The trade-offs of the designed solvers are analyzed, the results are compared to software and to other known implementations, and conclusions are drawn on how to improve the suggested architectures. © 2012 AICIT.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Data processing in FPGA-based systems",
        "doc_scopus_id": "84872863078",
        "doc_doi": "10.1109/ICAICT.2012.6398506",
        "doc_eid": "2-s2.0-84872863078",
        "doc_date": "2012-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            }
        ],
        "doc_keywords": [
            "Block rams",
            "Configurable Logic Blocks",
            "Data processing algorithms",
            "Design flows",
            "Embedded components",
            "High-performance computing",
            "Internet-based applications",
            "parallelism",
            "Parallelizations"
        ],
        "doc_abstract": "More than 50% of FPGA market is in the scope of communication and information. Data processing is a very broad area that is important for numerous computations, networking, embedded systems, Internet-based applications, etc. Many problems in this area are computationally intensive and thus, they require parallelization and acceleration based on new technologies. FPGAs can be seen as a very attractive platform permitting application-specific software and problem-targeted hardware to be combined on a single configurable microchip. The tutorial is dedicated to hardware-oriented data processing algorithms with emphasis on parallelism and pipelining. FPGA-targeted design flow is based on the rational use of configurable logic blocks/logic elements and embedded components (DSP slices and block RAMs). Particular examples, potential practical applications, experiments and comparisons will be demonstrated. © 2012 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Methodology and international collaboration in teaching reconfigurable systems",
        "doc_scopus_id": "84864144148",
        "doc_doi": "10.1109/EDUCON.2012.6201190",
        "doc_eid": "2-s2.0-84864144148",
        "doc_date": "2012-07-27",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            },
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            },
            {
                "area_name": "Education",
                "area_abbreviation": "SOCI",
                "area_code": "3304"
            }
        ],
        "doc_keywords": [
            "E-learning tool",
            "Host computers",
            "International collaborations",
            "Reconfigurable computing",
            "Reconfigurable systems",
            "Virtualizations"
        ],
        "doc_abstract": "The paper describes the proposed methodology for teaching reconfigurable (Field-Programmable Gate Array based) systems and international collaboration in education. The methodology includes e-learning tools (namely, tutorials, templates, and previously developed students' projects) combined with another methods that are: separation of given to students tasks on core and auxiliary components, and design based on interactions, virtualization, and communication with host computers. Future directions are also discussed. Numerous examples are presented, including particular cases of teaching outside of home universities. Evaluation of the proposed methodology in a period of three years was also done and the results are presented. © 2012 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Implementation of sorting algorithms in reconfigurable hardware",
        "doc_scopus_id": "84861511468",
        "doc_doi": "10.1109/MELCON.2012.6196391",
        "doc_eid": "2-s2.0-84861511468",
        "doc_date": "2012-05-31",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Coding techniques",
            "Data items",
            "Data sorting",
            "External memory",
            "Hardware implementations",
            "Hierarchical finite state machines",
            "Low-cost devices",
            "Memory requirements",
            "N-ary tree",
            "Sorting algorithm",
            "Sorting method",
            "Spartan-3",
            "Tree search"
        ],
        "doc_abstract": "The paper discusses data sorting algorithms which create and traverse tree-like data structures and permit fast resorting. Optimization is achieved through rational grouping of previously developed methods allowing address-based representation and compact coding of data items. The results of hardware implementation of the algorithms and prototyping in FPGA (Field-Programmable Gate Arrays) demonstrate that: 1) sorting algorithms can be implemented efficiently in low-cost FPGA; 2) the developed coding technique permits data items to be compactly represented in memory; 3) combining different sorting methods produces the best results in terms of performance and memory requirements; 4) low-cost devices can only be used to tackle limited sets of data (up to 2 20 in a Spartan-3 1200 FPGA) and for processing more data either a more powerful FPGA or an external memory is required. © 2012 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Processing N-ary trees in hardware circuits",
        "doc_scopus_id": "84856731243",
        "doc_doi": "10.1109/ISICir.2011.6131946",
        "doc_eid": "2-s2.0-84856731243",
        "doc_date": "2011-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Fixed numbers",
            "Hardware circuits",
            "Hierarchical finite state machines",
            "N-ary tree",
            "Parallel processing",
            "Practical problems",
            "Process data",
            "Processing steps",
            "Tree search"
        ],
        "doc_abstract": "The paper demonstrates that N-ary trees (N>2) can efficiently be used to model and process data in hardware. It is done through: 1) representation of data by N-ary trees; 2) compact coding of N-ary trees in memory; 3) common methods for data processing based on the model of a hierarchical finite state machine (HFSM). The proposed techniques have the following advantages: 1) similarity of processing N-ary trees with different characteristics such as the size of data M, the value N, and the depth d of trees; 2) fixed number of processing steps from the root to leaves for the given depth d; 3) the ease of reconfiguration (customization) of HFSM for different values of N, d, and M; 4) potential parallel processing of nodes' children. The results of experiments confirm effectiveness of the proposed techniques and their applicability for solving practical problems. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Simulation environment for visual prototyping of circuits and systems",
        "doc_scopus_id": "84856710866",
        "doc_doi": "10.1109/ISICir.2011.6131947",
        "doc_eid": "2-s2.0-84856710866",
        "doc_date": "2011-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Hardware system",
            "Multimedia environment",
            "Simulation environment",
            "Structural models",
            "Visual prototyping"
        ],
        "doc_abstract": "The paper presents results in the following two areas: the visual graphical verification of hardware systems and the synthesis of digital circuits from modular, hierarchical, recursive, and parallel specifications. Within these areas a simulation multimedia environment has been developed and used for verification of the proposed methods that are based on new structural models. The applicability of the environment and the methods is demonstrated through examples. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based systems in information and communication",
        "doc_scopus_id": "84855955504",
        "doc_doi": "10.1109/ICAICT.2011.6110989",
        "doc_eid": "2-s2.0-84855955504",
        "doc_date": "2011-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Communication",
                "area_abbreviation": "SOCI",
                "area_code": "3315"
            }
        ],
        "doc_keywords": [
            "Design ideas",
            "Design space exploration",
            "Design steps",
            "Design templates",
            "Economic aspects",
            "Electrical and computer engineering",
            "Engineering training",
            "Hewlett-packard",
            "Industrial requirements",
            "Information and communication",
            "Interactive learning",
            "Mobile Technology",
            "Portugal",
            "Potential benefits",
            "Reconfigurable systems",
            "Technical characteristics"
        ],
        "doc_abstract": "This tutorial is intended to give introduction to FPGA-based systems, to illustrate advantages of these systems in terms of technical characteristics and economic aspects, to demonstrate design steps on practical examples, and to discuss potential benefits and case studies targeted to the scope of the conference. It will be also shown that teaching FPGA-based systems is very important in engineering education and in University of Aveiro (Portugal) it has been supported from 2009 by the Hewlett Packard grant entitled «Use of HP Mobile Technology to Enhance Teaching Reconfigurable Systems for Electrical and Computer Engineering Curricula». The tutorial can also be seen as a dissemination of the results demonstrating how the HP mobile technology has been used to create a stimulating environment to encourage collaborative and interactive learning, to provide better interaction between the students and teachers, to extend opportunities for design space exploration in the scope of reconfigurable systems, to work more efficiently with tutorials, design templates and libraries, to provide for fast exchange of design ideas between the students and the students and teachers, and to ultimately reduce the gap between the industrial requirements and capabilities of engineering training. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Implementation in FPGA of address-based data sorting",
        "doc_scopus_id": "80455168388",
        "doc_doi": "10.1109/FPL.2011.81",
        "doc_eid": "2-s2.0-80455168388",
        "doc_date": "2011-11-09",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "Data items",
            "Data sort",
            "Data sorting",
            "Hardware implementations",
            "HFSM",
            "Low costs",
            "Memory address",
            "N-ary tree",
            "Sorting algorithm",
            "Working nodes"
        ],
        "doc_abstract": "The paper describes the hardware implementation and optimization of sorting algorithms that use data items as memory addresses with one-bit flags indicating presence of data. The proposed technique enables such type of address-based sorting to be applied either directly or through tree-walk tables permitting number of bits in sorted data items to be increased by constructing and traversing N-ary trees (N>2) composed of so called no-match and working nodes. The latter are organized in well balanced sub-trees of equal depth. It is allowed more than one data item to be assigned to leaves of working sub-trees and such sets of items are processed by fast acceleration circuits. Experiments and comparisons demonstrate that the proposed technique can be used efficiently in low cost FPGAs. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware implementation of recursive sorting algorithms",
        "doc_scopus_id": "80055069188",
        "doc_doi": "10.1109/ICEDSA.2011.5959040",
        "doc_eid": "2-s2.0-80055069188",
        "doc_date": "2011-11-03",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Data sorting",
            "Distinctive features",
            "Hardware implementations",
            "Hierarchical finite state machines",
            "Parallel processing",
            "Recursive algorithms",
            "Sorting algorithm",
            "Sorting network"
        ],
        "doc_abstract": "The paper describes methods of data sorting in hardware using parallel recursive algorithms over a binary tree. The implementation is based on communicating hierarchical finite state machines interacting with dedicated memories. Distinctive features of the proposed methods are balancing the tree to increase the performance of hardware implementation and the use of sorting networks combined with operations over the tree. Parallel processing is achieved through constructing and traversing different branches of the tree at the same time. The results of prototyping in FPGA and experiments demonstrate applicability and effectiveness of the proposed technique. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Recursion and hierarchy in digital design and prototyping: A case study",
        "doc_scopus_id": "80052793643",
        "doc_doi": "10.1145/2023607.2023616",
        "doc_eid": "2-s2.0-80052793643",
        "doc_date": "2011-09-20",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Human-Computer Interaction",
                "area_abbreviation": "COMP",
                "area_code": "1709"
            },
            {
                "area_name": "Computer Vision and Pattern Recognition",
                "area_abbreviation": "COMP",
                "area_code": "1707"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Design process",
            "Digital designs",
            "Digital system",
            "Hardware resources",
            "Hierarchical finite state machines",
            "Implementation methods",
            "Integration levels",
            "Project scale",
            "Recursions"
        ],
        "doc_abstract": "With the constant growth of integration level, today's circuits contain way over millions of gates. This puts forward a fundamental question - how to efficiently use enormous and continuously rising hardware resources in the design process? This paper describes a reuse technique that can be applied to the design of FPGA-based application-specific digital systems. Reusability is achieved at the level of specifications. The proposed specification and implementation method is based on the model of hierarchical finite state machine (HFSM). This allows to describe fragments (modules) in such a way that the developed algorithm can be composed of either new or previously designed modules providing reuse on project scale. © 2011 ACM.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Processing tree-like data structures for sorting and managing priorities",
        "doc_scopus_id": "80052128331",
        "doc_doi": "10.1109/ISCI.2011.5958935",
        "doc_eid": "2-s2.0-80052128331",
        "doc_date": "2011-09-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            }
        ],
        "doc_keywords": [
            "Data items",
            "Hardware implementations",
            "Sorting network",
            "Tree-like structures"
        ],
        "doc_abstract": "The paper describes the hardware implementation and optimization of algorithms that sort data using tree-like structures combined with sorting networks. The emphasis is done on applications that require dynamic resorting for new incoming data items. Experiments and comparisons demonstrate that the performance is increased compared to other known implementations. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "High-performance hardware accelerators for sorting and managing priorities",
        "doc_scopus_id": "79959962770",
        "doc_doi": "10.1109/DDECS.2011.5783103",
        "doc_eid": "2-s2.0-79959962770",
        "doc_date": "2011-07-11",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            }
        ],
        "doc_keywords": [
            "fast resorting",
            "hierarchical FSMs",
            "managing priorities",
            "Parallelizations",
            "sorting networks",
            "tree-like data structures"
        ],
        "doc_abstract": "The paper describes the hardware implementation and optimization of algorithms that process tree-like data structures which are needed for numerous practical applications in such areas as databases, embedded systems, and networks requiring priority management. The emphasis is done on applications that involve fast processing of new incoming data items, such as resorting. Parallelism is achieved by constructing N binary trees (N1) and applying concurrent operations to N trees at the same time with the aid of N communicating processing modules. It is shown that the considered technique can efficiently be combined with sorting networks, which gives new potentialities for optimization. Modeling in software, experiments with FPGA-based circuits on different computing platforms, and comparisons with the other known methods demonstrate that the performance is increased significantly. It is also shown that the proposed algorithms are easily scalable. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Multilevel models for data processing",
        "doc_scopus_id": "79957973967",
        "doc_doi": "10.1109/IEEEGCC.2011.5752494",
        "doc_eid": "2-s2.0-79957973967",
        "doc_date": "2011-06-09",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Signal Processing",
                "area_abbreviation": "COMP",
                "area_code": "1711"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Data models",
            "Data sorting",
            "Hierarchical finite state machines",
            "Multilevel model",
            "Sorting network",
            "Three different techniques",
            "Tree-like structures",
            "Trees"
        ],
        "doc_abstract": "The paper suggests multilevel models for data processing and demonstrates advantages of such models on examples of data sorting. Three different techniques are discussed, namely graph walk, using tree-like structures and sorting networks. The relevant implementations were done on the basis of hierarchical finite state machines and verified in commercially available FPGAs. Experiments and comparisons demonstrate that the results enable the performance of processing for different types of data to be increased compared to known implementations. © 2011 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Acceleration of recursive data sorting over tree-based structures",
        "doc_scopus_id": "80053029141",
        "doc_doi": "10.5755/j01.eee.113.7.612",
        "doc_eid": "2-s2.0-80053029141",
        "doc_date": "2011-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The main objective of this paper is to evaluate and improve FPGA-based digital circuits, which implement recursive specifications. Recursive sorting algorithms over binary trees are considered as a case study to evaluate and demonstrate new techniques and their advantages. Since recursive calls are not directly supported by hardware description languages, they are implemented using the model of a hierarchical finite state machine (HFSM). The paper presents analysis and comparison of alternative and competitive techniques for describing recursive algorithms in hardware. The experimental results demonstrate that the proposed innovations allow to achieve better performance. Obviously, the results of this paper are not limited to recursive sorting alone. They have a wider scope and can be applied effectively to numerous systems that implement recursive algorithms over tree-based data structures.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "MIAUDIO - Audio mixture digital matrix",
        "doc_scopus_id": "84866029140",
        "doc_doi": null,
        "doc_eid": "2-s2.0-84866029140",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Modeling and Simulation",
                "area_abbreviation": "MATH",
                "area_code": "2611"
            },
            {
                "area_name": "Acoustics and Ultrasonics",
                "area_abbreviation": "PHYS",
                "area_code": "3102"
            }
        ],
        "doc_keywords": [
            "Audio channels",
            "Audio input",
            "Audio signal",
            "Digital format",
            "Electroacoustic music",
            "Hardware solutions",
            "Host computers",
            "Low-cost solution",
            "Multichannel sounds",
            "Output channels",
            "Sound diffusion"
        ],
        "doc_abstract": "Electroacoustic music is turning more and more to the sound diffusion techniques. Multichannel sound systems like BEAST and SARC are built so that the musician can independently control the intensity of several audio channels. This feature provides the possibility of creating several sound diffusion scenarios, i.e., immersion and the possibility of movement around the audience. The developed system (MIAUDIO) is a real-time sound diffusion system currently able to mix up to 8 audio input channels through 32 outputs channels. A hardware solution was adopted using a Field Programmable Gate Array (FPGA) to perform the mixture. The analogue audio signals are conditioned, converted to digital format by several analogue-to-digital converters and then sent to the FPGA that is responsible to perform the mixing algorithm. The host computer connects to the FPGA via USB and is responsible for supplying the parameters that define the audio mixture. Being so, the user has control over the input levels through the output channels independently. MIAUDIO was successfully implemented with a low-cost solution when compared with similar systems. All the channels were tested using a Precision One system with very good results.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfiguration technique for adaptive embedded systems",
        "doc_scopus_id": "79952748656",
        "doc_doi": "10.1109/ICIAS.2010.5716111",
        "doc_eid": "2-s2.0-79952748656",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Artificial Intelligence",
                "area_abbreviation": "COMP",
                "area_code": "1702"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            }
        ],
        "doc_keywords": [
            "CAD system",
            "Control algorithms",
            "Hierarchical finite state machines",
            "Modifiability",
            "Recursions",
            "Synthesis methodology"
        ],
        "doc_abstract": "This paper is dedicated to the design and implementation of adaptive embedded systems. Different synthesis methodologies are presented and discussed. Applying such methodologies the synthesis of circuits with support for modifiability and extensibility can be done. The paper describes: 1) specification of control algorithms for adaptive embedded systems and formal conversion of the specification to synthesizable VHDL code; 2) a model that is called a hierarchical finite state machine, which provides support for modularity, hierarchy, and recursion; 3) VHDL templates enabling the circuit to be synthesized in commercial CAD systems; and 4) the results of experiments.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Optimization of FPGA-based circuits for recursive data sorting",
        "doc_scopus_id": "79952141353",
        "doc_doi": "10.1109/BEC.2010.5629731",
        "doc_eid": "2-s2.0-79952141353",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Data sorting",
            "Hardware circuits",
            "Hierarchical finite state machines",
            "Optimization method",
            "Parallel method",
            "Recursions",
            "State machine"
        ],
        "doc_abstract": "The paper describes sequential and parallel methods of recursive data sorting that are applied to binary trees. Hardware circuits implementing these methods are based on the model of a hierarchical finite state machine, which provides support for recursion in hardware. It is shown that the considered technique allows the known optimization methods for conventional state machines to be applied directly. The described circuits have been implemented in commercial FPGAs and tested in numerous examples. Analysis and comparison of alternative and competitive techniques is also done in the paper. ©2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis and implementation of hierarchical finite state machines with implicit modules",
        "doc_scopus_id": "79951767051",
        "doc_doi": "10.1109/ReConFig.2010.29",
        "doc_eid": "2-s2.0-79951767051",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [
            "Circuit synthesis",
            "Finite state machines",
            "Hierarchical finite state machines",
            "Hierarchical graph-schemes",
            "Optimization method",
            "Reconfiguration technique",
            "Recursions",
            "Stack memory"
        ],
        "doc_abstract": "The paper describes a hierarchical finite state machine (HFSM) with implicit modules, which inherits capabilities of existing models (in particular, provides support for modularity, hierarchy, and recursion); requires a very simple stack memory; and permits optimization methods developed for conventional FSMs to be reused. The HFSM has been tested in several practical applications briefly characterized in the paper. It is shown that the same hardware can implement different algorithms through the proposed reconfiguration technique. The results of experiments, reported in the paper, clearly demonstrate advantages of the proposed model. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable digital audio mixer for electroacoustic music",
        "doc_scopus_id": "79951761248",
        "doc_doi": "10.1109/ReConFig.2010.28",
        "doc_eid": "2-s2.0-79951761248",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [
            "Audio mixture",
            "Complete system",
            "Core part",
            "Digital audio",
            "Electroacoustic music",
            "Electronic music",
            "FPGA-based prototyping",
            "Host computers",
            "Input channels",
            "Low costs",
            "Mixture algorithm",
            "Multichannel sound diffusion system",
            "Multichannel sounds",
            "Output channels",
            "Re-configurable",
            "Sound diffusion",
            "Spartan-3",
            "USB ports"
        ],
        "doc_abstract": "Sound diffusion techniques are currently widely employed in the modern music allowing new composition styles and sound movement scenarios to be developed. Multichannel sound diffusion systems are built so as to provide the user with an opportunity to independently control several input channels through the desired output channels. The system MIAUDIO described in the paper allows using up to 8 input channels that can be mixed in real-time through 32 output speakers. The core part of the system which performs the desired audio mixture algorithm was implemented in a Spartan-3E Field Programmable Gate Array (FPGA). The mixture parameters are supplied by a host computer communicating with the FPGA via USB port. The complete system was successfully implemented and tested. The resulting solution has very low cost and was developed in relatively short time. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Parallel FPGA-based implementation of recursive sorting algorithms",
        "doc_scopus_id": "79951739418",
        "doc_doi": "10.1109/ReConFig.2010.30",
        "doc_eid": "2-s2.0-79951739418",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [
            "Circuit synthesis",
            "Finite state machines",
            "FPGA-based implementation",
            "Hardware description languages",
            "Hardware implementations",
            "Hierarchical finite state machines",
            "New results",
            "Parallel processing",
            "Parallel sorting algorithms",
            "Recursive algorithms",
            "Sorting algorithm",
            "Tree data structures"
        ],
        "doc_abstract": "The paper describes the hardware implementation and optimization of parallel recursive algorithms that sort data using binary trees. Since recursive calls are not directly supported by hardware description languages, they are implemented using the model of a hierarchical finite state machine (HFSM). Parallel processing is achieved by constructing N binary trees (N>1) and applying concurrent sorting to N trees at the same time with the aid of N communicating HFSMs. The paper presents new results in: 1) parallel sorting algorithms; 2) FPGA-based parallel architectures; and 3) the analysis and comparison of alternative and competitive techniques for implementing parallel recursive algorithms. Experiments demonstrate that the performance of sorting operations is increased compared to previous implementations. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Optimization of recursive sorting algorithms for implementation in hardware",
        "doc_scopus_id": "79951684089",
        "doc_doi": "10.1109/ICM.2010.5696191",
        "doc_eid": "2-s2.0-79951684089",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Circuit synthesis",
            "Finite state machines",
            "Hardware description languages",
            "Hardware implementations",
            "Hierarchical finite state machines",
            "Recursive algorithms",
            "Sorting algorithm"
        ],
        "doc_abstract": "The paper describes the hardware implementation and optimization of recursive algorithms that sort data using binary trees. Since recursive calls are not directly supported by hardware description languages, they are implemented using the known model of a hierarchical finite state machine (HFSM). The paper suggests new hardware-oriented recursive algorithms, describes their implementation in hardware; reports the results of numerous experiments; provides analysis and comparison of alternative and competitive techniques. The results clearly demonstrate that performance of sorting operations is increased comparing to other known implementations. © 2009 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Application-specific hardware accelerator for implementing recursive sorting algorithms",
        "doc_scopus_id": "79551516134",
        "doc_doi": "10.1109/FPT.2010.5681486",
        "doc_eid": "2-s2.0-79551516134",
        "doc_date": "2010-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "Application-specific hardware",
            "Computational model",
            "Data sorting",
            "Hardware accelerators",
            "Hardware and software",
            "Hardware architecture",
            "Hardware description languages",
            "Hierarchical finite state machines",
            "New results",
            "Parallel executions",
            "Recursive algorithms",
            "Sorting algorithm",
            "Tree-based"
        ],
        "doc_abstract": "The paper is dedicated to hardware accelerators for data sorting using tree-based recursive algorithms. Since recursive calls are not directly supported by hardware description languages, they are implemented using the model of a hierarchical finite state machine. The paper presents new results in: 1) computational models and hardware architectures; 2) optimization and parallel execution of recursive sorting algorithms; 3) the analysis and comparison of alternative and competitive techniques for implementation of recursive sorting algorithms both in hardware and software. Experiments with the proposed FPGA-based hardware accelerators demonstrate that the performance of sorting operations is increased compared to known implementations. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware implementation of recursive algorithms",
        "doc_scopus_id": "77956588948",
        "doc_doi": "10.1109/MWSCAS.2010.5548674",
        "doc_eid": "2-s2.0-77956588948",
        "doc_date": "2010-09-20",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Electronic, Optical and Magnetic Materials",
                "area_abbreviation": "MATE",
                "area_code": "2504"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Hardware circuits",
            "Hardware implementations",
            "Hardware resources",
            "Hierarchical finite state machines",
            "New model",
            "New results",
            "Prototyping",
            "Recursive algorithms",
            "Sorting algorithm"
        ],
        "doc_abstract": "The paper presents new results in the hardware implementation and optimization of recursive sequential and parallel algorithms using the known and a new model of a hierarchical finite state machine. Applicability and advantages of the proposed methods are confirmed through numerous examples of the designed hardware circuits that have been analyzed and compared. The results of experiments and FPGA-based prototyping demonstrate clearly that the proposed innovations enable the required hardware resources to be decreased achieving at the same time better performance of recursive sorting algorithms compared to known implementations both in hardware and in software. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "E-learning tools and remote reconfigurable systems for engineering education",
        "doc_scopus_id": "77955630274",
        "doc_doi": "10.1109/ICNIT.2010.5508567",
        "doc_eid": "2-s2.0-77955630274",
        "doc_date": "2010-08-20",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            }
        ],
        "doc_keywords": [
            "Animated tutorials",
            "Cosimulation",
            "E-learning tool",
            "Effective learning",
            "Engineering practices",
            "Prototyping",
            "Re-configurable",
            "Reconfigurable systems",
            "Remote laboratories",
            "Remote reconfiguration",
            "State-of-the-art engineering"
        ],
        "doc_abstract": "This paper presents an original approach proposed and successfully used in University of Aveiro and targeted to advance e-learning tools and remote laboratories for state-of-the-art engineering education. Nowadays, reconfigurable systems, in general, and FPGA (field-programmable gate array) based systems, in particular, constitute an essential part of engineering practice. The respective professional trends are, however, not reflected accordingly in contemporary engineering education curricula. The paper argues importance of reconfigurable systems in education and proposes effective learning methods and tools, which include laboratory templates animated tutorials education-oriented examples, a remotely reconfigurable prototyping system, and a virtual software/reconfigurable hardware co-simulation environment. © 2010 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Modeling, design, and implementation of a priority buffer for embedded systems",
        "doc_scopus_id": "71449091187",
        "doc_doi": null,
        "doc_eid": "2-s2.0-71449091187",
        "doc_date": "2009-12-11",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Vision and Pattern Recognition",
                "area_abbreviation": "COMP",
                "area_code": "1707"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            }
        ],
        "doc_keywords": [
            "Buffer architecture",
            "Hierarchical algorithm",
            "Output sequences",
            "Recursions"
        ],
        "doc_abstract": "The paper describes a model, architecture, and functionality of a priority buffer, which receives an arbitrary sequence of instructions and outputs a new sequence ordered in accordance with the priorities of the instructions that have already been received. Any new incoming instruction changes the output sequence because it has to be accommodated in the buffer on the basis of its priority. It is shown that the desired functionality of the buffer can be described efficiently by the proposed parallel hierarchical algorithms involving recursion. The algorithms have been modeled in general-purpose software and implemented in hardware (in a commercially available FPGA). The results of experiments have shown that the buffer operates in strong conformity with the requirements and specification. The required memory is allocated and deallocated dynamically. The proposed buffer architecture is easily scalable, which enables a buffer of any size to be provided. ©2009 ACA.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Specification and synthesis of parallel hierarchical finite state machines for control applications",
        "doc_scopus_id": "71449087077",
        "doc_doi": null,
        "doc_eid": "2-s2.0-71449087077",
        "doc_date": "2009-12-11",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Vision and Pattern Recognition",
                "area_abbreviation": "COMP",
                "area_code": "1707"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            }
        ],
        "doc_keywords": [
            "Control applications",
            "Hierarchical algorithm",
            "Hierarchical finite state machines",
            "Practical algorithms",
            "Proposed architectures",
            "Reconfigurable controllers"
        ],
        "doc_abstract": "Many practical algorithms require support for hierarchy and parallelism. Hierarchy assumes an opportunity to activate one sub-algorithm from another and parallelism enables different sub-algorithms to be executed at the same time. The paper presents a graphical specification of parallel hierarchical algorithms, suggests architecture of a parallel reconfigurable controller, indicates limitations and describes a formal method of synthesis allowing the given algorithms to be implemented in hardware on the basis of the proposed architecture. ©2009 ACA.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Virtual environment for prototyping and experiments",
        "doc_scopus_id": "77951105651",
        "doc_doi": null,
        "doc_eid": "2-s2.0-77951105651",
        "doc_date": "2009-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Computational devices",
            "Electronic functionality",
            "FPGA prototyping",
            "Interactive models",
            "Mechanical systems",
            "Physical objects",
            "Potential errors",
            "Process automation",
            "Prototyping",
            "Simulation tool",
            "Transportation system",
            "Virtual environments",
            "Visual simulation"
        ],
        "doc_abstract": "The paper suggests the methodology for validation of designed systems and experiments through the use of the developed simulation tools and interactive models. The primary idea is prototyping on the basis of virtual visual samples imitating interacting physical objects. The desired electronic functionality is implemented in reconfigurable hardware and, therefore, can easily be changed, which significantly simplifies such problems as verification of alternative implementations and eliminating potential errors. The desired physical functionality is modeled through observation of and experiences with interacting images which look like physical objects. The proposed methodology is very helpful and effective for many practical applications, such as mechanical systems control, robotics, process automation, transportation systems, computational devices, etc. © 2009 SICE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Modeling and implementation of automatic system for garage control",
        "doc_scopus_id": "77951104922",
        "doc_doi": null,
        "doc_eid": "2-s2.0-77951104922",
        "doc_date": "2009-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Industrial and Manufacturing Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2209"
            }
        ],
        "doc_keywords": [
            "Automatic parking",
            "Automatic systems",
            "Complete system",
            "Functional simulations",
            "Physical environments",
            "Sub-systems",
            "Visual simulation",
            "Wireless interfaces"
        ],
        "doc_abstract": "The paper describes a system for garage control providing for automatic parking of arriving cars and driving them to the garage exit on requests. The system is composed of two sub-systems that are directly linked for simulation purposes and communicate through a wireless interface needed for physical implementation. One of the basic modules providing for management and priority-driven selection of parking slots is considered in detail. The complete system prototype was designed, implemented in FPGA, validated, and tested. Functional simulation of the designed system is presented in a virtual mode enabling the relevant results to be evaluated visually on a monitor screen without the need for an expensive physical environment. © 2009 SICE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design and implementation of communicating fixed and variable instruction set processors",
        "doc_scopus_id": "77950495089",
        "doc_doi": "10.1109/ICCEE.2009.238",
        "doc_eid": "2-s2.0-77950495089",
        "doc_date": "2009-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Co-processors",
            "Combinatorial search",
            "Computational system",
            "Instruction set",
            "Instruction set processors",
            "Primary objective",
            "Processor architectures",
            "Scope of application"
        ],
        "doc_abstract": "The paper describes a computational system that is composed of a special-purpose processor augmented by an application-targeted coprocessor with variable instruction set. The primary objective is to form the processor architecture in such a way that is the most appropriate to a selected scope of applications and to optimize instructions of the coprocessor for a particular application. As an example the scope of combinatorial search algorithms was examined and experiments were carried out and analyzed with the relevant system implemented in FPGAs. © 2009 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A multimedia tool for teaching reconfigurable computing",
        "doc_scopus_id": "77950491936",
        "doc_doi": "10.1109/ICCEE.2009.237",
        "doc_eid": "2-s2.0-77950491936",
        "doc_date": "2009-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Engineering practices",
            "FPGA prototyping",
            "Multimedia tool",
            "Prototyping",
            "Prototyping board",
            "Reconfigurable computing",
            "Reconfigurable systems"
        ],
        "doc_abstract": "This paper proposes a method for efficient teaching of reconfigurable computing. Nowadays, reconfigurable systems, in general, and FPGA (Field-Programmable Gate Array) based systems, in particular, constitute an essential part of engineering practice. The paper argues importance of reconfigurable systems in education and suggests a multimedia tool augmented with an FPGA-based prototyping system, which could contribute to productive teaching of reconfigurable computing. © 2009 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Recursion in reconfigurable computing: A survey of implementation approaches",
        "doc_scopus_id": "70449926237",
        "doc_doi": "10.1109/FPL.2009.5272304",
        "doc_eid": "2-s2.0-70449926237",
        "doc_date": "2009-11-25",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "Ease of use",
            "Efficient implementation",
            "Hardware circuits",
            "Hardware description languages",
            "High Level Synthesis",
            "Implementation approach",
            "Problem-solving methods",
            "Reconfigurable computing",
            "Reconfigurable hardwares",
            "Reconfigurable systems",
            "Recursions",
            "Research efforts",
            "State of the art",
            "Synthesis tool"
        ],
        "doc_abstract": "Reconfigurable systems are widely used nowadays to increase performance of computationally intensive applications. There exist a lot of synthesis tools that automatically generate customized hardware circuits from specifications in both high-level and hardware description languages. However, such tools have a limited applicability because they are unable to handle recursive functions whereas it is known that recursion is a powerful problem-solving method widely used in computer science. Therefore a great deal of research effort is aimed at efficient implementation of recursion in reconfigurable hardware. This paper presents the state of the art in this area. The existing proposals are described, analyzed, and compared according to such criteria as level of parallelism supported, approach to concurrency, ease of use, availability of automated high-level synthesis tools, etc. ©2009 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Multimedia tools and architectures for hardware/software co-simulation of reconfigurable systems",
        "doc_scopus_id": "47649096359",
        "doc_doi": "10.1109/VLSI.2008.70",
        "doc_eid": "2-s2.0-47649096359",
        "doc_date": "2008-07-25",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Co-simulation",
            "Design methodologies",
            "Engineering training",
            "Graphical objects",
            "Hardware designs",
            "Illustrative examples",
            "International conferences",
            "Multimedia Tools",
            "Physical objects",
            "Prototyping",
            "Real world",
            "Reconfigurable system design",
            "Reconfigurable Systems",
            "Virtual objects",
            "Virtual simulations",
            "VLSI designs"
        ],
        "doc_abstract": "The paper describes novel multimedia tools and architectures for hardware/software co-simulation of reconfigurable systems. The main contributions are provided in the following three areas: 1) multimedia tools making it possible to manage animated graphical objects for virtual simulation of real world physical objects in the scope of reconfigurable system design; 2) a remotely accessible prototyping system, which is very helpful for both solving the problems of hardware design and supporting multimedia systems which can be used in vast varieties of practical applications, the most important of which are engineering training and education; 3) design methodology based on physical circuits and virtual objects. A number of illustrative examples demonstrating capabilities of the proposed approach are presented and discussed. © 2008 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Recursive versus iterative algorithms for solving combinatorial search problems in hardware",
        "doc_scopus_id": "47649090802",
        "doc_doi": "10.1109/VLSI.2008.51",
        "doc_eid": "2-s2.0-47649090802",
        "doc_date": "2008-07-25",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Binary matrices",
            "Boolean satisfiability (SAT)",
            "Combinatorial search",
            "Comparative data",
            "Graph colorings",
            "In-field",
            "International conferences",
            "Iterative algorithms",
            "VLSI designs"
        ],
        "doc_abstract": "The paper analyses and compares alternative iterative and recursive implementations of combinatorial search algorithms in hardware (in field-programmable gate arrays - FPGA, in particular). The results of experiments and comparisons for three widely used problems from this scope are presented, namely for the Boolean satisfiability, binary matrix covering, and graph coloring. The relevant comparative data have been obtained as a result of synthesis and implementation in FPGAs of the respective circuits from VHDL specifications. © 2008 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design and implementation of parallel hierarchical finite state machines",
        "doc_scopus_id": "51549112960",
        "doc_doi": "10.1109/cce.2008.4578929",
        "doc_eid": "2-s2.0-51549112960",
        "doc_date": "2008-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            },
            {
                "area_name": "Communication",
                "area_abbreviation": "SOCI",
                "area_code": "3315"
            }
        ],
        "doc_keywords": [
            "Design and implementations",
            "Hierarchical algorithm",
            "Hierarchical finite state machines",
            "Low costs",
            "Multiple stacks",
            "Real-world problem",
            "State transition diagrams"
        ],
        "doc_abstract": "This paper presents a novel model and method for synthesis of parallel hierarchical finite state machines (PHFSM) that permit to implement algorithms composed of modules in such a way that 1) the modules can be activated from other modules, and 2) more than one module can be activated in parallel. The model combines multiple stack memories interacting with a combinational circuit. The synthesis involves three basic steps: 1) conversion of a given specification to special state transition diagrams; 2) use of the proposed hardware description language templates; 3) synthesis of the circuit from the templates. A number of PHFSMs have been designed, implemented in low-cost commercially available FPGAs, tested, and evaluated. The results of experiments have proven the effectiveness and practicability of the proposed technique for solving real-world problems. ©2008 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A prototyping system for mobile devices",
        "doc_scopus_id": "36849060189",
        "doc_doi": "10.1145/1280940.1281048",
        "doc_eid": "2-s2.0-36849060189",
        "doc_date": "2007-12-14",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Hardware accelerators",
            "Prototyping boards",
            "Reconfigurable systems",
            "Remote reconfiguration"
        ],
        "doc_abstract": "The paper discusses an FPGA-based prototyping system with both wired and wireless programming and data exchange facilities. The system can be efficiently used for different types of portable devices. For example, it can supply additional interfaces to mobile computers; can be seen as a hardware accelerator for solving computationally complex problems or serve as a base for portable embedded applications. The system includes an extendable core prototyping board, development tools and supplementary software. The board is designed in such a way that it provides direct support for reconfiguration and self- reconfiguration. It can also be employed for virtual prototyping systems that require more resources that the capacity of the onboard FPGA. The supplementary software includes all necessary drivers and interfaces to interact with the board. The development tools are targeted to design space exploration and they consist of hardware description language libraries, design templates, IP cores, software models and multimedia applications. The latter are mainly used for different types of experiments and for hardware/software partitioning. Copyright 2007 ACM.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reuse technique in hardware design",
        "doc_scopus_id": "47949118773",
        "doc_doi": "10.1109/IRI.2007.4296594",
        "doc_eid": "2-s2.0-47949118773",
        "doc_date": "2007-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Digital systems",
            "Hardware circuits",
            "Hardware designs",
            "Information re-use",
            "International conferences"
        ],
        "doc_abstract": "The paper presents a technique for the design of digital systems on the basis of reusable hardware templates, which are circuits with modifiable functionality that might be customized to satisfy requirements of target applications, such as a highly optimized implementation of the selected problem-specific operations. Reusability is provided at two levels that are the level of hardware circuits and the level of specifications. The paper demonstrates how hardware templates can be modeled in software and implemented in hardware. © 2007 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Encoding algorithms for logic synthesis",
        "doc_scopus_id": "36249012507",
        "doc_doi": "10.1109/AICCSA.2007.370906",
        "doc_eid": "2-s2.0-36249012507",
        "doc_date": "2007-11-26",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Signal Processing",
                "area_abbreviation": "COMP",
                "area_code": "1711"
            }
        ],
        "doc_keywords": [
            "Auxiliary graph",
            "Logic elements",
            "State encoding",
            "Swapping coded variables"
        ],
        "doc_abstract": "This paper presents an encoding algorithm that is very efficient for many different logic synthesis problems. The algorithm is based on the use of special tables and includes two basic steps: searching for predefined graphical shapes in the tables, and swapping coded variables in the tables taking into account some constraints. The latter are specified with the aid of an auxiliary graph that reflects the overlap between coded variables in different subsets that have to be accommodated in the tables. The examples in the paper and the results of experiments have shown that the use of the proposed algorithm for state encoding allows the number of logic elements for combinational circuits of finite state machines to be decreased. © 2007 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Software/configware implementation of combinatorial algorithms",
        "doc_scopus_id": "36248985632",
        "doc_doi": "10.1109/AICCSA.2007.370934",
        "doc_eid": "2-s2.0-36248985632",
        "doc_date": "2007-11-26",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Signal Processing",
                "area_abbreviation": "COMP",
                "area_code": "1711"
            }
        ],
        "doc_keywords": [
            "Combinatorial algorithms",
            "Design process"
        ],
        "doc_abstract": "This paper discusses an approach for solving combinatorial problems by combining software and dynamically reconfigurable hardware (configware). The suggested technique avoids instance-specific hardware compilation and, as a result, allows obtaining higher performance than currently available pure software approaches as well as instance-specific reconfigurable solutions. Moreover, the technique permits problems to be solved that exceed the resources of the available reconfigurable hardware. The architecture of dynamically reconfigurable hardware problem solver is modeled in software allowing to estimate different characteristics, such as the time of reconfiguration, performance, etc., and to speed up the overall design process. © 2007 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based implementation of graph colouring algorithms",
        "doc_scopus_id": "34547990688",
        "doc_doi": "10.1007/978-3-540-73424-6_26",
        "doc_eid": "2-s2.0-34547990688",
        "doc_date": "2007-08-23",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Artificial Intelligence",
                "area_abbreviation": "COMP",
                "area_code": "1702"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The chapter suggests an FPGA-based implementation of graph colouring algorithms formulated over ternary matrices. First, software models (described in C++) and the respective hardware circuits (synthesised from Handel-C specifications) for getting exact solutions are discussed, analysed and compared. Then it is shown that the exact algorithm can serve as a base for a number of approximate algorithms, which permit to improve incrementally the results until some predefined criteria are satisfied. Characteristics and capabilities of the approximate algorithms are also examined. © 2007 Springer-Verlag Berlin Heidelberg.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis of reconfigurable hierarchical finite state machines",
        "doc_scopus_id": "34547967203",
        "doc_doi": "10.1007/978-3-540-73424-6_30",
        "doc_eid": "2-s2.0-34547967203",
        "doc_date": "2007-08-23",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Artificial Intelligence",
                "area_abbreviation": "COMP",
                "area_code": "1702"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The paper suggests design methods for reconfigurable hierarchical finite state machines (RHFSM), which possess two following important features: (1) they enable the control algorithms to be divided in modules providing direct support for \"divide and conquer\" strategy; (2) they allow for static and dynamic reconfiguration. Run-time reconfiguration permits virtual control systems to be constructed, including systems that are more complex than capabilities of available hardware. It is shown that RHFSM can be synthesised from specification in form of hierarchical graph-schemes with the aid of the considered in the paper VHDL templates. The results of experiments show correctness of the proposed methods and their applicability for the design of engineering systems. © 2007 Springer-Verlag Berlin Heidelberg.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Evolutionary algorithm for state encoding",
        "doc_scopus_id": "33845524982",
        "doc_doi": "10.1007/978-0-387-34747-9_24",
        "doc_eid": "2-s2.0-33845524982",
        "doc_date": "2006-12-21",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "Complex applications",
            "Encoding techniques",
            "Logic synthesis",
            "State encoding",
            "Sub-systems",
            "System of Boolean functions"
        ],
        "doc_abstract": "This paper presents an encoding technique that is common for many different logic synthesis problems. It enables us to construct a system of Boolean functions, and then to decompose this system into sub-systems in such a way that a dependency of functions, included into each sub-system, on the respective arguments is reduced. For complex applications such type of encoding has a high computational complexity and the paper proposes a novel evolutionary algorithm for the solution of this problem. © 2006 International Federation for Information Processing.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis of FSMs on the basis of reusable hardware templates",
        "doc_scopus_id": "33749035274",
        "doc_doi": null,
        "doc_eid": "2-s2.0-33749035274",
        "doc_date": "2006-11-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            },
            {
                "area_name": "Computer Science Applications",
                "area_abbreviation": "COMP",
                "area_code": "1706"
            }
        ],
        "doc_keywords": [
            "Dual-port memory",
            "Finite state machine",
            "Run-time modifications"
        ],
        "doc_abstract": "This paper suggests a reusable hardware template (HT) for finite state machines (FSM) and a method for the synthesis of FSMs based on such a template. The HT is a circuit with a predefined structure that has already been implemented in hardware (for example, in FPGA). By reprogramming its RAM-blocks we can implement a different functionality of the FSM. The proposed method permits the translation of a given FSM specification (that takes into account the parameters of a particular HT) into bitstreams for reloading the RAM-blocks. Run-time modifications are also permitted with the aid of dual-port memory. Note that the resulting FSM circuits are very fast and any state transition is performed within one clock cycle. The designed C++ program provides synthesis, verification and modeling of FSMs. The synthesized circuits were implemented and tested in Xilinx FPGAs. The synthesis methods considered permit various target requirements to be satisfied, such as minimizing the complexity of the circuit and the possibility for changes in the circuit functionality.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "E-learning tools and web-resources for teaching reconfigurable systems",
        "doc_scopus_id": "33750008975",
        "doc_doi": "10.1007/978-0-387-34731-8_23",
        "doc_eid": "2-s2.0-33750008975",
        "doc_date": "2006-10-20",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "E-learning tool",
            "Engineering works",
            "Higher education",
            "Information resource",
            "Integrated methodology",
            "Reconfigurable systems",
            "Research activities",
            "Web resources"
        ],
        "doc_abstract": "The paper shows that the teaching of reconfigurable systems is a complex and difficult process requiring many novel methods and tools to be considered within the same course. This process can be greatly simplified with the aid of the information resources and e-learning tools that have been developed and incorporated into an integrated methodology that includes original evaluation and motivation methods. This methodology has been successfully applied to the teaching of reconfigurable systems for approximately 10 years. The paper discusses the impact of this methodology on such important components of higher education as research activity, postgraduate learning, and training for engineering work in industry. © 2006 International Federation for Information Processing.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Intelligent systems engineering with reconfigurable computing",
        "doc_scopus_id": "85032185000",
        "doc_doi": "10.1007/978-0-387-34749-3_17",
        "doc_eid": "2-s2.0-85032185000",
        "doc_date": "2006-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "Fpga(field programmable gate array)",
            "Microprocessor core",
            "Programmable logic",
            "Reconfigurable computing",
            "Reconfigurable systems",
            "Recursive algorithms",
            "Required functionalities",
            "System-level specifications"
        ],
        "doc_abstract": "© 2006 by International Federation for Information Processing. All rights reserved.Intelligent computing systems comprising microprocessor cores, memory and reconfigurable user-programmable logic represent a promising technology which is well-suited for applications such as digital signal and image processing, cryptography and encryption, etc. These applications employ frequently recursive algorithms which are particularly appropriate when the underlying problem is defined in recursive terms and it is difficult to reformulate it as an iterative procedure. It is known, however, that hardware description languages (such as VHDL) as well as system-level specification languages (such as Handel-C) that are usually employed for specifying the required functionality of reconfigurable systems do not provide a direct support for recursion. In this paper a method allowing recursive algorithms to be easily described in Handel-C and implemented in an FPGA (field-programmable gate array) is proposed. The recursive search algorithm for the knapsack problem is considered as an example.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Recursive and iterative algorithms for N-ary search problems",
        "doc_scopus_id": "84927608470",
        "doc_doi": "10.1007/978-0-387-34749-3_9",
        "doc_eid": "2-s2.0-84927608470",
        "doc_date": "2006-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Information Systems",
                "area_abbreviation": "COMP",
                "area_code": "1710"
            },
            {
                "area_name": "Computer Networks and Communications",
                "area_abbreviation": "COMP",
                "area_code": "1705"
            },
            {
                "area_name": "Information Systems and Management",
                "area_abbreviation": "DECI",
                "area_code": "1802"
            }
        ],
        "doc_keywords": [
            "Embedded memory blocks",
            "Fast implementation",
            "Hierarchical algorithm",
            "Hierarchical finite state machines",
            "Iterative algorithm",
            "Paper analysis",
            "Search Algorithms",
            "Search problem"
        ],
        "doc_abstract": "© 2006 by International Federation for Information Processing. All rights reserved.The paper analyses and compares alternative iterative and recursive implementations of N-ary search algorithms in hardware (in field programmable gate arrays, in particular). The improvements over the previous results have been achieved with the aid of the proposed novel methods for the fast implementation of hierarchical algorithms. The methods possess the following distinctive features: 1) providing sub-algorithms with multiple entry points; 2) fast stack unwinding for exits from recursive sub-algorithms; 3) hierarchical returns based on two alternative approaches; 4) rational use of embedded memory blocks for the design of a hierarchical finite state machine.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design tools for reconfigurable embedded systems",
        "doc_scopus_id": "33750021650",
        "doc_doi": "10.1109/ICESS.2005.47",
        "doc_eid": "2-s2.0-33750021650",
        "doc_date": "2005-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Hardware/software tools",
            "Kernel prototyping",
            "Reconfiguration"
        ],
        "doc_abstract": "This paper describes the developed hardware/software tools, libraries and design methods for FPGA-based embedded systems which include: a kernel prototyping board with the Xilinx Spartan 3 FPGA; a set of projects for reusable FPGA-based circuits; utilities for FPGA programming; software/hardware tools that provide support for reconfiguration; and programs enabling the designers to partition the functionality of the developed system between software, running on a PC computer, and hardware, implemented in FPGA. A special attention has been paid to data exchange between a host computer and the kernel prototyping board based on compression/decompression techniques. Examples of practical applications are also presented. © 2005 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based implementation and comparison of recursive and iterative algorithms",
        "doc_scopus_id": "33746910626",
        "doc_doi": "10.1109/FPL.2005.1515728",
        "doc_eid": "2-s2.0-33746910626",
        "doc_date": "2005-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Binary (N-ary) search algorithms",
            "Iterative algorithms",
            "Recursive implementations"
        ],
        "doc_abstract": "The paper analyses and compares alternative iterative and recursive implementations of FPGA circuits for various problems. Two types of recursive calls have been examined, namely for cyclic and binary (N-ary) search algorithms. The details of experiments are presented for four different design problems. The relevant comparative data have been obtained as a result of synthesis and implementation in FPGAs of the respective circuits from system-level (Handel-C) and RTL (VHDL) specifications. © 2005 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Self-correction of FPGA-based control units",
        "doc_scopus_id": "33744931405",
        "doc_doi": "10.1007/11599555_31",
        "doc_eid": "2-s2.0-33744931405",
        "doc_date": "2005-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Control units",
            "FSM register",
            "Hamming codes",
            "Self correcting finite state machines",
            "Specification in vhdl"
        ],
        "doc_abstract": "This paper presents a self-correcting control unit design using Hamming codes for finite state machine (FSM) state encoding. The adopted technique can correct single-bit errors and detect two-bit errors in the FSM register within the same clock cycle. The main contribution is the development of a parameterizable VHDL package and the respective error-correcting modules, which can easily be added to an FSM specification using any state assignment strategy and having any number of inputs, outputs and states. Besides of application to FSM error correction, the developed tools can easily be adapted to other applications where error detection and correction is required. © Springer-Verlag Berlin Heidelberg 2005.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Teaching reconfigurable systems: Methods, tools, tutorials, and projects",
        "doc_scopus_id": "20344363169",
        "doc_doi": "10.1109/TE.2004.842909",
        "doc_eid": "2-s2.0-20344363169",
        "doc_date": "2005-05-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Education",
                "area_abbreviation": "SOCI",
                "area_code": "3304"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Animated tutorials",
            "Educational technology",
            "Miniprojects",
            "Reconfigurable architectures",
            "Reconfigurable computing"
        ],
        "doc_abstract": "This paper presents an approach that has been used for teaching disciplines on reconfigurable computing and advanced digital systems, which are intended to cover such topics as architectures and capabilities of field-programmable logic devices; languages for the specification, modeling, and synthesis of digital systems; design methods; computer-aided design tools; reconfiguration techniques; and practical applications. To assist the educational process, the following units have been developed and employed in the pedagogical practice: animated tutorials, miniprojects, hardware templates, and course-oriented library of digital circuits. To stimulate the student's activity, an optional project-based evaluation technique has been applied. All the materials that are required for students are available on the university website (WebCT) and can easily be used for studying inside the university, for obtaining additional information during practical classes and for distance learning. © 2005 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable hardware SAT solvers: A survey of systems",
        "doc_scopus_id": "8744233904",
        "doc_doi": "10.1109/TC.2004.102",
        "doc_eid": "2-s2.0-8744233904",
        "doc_date": "2004-11-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Computational Theory and Mathematics",
                "area_abbreviation": "COMP",
                "area_code": "1703"
            }
        ],
        "doc_keywords": [
            "Boolean satisfiability",
            "Combinatorial optimization problems",
            "Hardware acceleration",
            "High capacity programmable logic devices",
            "Reconfigurable computing"
        ],
        "doc_abstract": "By adapting to computations that are not so well-supported by general-purpose processors, reconfigurable systems achieve significant increases in performance. Such computational systems use high-capacity programmable logic devices and are based on processing units customized to the requirements of a particular application. A great deal of the research effort in this area is aimed at accelerating the solution of combinatorial optimization problems. Special attention in this context was given to the Boolean satisfiability (SAT) problem resulting in a considerable number of different architectures being proposed. This paper presents the state-of-the-art in reconfigurable hardware SAT satisfiers. The analysis and classification of existing systems has been performed according to such criteria as algorithmic issues, reconfiguration modes, the execution model, the programming model, logic capacity, and performance. © 2004 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A software/reconfigurable hardware SAT solver",
        "doc_scopus_id": "2442713051",
        "doc_doi": "10.1109/TVLSI.2004.825859",
        "doc_eid": "2-s2.0-2442713051",
        "doc_date": "2004-04-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Boolean satisfiability (SAT)",
            "Configurable computing",
            "Hardware platform",
            "Partitioning"
        ],
        "doc_abstract": "This paper introduces a novel approach for solving the Boolean satisfiability (SAT) problem by combining software and configurable hardware. The suggested technique avoids instance-specific hardware compilation and, as a result, allows the total problem solving time to be reduced compared to other approaches that have been proposed. Moreover, the technique permits problems that exceed the resources of the available reconfigurable hardware to be solved. The paper presents the results obtained with some of the DIMACS benchmarks and a comparison of our implementation with other available SAT solvers based on reconfigurable hardware. The hardware part of the satisfier was realized on Virtex XCV812E FPGA, which has a large volume of embedded memory blocks that provide direct support for the proposed approach.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Hardware/software implementation of FPGA-targeted matrix-oriented SAT solvers",
        "doc_scopus_id": "84947996377",
        "doc_doi": "10.1007/978-3-540-30117-2_100",
        "doc_eid": "2-s2.0-84947996377",
        "doc_date": "2004-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Hardware/software",
            "Host computers",
            "Matrix compression",
            "SAT problems",
            "SAT solvers"
        ],
        "doc_abstract": "© Springer-Verlag Berlin Heidelberg 2004.The paper describes two methods for the design of matrix-oriented SAT solvers based on data compression. The first one provides matrix compression in a host computer and decompression in an FPGA. It is shown that although some improvements have been achieved in this case, there exists a better solution. The second method makes possible to execute operations required for solving the SAT problem over compressed matrices.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Architecture of a Reconfigurable Processor for Implementing Search Algorithms over Discrete Matrices",
        "doc_scopus_id": "1642322114",
        "doc_doi": null,
        "doc_eid": "2-s2.0-1642322114",
        "doc_date": "2003-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            }
        ],
        "doc_keywords": [
            "Discrete matrices",
            "Search algorithms"
        ],
        "doc_abstract": "The paper suggests architecture of a reconfigurable processor, which can be customized for implementing different search algorithms over discrete matrices. Such algorithms might be used for solving various problems of combinatorial optimization, such as covering, Boolean satisfiability, etc. The proposed architecture contains memory blocks for a binary or a ternary matrix, general-purpose registers, five stacks, that make possible to carry out recursive search procedures based on a decision tree, and a reprogrammable functional unit that allows to perform the required operations over binary and ternary vectors. Two levels of control circuits have been suggested. The first (top) level permits to realize the search algorithm. The second (bottom) level allows operations that are required for the algorithm to be implemented.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design of Digital Circuits on the Basis of Hardware Templates",
        "doc_scopus_id": "1642294944",
        "doc_doi": null,
        "doc_eid": "2-s2.0-1642294944",
        "doc_date": "2003-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Harware templates",
            "Reprogrammable finite state machines (RFSM)",
            "Reusable architectures"
        ],
        "doc_abstract": "This paper presents a technique for the design of digital systems on the basis of reusable hardware templates (HT), which are circuits with modifiable functionality that might be customized to satisfy requirements of target applications, such as a highly optimized implementation of the selected problem-specific operations. It demonstrates how HTs can be modeled in software with the aid of suggested C++ classes and implemented in hardware (in FPGA in particular). It is shown that the desired functionality of HT-based digital systems might be provided through some changes to the behavior of reprogrammable finite state machines (RFSM) that are considered to be primary customizable blocks. The paper describes a parameterizable VHDL code of RFSM and demonstrates how the respective circuit can be implemented in FPGA.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "The design and implementation of a reconfigurable processor for problems of combinatorial computation",
        "doc_scopus_id": "0141963420",
        "doc_doi": "10.1016/S1383-7621(03)00067-5",
        "doc_eid": "2-s2.0-0141963420",
        "doc_date": "2003-09-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Software",
                "area_abbreviation": "COMP",
                "area_code": "1712"
            },
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            }
        ],
        "doc_keywords": [],
        "doc_abstract": "The paper analyses different techniques that might be employed in order to solve various problems of combinatorial optimization and argues that the best results can be achieved by the use of software running on a general-purpose computer together with an FPGA-based reconfigurable co-processor. It suggests an architecture for a combinatorial co-processor that is based on hardware templates and consists of reconfigurable functional and control units. Finally the paper demonstrates how the co-processor can be applied to two practical applications formulated over discrete matrices, the Boolean satisfiability and covering problems. © 2003 Elsevier B.V. All rights reserved.",
        "available": true,
        "clean_text": "serial JL 271017 291210 291716 291791 291869 291870 291883 31 Journal of Systems Architecture JOURNALSYSTEMSARCHITECTURE 2003-07-11 2003-07-11 2010-03-26T10:38:01 S1383-7621(03)00067-5 S1383762103000675 10.1016/S1383-7621(03)00067-5 S300 S300.1 FULL-TEXT 2015-05-15T06:00:21.838142-04:00 0 0 20030901 20030930 2003 2003-07-11T00:00:00Z articleinfo crossmark dco dateupdated tomb dateloaded datesearch indexeddate issuelist volumelist yearnav articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids confeditor contenttype copyright dateloadedtxt docsubtype doctype doi eid ewtransactionid hubeid issfirst issn issnnorm itemstage itemtransactionid itemweight openaccess openarchive pg pgfirst pglast pii piinorm pubdateend pubdatestart pubdatetxt pubyr sortorder srctitle srctitlenorm srctype subheadings vol volfirst volissue figure table body acknowledge affil articletitle auth authfirstini authfull authkeywords authlast primabst ref vitae alllist content subj ssids 1383-7621 13837621 49 49 4 6 4 5 6 Volume 49, Issues 4–6 8 211 226 211 226 200309 September 2003 2003-09-01 2003-09-30 2003 Reconfigurable Systems M. Edwards and L. Jozwiak converted-article fla Copyright © 2003 Elsevier B.V. All rights reserved. DESIGNIMPLEMENTATIONARECONFIGURABLEPROCESSORFORPROBLEMSCOMBINATORIALCOMPUTATION SKLIAROVA I 1 Introduction 2 Models and methods of combinatorial optimization 3 Strategies of combinatorial computations 4 Design and implementation of RCP 4.1 Reprogrammable matrices 4.2 Reconfigurable control unit 4.3 Reconfigurable functional unit 4.4 Implementation of the RCP 5 Experiments 5.1 The Boolean satisfiability problem 5.2 The covering problem 5.3 Performance results 6 Software/reconfigurable hardware partitioning 7 Discussion and related work 8 Conclusion Acknowledgements References ABRAMOVICI 2000 5 36 M ATHANAS 1993 11 18 P BARANOV 1994 S LOGICSYNTHESISFORCONTROLAUTOMATA BELL 1996 D SPLASH2FPGASINACUSTOMCOMPUTINGMACHINE CORMEN 1997 T INTRODUCTIONALGORITHMS DICK 1998 135 148 C GAREY 1979 M COMPUTERSINTRACTABILITYAGUIDETHEORYNPCOMPLETENESS GRAHAM 1995 352 361 P PROC5THINTERNATIONALWORKSHOPFIELDPROGRAMMABLELOGICAPPLICATIONS AHARDWAREGENETICALGORITHMFORTRAVELINGSALESMANPROBLEMSPLASH2 GU 1997 19 151 J HAENNI 1998 288 289 J PROCIEEESYMPOSIUMFPGASFORCUSTOMCOMPUTINGMACHINESFCCM RENCOARECONFIGURABLENETWORKCOMPUTER HAUCK 1998 615 638 S HAYNES 2000 50 57 S KOLINUMMI 2000 23 42 P KREHER 1999 D COMBINATORIALALGORITHMSGENERATIONENUMERATIONSEARCH MICHALEWICZ 2000 Z HOWSOLVEMODERNHEURISTICS MICHELI 1994 G SYNTHESISOPTIMIZATIONDIGITALCIRCUITS PERKOWSKI 2002 52 61 M IEEEMICRO LEARNINGHARDWAREUSINGMULTIPLEVALUEDLOGICPART2CUBECALCULUSARCHITECTURE PLATZNER 1998 69 78 M PROC8THINTWORKSHOPFIELDPROGRAMMABLELOGICAPPLICATIONSFPL98 ACCELERATIONSATISFIABILITYALGORITHMSBYRECONFIGURABLEHARDWARE SANCHEZ 1999 556 564 E SILVA 1999 506 521 J SKLIAROVA 2001 202 208 I VUILLEMIN 1996 56 69 J ZAKREVSKI 1981 A LOGICALSYNTHESISCASCADENETWORKS SKLIAROVAX2003X211 SKLIAROVAX2003X211X226 SKLIAROVAX2003X211XI SKLIAROVAX2003X211X226XI item S1383-7621(03)00067-5 S1383762103000675 10.1016/S1383-7621(03)00067-5 271017 2010-09-30T02:02:41.632868-04:00 2003-09-01 2003-09-30 true 424433 MAIN 16 59004 849 656 IMAGE-WEB-PDF 1 si8 528 18 127 si7 517 18 125 si6 767 17 155 si5 217 12 29 si4 599 40 124 si3 310 19 46 si2 310 19 46 si1 170 15 21 gr1 1665 93 84 gr1 20743 297 267 gr2 3069 94 125 gr2 3753 112 149 gr3 1674 62 125 gr3 2520 106 214 gr4 2990 88 125 gr4 7045 170 242 gr5 2840 93 118 gr5 5250 158 200 gr6 2570 71 125 gr6 5829 131 231 fx1 1034 49 125 fx1 1352 66 170 gr7 2273 92 71 gr7 7572 248 191 gr8 2613 60 125 gr8 5206 107 222 gr9 2057 93 71 gr9 8751 296 226 gr10 3780 94 96 gr10 9149 160 163 fx2 2071 92 66 fx2 38773 413 295 fx3 2189 92 66 fx3 44225 413 295 SYSARC 494 S1383-7621(03)00067-5 10.1016/S1383-7621(03)00067-5 Elsevier B.V. Fig. 1 The structure of RCP. Fig. 2 Example of representing a ternary matrix in FPGA memory blocks. Fig. 3 A trivial structure of RAM-based FSM. Fig. 4 The proposed architecture of the RCU. Fig. 5 The reconfigurable core performs operations over rows and columns of matrices. Fig. 6 Configuring the RCP. Fig. 7 A GS of the algorithm for solving the Boolean satisfiability problem. Fig. 8 A minimum-size vertex cover of a graph (a) and the corresponding incidence matrix (b). Fig. 9 An algorithm for finding the minimal row cover of a Boolean matrix. Fig. 10 Processing of the decision tree in software and in reconfigurable hardware. Table 1 Experimental results with RCP implemented in XC4010XL FPGA Problem Matrix/vector dimensions Software execution time (in ms) Hardware execution time (in ms) Speedup Count the number of ones in a vector 8 0.0059 0.00002487 237 Cov1 0.284 0.0110 25.82 Cov2 0.310515 0.0144 24.56 Cov3 0.217905 0.0065 33.52 Cov4 0.17684 0.00423 41.81 Cov5 8×8 0.292075 0.00924 31.61 Cov6 0.227125 0.00274 82.89 SAT1 4.54248 0.02971 152.89 SAT2 5.22301 0.01508 346.35 SAT3 0.24891 0.000588 423.32 SAT4 11.75764 0.07485 157.08 SAT5 8×8 2.72465 0.008059 338.09 SAT6 0.51543 0.002647 194.72 ☆ A preliminary version of this paper was presented at the Euromicro Symposium on Digital System Design (DSD), Warsaw, Poland in 2001. The design and implementation of a reconfigurable processor for problems of combinatorial computation Iouliia Skliarova ∗ António B. Ferrari Department of Electronics and Telecommunications, University of Aveiro, IEETA, 3810-193 Aveiro, Portugal ∗ Corresponding author. Tel.: +351-234-370-355x23062; fax: +351-234-370-545 The paper analyses different techniques that might be employed in order to solve various problems of combinatorial optimization and argues that the best results can be achieved by the use of software running on a general-purpose computer together with an FPGA-based reconfigurable co-processor. It suggests an architecture for a combinatorial co-processor that is based on hardware templates and consists of reconfigurable functional and control units. Finally the paper demonstrates how the co-processor can be applied to two practical applications formulated over discrete matrices, the Boolean satisfiability and covering problems. Keywords Reconfigurable combinatorial processor Hardware template Combinatorial problems 1 Introduction With the advent of reconfigurable computing it becomes possible to create rapidly custom hardware implementations of various algorithms that cannot be solved efficiently using other known approaches (such as ASIC-based implementations, realization on general-purpose computers (GPCs), etc.). The effectiveness of reconfigurable circuits in general, and FPGA-based circuits in particular, depends on the application, and for certain classes of problems they provide many advantages from the point of view of performance, the resources required, etc. [14]. This potential has been realized by many different research machines, such as DECPeRLe [37], Splash 2 [6], PRISM [4], RENCO [13], Spyder [16], etc. [25]. There are many applications where an FPGA-based system offers a very high performance solution, including DNA pattern recognition, RSA cryptography [27], the traveling salesman problem [11], long integer arithmetic [37], signal processing [9], neural networks [17], image processing [15], and the Boolean satisfiability (SAT) problem [23]. Most of the current systems that are implemented in reconfigurable hardware are data processing computations based on relatively simple algorithms. The applications that are suitable for a configurable realization usually have a large number of bit-level manipulations, which is typical for applications in image processing, cryptography, etc. This paper suggests applying the configurable computing technique to problems that involve rather more complex flow of control operations, in particular, problems in the area of combinatorial optimization. There are a few reconfigurable engines available for such problems [1,11,22–24,36,41,42]. They are mainly based on the idea of instance-specific hardware, which assumes that a specific FPGA configuration is generated for each individual problem. In this paper we propose a domain-specific approach that enables a variety of problems in the area of combinatorial computation to be addressed. The proposed technique is based on a reconfigurable combinatorial processor (RCP) that is going to be used for solving combinatorial tasks formulated over discrete matrices [40]. The approach we have adopted is based on special hardware templates (HTs) that allow execution and control units with the same architecture to be used for a variety of problems, and which do not require to be changed from one task to another. In this case, it is only necessary to configure the basic computational operations and the corresponding control algorithms for each combinatorial problem. The paper is divided into eight sections. Section 1 is this introduction. Section 2 presents typical models and methods used in the field of combinatorial optimization. Section 3 gives an overview of possible strategies for combinatorial computations. Section 4 discusses the architecture of the proposed RCP. Experiments are presented in Section 5. Section 6 summarizes the principal ideas of software/reconfigurable hardware partitioning. Section 7 surveys related work on reconfigurable accelerators for solving combinatorial optimization problems, providing the respective comparison with the RCP. Finally, the conclusion is given in Section 8. 2 Models and methods of combinatorial optimization The problems of combinatorial optimization arise in many application areas such as logic design, technical diagnostics, artificial intelligence, etc. [20,40]. Many of these problems are known to be NP-hard [10], which means that in general, the execution time for a solution grows exponentially with the size of a problem instance. Of course, with the proposed approach, we cannot cancel out this effect of exponential growth, but we are able to delay it by enabling the primary operations of the respective algorithms to be executed more efficiently. The exact algorithms that are employed in the area of combinatorial optimization are usually based on the generation and exhaustive examination of all possible solutions until a solution with a desired quality is found. The primary decision to be taken in this approach is how to generate the candidate solutions effectively. A widely accepted answer to this question consists of constructing a decision tree [18], which enables all possible solutions to be generated in a well-structured and efficient way. The root of the tree is considered to be the starting point that corresponds to the initial situation. The other nodes represent various situations that can be reached during the search for results. The arcs of the tree specify steps of the algorithm that have been performed. Initially, the decision tree is unknown and it is constructed during the search process. A distinctive feature of this approach is that at each node of the decision tree the same problem is being solved. The only thing that changes from node to node is the input data. This means that the whole problem reduces to the execution of a large number of repeated operations over a periodically modified set of data. Of course, the method of exhaustively checking all possible solutions cannot be used for the majority of practical problems because it requires such a very long execution time. That is why it is necessary to apply some optimization techniques that reduce the number of the situations that need to be considered. In order to speed up the discovering of the results various tree-pruning techniques are applied. Usually the pruning process is based on erasing repeated variants and on avoiding feasible solutions that have a cost higher than the cost of any solution already found. Sometimes it is possible to apply problem-specific methods that allow big portions of the decision tree to be pruned by exploiting instance-specific information that can be obtained during the search. A good example of this technique is non-chronological backtracking that is widely used in the state-of-the-art SAT solvers [21,28]. The other known method of improving the effectiveness of the search is a reduction [40], which permits the current situation to be replaced with some new simpler situation without sacrificing any feasible solution. As a result, the number of computations that are required for the analysis of situations resulting from the current algorithmic step can be reduced. Returning to the example of the Boolean satisfiability problem, the well-known unit-clause rule is a good illustration of this technique [12]. However, a reduction is not possible for all existing situations. In this case another method is used that relies on the divide-and-conquer strategy [19]. This applies to critical situations that have to be divided into several simpler situations such that each of them has to be examined. The objective is to find the minimum number of such variants. Very often these new situations can be ordered according to some criteria. Considering such preliminary ordered variants essentially increases the effectiveness of computations. It is not always possible to find the optimal solution for a number of practical combinatorial problems in a reasonable time with the available computational resources. In these cases approximate algorithms are widely used [19]. It should be noted that many of the approximate algorithms that have been developed for problems of combinatorial optimization also rely on the construction of a decision tree [40]. These algorithms try to reduce the number of variants to be considered by eliminating less promising branches of the decision tree. However, in this procedure the optimal result can be lost. The quality of the results and the computation time define the effectiveness of approximate methods. There are many formal mathematical models such as sets, graphs, matrices, logic functions, etc. that are typically used in order to describe combinatorial tasks. As a rule any of these representations can be converted into any other [31]. We have selected discrete matrices as the primary mathematical model because they can easily be represented in both software and hardware. Besides, the architecture of the combinatorial processor that we are going to suggest needs to be reconfigurable (in order to be able to handle a variety of problems and problem instances) and the matrix model is more suited to this purpose because it significantly eases the process of reconfiguration and helps to minimize the reconfiguration time. 3 Strategies of combinatorial computations Let us analyze the various possible ways in which combinatorial computations might be carried out. Basically, there are three different approaches that can be adopted. The first is based on the design and implementation of an ASIC that is able to solve a chosen combinatorial problem. In this case we are likely to achieve excellent results (in terms of performance) because the functional and control units that are required can be optimized for the selected problem. However, if it becomes necessary to solve a different problem, or even to make a small change in the algorithm employed, all the original design steps have to be repeated. Thus this approach is totally inflexible. Moreover, ASICs have very high development costs that would only be recovered in the case of large volume production. The second possible approach is to use a GPC and to develop a software program that solves the required combinatorial problems. Compared to the first approach this is very flexible: any algorithmic change can easily be incorporated into the program code. The problem here is performance. The architecture of a GPC is not tailored to the specific domain of combinatorial computations and applications must always be programmed using the instructions from the fixed set that the machine provides. The last approach to be analyzed relies on reconfigurable hardware. This is considered to be more advantageous because it allows the benefits, such as flexibility and speed, of both ASICs and GPCs to be combined, and their weaknesses to be eliminated. Of course, in similar technology, FPGAs (reconfigurable hardware is usually constructed with the aid of SRAM-based FPGAs) suffer a speed penalty of at least one order of magnitude compared to ASICs. However, FPGAs possess the flexibility and low development cost of software implementations. To enable an implementation based on reconfigurable hardware to outperform the equivalent software implementation, the following techniques are usually employed. First, primary functional units are constructed in such a way that they are optimized for particular operations, thus requiring fewer clock cycles [2]. Second, the techniques of parallel processing and pipelining are employed. And finally, the memory organization is tailored to specific data sizes, thus speeding up data transfer. It should be noted that in general it is difficult to realize practical combinatorial algorithms efficiently entirely in an FPGA. This is because reconfigurable logic is not so well suited for some computations. For instance, floating point arithmetic can be realized more efficiently in custom mathematical co-processors. In addition, some fragments of combinatorial algorithms are activated rarely and we can predict that the effectiveness of an FPGA-based solution will be low for such fragments. A GPC is more appropriate for realizing such irregular computations. On the other hand, FPGAs are more suited to regular (repeated) processing of a large volume of data [14]. Thus the best result can be achieved by a combination of GPC and FPGA resources. Subroutines that can benefit from a hardware implementation are mapped to the FPGA, while others are computed by the GPC. Besides, in general it is not possible to solve any problem instance in FPGA because the reconfigurable hardware resources are always limited. A more detailed consideration of this matter is given in Section 6. Combinatorial optimization problems have a huge number of varieties so it is difficult to design a universal accelerator that would allow for their efficient solution. Indeed it would be very problematical to find a reasonable compromise between the complexity of such an accelerator and the redundancy of its components [30]. The architecture of the RCP has to be reconfigurable to allow a wide variety of combinatorial problems to be solved. The reconfigurability feature is of great importance because the number of different primary operations required to support all relevant algorithms is huge, but any particular algorithm involves just a very limited number of them [22,30]. Within the domain of configurable computing, we can distinguish between two modes of configurability: static and dynamic [26]. Static reconfiguration assumes permanent functionality after the configuration has been loaded. In fact it does not provide much flexibility but permits performance to be increased by using hardware that is optimized for a given application. Dynamic reconfiguration allows the functionality of the system to be changed during the execution of an application. Dynamic reconfiguration can in turn be partial or global. Global reconfiguration reserves all the hardware resources for each step of execution. After a step has been concluded, the device may be reprogrammed for the next step. Partial reconfiguration implies the selective modification of hardware resources. This opportunity allows the hardware to be adapted to better suit the actual needs of the application. Since only selected portions are reconfigured, the configuration overhead is smaller than in the previous case. A variety of reprogrammable devices can be used to carry out dynamic reconfiguration. Single-context devices require complete reprogramming in order to introduce even a small change. Multi-context devices possess various planes of configuration information with just one of them active at any given moment. The main advantage of such devices is the ability to switch the context very quickly. They also support background configuration thus allowing a selected context to be reprogrammed while another one is active. Partially reconfigurable devices permit small portions of their resources to be modified without disturbing the remaining parts. Although this kind of device (such as the XC6200 family of Xilinx) was used in some architectures intended to accelerate the solution of combinatorial problems [1], the potential for partial reconfigurability has not been explored. It should be noted that although the majority of commercially available FPGAs are single-context, there is a technique (based on HTs) that allows partial dynamic reconfiguration to take place. The primary idea of a HT is to construct a parameterizable computational unit in such a way that it includes components that have both changeable and non-changeable functionality with fixed connections between them [30]. Customizing the unit is achieved by configuring the components that have alterable functionality, and the number of these components is kept to a minimum. This allows partial reconfigurability to be used and fundamentally reduces the configuration overhead. 4 Design and implementation of RCP On the basis of the analysis of the mathematical models that are used in combinatorial optimization [31], and the primary operations and basic techniques for combinatorial algorithms over discrete matrices [30], the following requirements for the RCP have been formulated. Due to the heterogeneity of combinatorial tasks, the RCP must be dynamically reconfigurable. In other words we must be able to modify the processor’s functionality at run time. In order to reduce the reconfiguration time, the RCP has to be based on a HT. In this case only the basic computational operations and the corresponding control algorithms can be altered. All the other components and connections between them will not be changed. In order to do this we propose using a RAM-based HT in such a way that customizing the functionality of the RCP is achieved by reloading RAM-based blocks. Consequently, the RCP has to be built on the basis of an FPGA with distributed memory cells (e.g. LUTs) or embedded memory blocks, such as the Xilinx XC4000 and Virtex families. The distributed cells grouped in blocks of required sizes can be used to store matrices, much like the way the general-purpose registers of a GPC store operands and the results of intermediate computations. The embedded memory blocks can also be used to implement the components of a HT with modifiable functionality. The reconfiguration is supported by auxiliary circuits that control the reloading of the RAM-based blocks. Fig. 1 depicts the structure of a RCP that satisfies the requirements considered above. The RCP in Fig. 1 consists of two major parts: a reconfigurable control unit (RCU), and a reconfigurable functional unit (RFU). The shaded blocks in Fig. 1 can be customized for a particular application. The remaining blocks possess fixed functionality and perform common tasks that are shared by many different combinatorial problems. Let us describe each reconfigurable block from Fig. 1 in more detail. 4.1 Reprogrammable matrices The Matrices block can store up to three logical matrices with dimensions m×n. For each logical matrix, U, two physical copies are constructed, the first of which stores the original matrix, U, and the second stores its transpose, U T . Of course, such an approach requires double the resources needed to store just the matrix data. However, the RCP performance is improved significantly because each row and column can be read in just one clock cycle. Each physical matrix is composed of two blocks of equal dimensions: U_ones and U_zeros. The blocks U_ones (U T_ones) contain 1s in the positions where the original logical matrix U ( U T ) has 1s and contain 0s in all the other positions. Correspondingly, the blocks U_zeros (U T_zeros) hold 1s only in the positions in which matrix U ( U T ) has 0s. As a result, each element u ij , i=1,…,m, j=1,…,n, of the matrix U is encoded as follows: • if u ij =‘1’, then U_ones[i][j]=‘1’ U_zeros[i][j]=‘0’, U T_ones[j][i]=‘1’, and U T_zeros[j][i]=‘0’. • if u ij =‘0’, then U_ones[i][j]=‘0’, U_zeros[i][j]=‘1’, U T_ones[j][i]=‘0’, and U T_zeros[j][i]=‘1’. • if u ij =‘-’, then U_ones[i][j]=‘0’, U_zeros[i][j]=‘0’, U T_ones[j][i]=‘0’, and U T_zeros[j][i]=‘0’. Fig. 2 illustrates the encoding for the following matrix: U = – 1 0 0 – 1 Before execution the relevant matrix data are transferred to the Matrices block. When some other problem instance is to be solved, the block can easily be loaded with different data. 4.2 Reconfigurable control unit The RCU implements the control algorithms that are required. The unit is modeled by a finite state machine (FSM) with dynamically modifiable behavior that generates the sequence of operations for the combinatorial algorithm being executed. An FSM might be presented at the structural level as a composition of a combinational circuit that calculates the next states and outputs, and a register that stores the current state (see Fig. 3 ). We are considering a so-called RAM-based FSM, i.e. an FSM for which the combinational circuit is constructed from RAM-based blocks [32]. Any state code from the register is combined with input variables (i.e. logic conditions from the set X) and the result forms an address in the FSM RAM. Each address accesses a word in the FSM RAM that contains both the code for the corresponding next state and the outputs (i.e. the control signals from the set Y). Such an architecture is easily reprogrammable since reloading the contents of the FSM RAM changes the functionality of the RCU. If R is the minimum number of bits needed for state codes, then the size of the FSM RAM is 2(R+L)×(R+N), where L is the number of inputs from the set X and N is the number of outputs from the set Y. For sufficiently large L the size of the FSM RAM becomes quite large. Thus the principal drawback of this approach is that it is resource consuming and only allows very simple control algorithms to be implemented. In order to reduce the size requirements of the RCU, a special state encoding technique was employed that allows the functional dependency of outputs on inputs to be reduced [35]. The technique relies on combining the inputs from the set X with state codes, enabling the depth of the FSM RAM to be reduced to 2 R ′ where R⩽R ′⩽(R+L). As a result, the size of the FSM RAM becomes 2 R ′ ×(R ′+N). Experiments have shown that for many practical applications R ′→R and usually R⩽R ′⩽(R+1) [35]. To support reprogrammability, the RCU is decomposed into several RAM-based sub-blocks corresponding to the architecture presented in Fig. 4 (which implements the Moore FSM model). The block Y RAM produces outputs on the basis of state codes. The block A RAM provides conditional state transitions, i.e. transitions that are caused by some input variables from the set X. For all unconditional state transitions the output vector a is identically equal to 0. The block P RAM calculates the vector p that depends on inputs from the set X and on the vector a. Finally, the block FSM RAM produces the next state of the FSM. A more detailed description of the decomposition and encoding can be found in [32,35]. As a result, the RCU is based on a parameterizable HT that has some predefined constraints. These constraints restrict the sizes of the respective RAM-based blocks, and consequently determine the maximum number of FSM states, inputs, outputs, and conditional state transitions that can be accommodated [32]. It is very easy to reprogram this device. For such purposes it is sufficient to reload the contents of the RAM-based blocks. We have developed special software tools [32] that allow a given behavioral specification of the control algorithms to be translated into the RAM contents, assuming that the RCU is based on the predefined HT. The results of experiments [32] have shown that the proposed realization of the RCU requires less area than circuits generated by the Xilinx Foundation Software from the same specification. 4.3 Reconfigurable functional unit The RFU is composed of memory elements and circuits needed to store and process the variables of the algorithm. Basic computations over columns and rows of discrete matrices are executed in the reconfigurable core shown in Fig. 5 . The core is composed of a number of RAM-based blocks (the number of blocks, k, is equal to max(m,n)). Each block performs an operation over one or two 2-bit values and calculates a 2-bit result. The first bit comes from one of the blocks U_ones or U T_ones, and the second bit is from the blocks U_zeros or U T_zeros. In order to implement different operations, it is necessary to reload the appropriate group of RAM-based blocks. Three groups of operations have been proposed: Boolean operations, such as a ∧ b ; operations that require an answer in the form YES/NO, for example “test if a is orthogonal to b”; and counting operations, such as calculating the number of zeros in a Boolean vector [29,30]. 4.4 Implementation of the RCP Two variants of the RCP have been designed, implemented, and tested. The first variant was implemented based on the XStend board from XESS [38] containing one Xilinx XC4010XL FPGA. The reprogrammable blocks of the RCP were constructed from LUTs available in this FPGA. The reconfiguration was carried out through the parallel port. Since the FPGA employed has very restricted resources and reconfiguration via a parallel interface does not provide much flexibility, this implementation has only been used for verification purposes and for some experiments. In this section we present the results achieved with this approach. The second variant of RCP architecture that is more application-oriented was implemented subsequently using the ADM-XRC PCI board [3]. This board contains one XCV812E Virtex Extended Memory FPGA with approximately 254K logic gates and embedded memory blocks that provide for a total capacity of more than 1 Mbits [39]. Interaction with the FPGA is carried out with the aid of the ADM-XRC API library, which provides support for initialization, loading configuration bitstreams, data transfers, interrupt processing, clock management and error handling. The respective implementation is tailored to the Boolean satisfiability problem and all the details can be found in [33,34]. For configuring the FPGA, the following model has been proposed (see Fig. 6 ). Basic functions of combinatorial algorithms (for instance, find-max-column, find-ort-row, etc.) are included in a parameterized library. The system level specification is prepared in the C++ programming language, i.e. a combinatorial algorithm is described in C++ using the library mentioned above. The assisting software tools extract the corresponding configuration from the library and download it to the FPGA when required. Note that the basic HT is loaded from the very beginning, so it is only necessary to reprogram the alterable components in the RCU and RFU. Finally the matrix data are passed to the FPGA for processing. When the computation has been completed, the assisting software tools will store the intermediate results and program execution will proceed, eventually reaching another hardware library function forcing a similar sequence of actions, i.e. the process considered above will be repeated. 5 Experiments Two main applications were used to test the RCP. These are the Boolean satisfiability problem and the covering problem. 5.1 The Boolean satisfiability problem The Boolean satisfiability problem involves determining if a formula presented in conjunctive normal form (CNF) is satisfied by some truth assignment. The search variant of this problem requires at least one satisfying assignment to be found. A CNF consists of a conjunction of a number of clauses, where a clause is a disjunction of one or more variables or their negations. The SAT problem has great importance in the area of computer-aided hardware optimization. For example the following formula contains four variables and three clauses, and is satisfied when x 1=‘0’, x 2=‘0’, x 3=‘1’ and x 4=‘1’: ( x ̄ 1∨x4)(x3)(x1∨ x ̄ 2∨ x ̄ 3) In order to solve this problem with the aid of the RCP, we first have to formulate it over a ternary matrix U. Let us set a correspondence between the variables and clauses of the formula, and the columns and rows of U. Each element u ij , i=1,…,m, j=1,…,n, of the matrix is equal to: • ‘0’––if variable x j is included in clause c i with negation; • ‘1’––if variable x j is included in clause c i without negation; • ‘-’ (don’t care)––if variable x j is not included in clause c i . Taking into account these rules, the matrix U for the formula considered above can be presented in the following form: We have implemented a deterministic solution to the SAT problem that exhaustively generates and examines all possible assignments of values to variables. It should be noted that such a brute-force approach is not very efficient. However, it can be used to estimate the effectiveness of the proposed architecture. The more competent solution to this problem can be found in [33,34]. The algorithm employed has been described by the graph-scheme (GS) [5] depicted in Fig. 7 . The problem can be solved using the following sequence of actions. First we have to construct the matrix U, load the control algorithm from Fig. 7 into the RCU, and configure the RFU to implement the orthogonality checking operation. According to the algorithm we have to find a Boolean vector w that is orthogonal to all rows of the matrix U. Two ternary vectors a =[a1 a2 …an] and b =[b1 b2 …bn] are orthogonal if there exist j=1,…,n, such that either a j =‘0’ and b j =‘1’, or a j =‘1’ and b j =‘0’. If such vector cannot be found then the problem is unsatisfiable. In the opposite case the negated vector w gives the solution, i.e. all its elements having value ‘0’ point to variables, which must be equal to ‘1’, and all its elements with value ‘1’ point to variables, which must be equal to ‘0’. The overall runtime for solving this problem in hardware includes in our case the time for configuring the matrix, the RCU, and the RFU, and the actual hardware execution time. 5.2 The covering problem Covering is a well-known combinatorial problem that has many practical applications. For a given set it requires a subset to be found that has certain properties. The optimization variant of this problem involves finding a subset of minimal cardinality. For example, let us suppose that it is necessary to determine a minimum-size vertex cover of an undirected graph. It is known that a vertex cover of a graph G=(V,E) is a subset V ′⊆V such that if (u,v)∈E, then u∈V ′ or v∈V ′ (or both) [7]. In order to solve this problem in the RCP, we must reformulate it over a matrix. For this purpose let us build the incidence matrix, I, whose columns correspond to edges of the graph and rows represent the vertices. Now in order to solve the problem, we have to find a cover of the matrix, I, that is composed of the minimal number of rows having in conjunction at least one ‘1’ in each column of I. The selected rows correspond to the vertices that must be included into the minimum-size vertex cover. Let us consider an example. For the graph in Fig. 8a the incidence matrix is presented in the form depicted in Fig. 8b. In order to find a minimum-size row cover of a Boolean matrix we used the approximate algorithm described in Fig. 9 [40]. As can be seen from Fig. 9, the primary operation to be executed by the algorithm is to count the number of ones in different rows and columns of the matrix. Thus the problem can be solved by applying the following basic steps. First the matrix I is constructed, then the control algorithm is loaded into the RCU. Finally, the RFU is configured to implement a count-number-of-ones operation. The discovered subset is shaded in the graph in Fig. 8a and in the matrix I in Fig. 8b. In this example we have indeed found the minimum-size vertex cover of the graph but in the general case the algorithm does not guarantee that the best solution will be found. 5.3 Performance results Table 1 contains the results obtained when we solved the two combinatorial problems considered with the aid of software running under Windows 2000 on a Pentium III-800 MHz/256 MB PC and with the RCP implemented in an XC4010XL FPGA. The rows Cov1…Cov6 show results for randomly generated instances of the covering problem, and the rows SAT1…SAT6––for the satisfiability problem. The first line in Table 1 presents an example of a trivial operation that counts the number of ones in a Boolean vector. This operation requires several clock cycles in a GPC. In the RCP we can realize it using much fewer clock cycles. As it can be seen from Table 1, the improvement in results obtained for the covering problem compared to the software implementation of the same algorithm is quite considerable. The primary operation of the algorithm for finding the minimal row cover of a Boolean matrix is to count the number of ones in various rows and columns (see Fig. 9). As we mentioned above, this operation executes in the RCP much faster than in software. However, the problem is quite control-oriented, so the acceleration in the basic operation is not achieved overall because the other parts of the algorithm are not executed much faster than in software. We guess that this circumstance impedes the achievement of a more significant speedup compared to the software implementation. For the satisfiability problem we have obtained more impressive speedups. This is because the algorithm (see Fig. 7) only requires sequential reading of different rows of the matrix and checking the respective vectors for orthogonality. Each of these operations needs just one clock cycle in the RCP. In software the matrix has been constructed as an array of integers. Thus checking whether the vector w (see Fig. 7) is orthogonal to any row of the matrix requires many memory accesses and calculations. 6 Software/reconfigurable hardware partitioning For the examples considered (see Section 5), each task was completely solved in FPGA. Note that the proposed RCP limits the maximum dimensions of the matrix so the RCP cannot be used for dealing with an arbitrary task. With respect to the maximum matrix dimensions that are allowed, three different kinds of situations can occur: • The problem instance is very small and simple. In this case the use of FPGA becomes unreasonable because it takes a significant time to reconfigure the HT (in our case), or to generate the hardware circuit (in an instance-specific approach). Either way, in this instance we will lose all the advantages of fast hardware and a software solution will work much faster. • The problem instance is hard and its dimensions fit within the matrix dimensions allowed in FPGA. In this case we might possibly achieve a sufficiently good performance to offset the hardware configuration time. However, real-world problems rarely match the limited dimensions of the HT. • The problem size is very large, far and away exceeding the supported hardware capacity. Within the domain of an instance-specific approach [1,41], the following solution is usually adopted. If the circuit cannot be implemented in a single FPGA, several FPGAs are employed by applying special methods for multi-FPGA partitioning. Nevertheless, there is still no guarantee that a given task will be solved efficiently on the available reconfigurable hardware resources. Because of that, we suggest the following strategy should be applied. As we have already discussed in Section 2, a common approach to solving combinatorial problems is based on a decision tree. When we construct the tree, various splitting and reduction methods are used. This enables the initial matrix dimensions to be decreased gradually (traversing one of the tree branches). The RCP is based on a HT with predefined constraints on the maximum number of rows and columns of the matrix. We can utilize the following technique to accommodate this. First of all, the assisting software tools will configure the RFU and the RCU to execute the required algorithm. Next, if the initial matrix satisfies the predefined constraints, the matrix data will be transferred to FPGA and the problem will be completely solved in the RCP. Otherwise, the software will try to solve the problem. During this process, it will apply special splitting and reduction methods until an intermediate matrix, constructed during the current search step, is arrived at that does not exceed the capacity restrictions. From this point on, the RCP will be responsible for subsequent steps. If the reconfigurable hardware finds a solution, the problem is considered to be solved and the result will be dispatched to the host computer. On the other hand, if the current branch of the decision tree does not allow a solution to be found, control will be returned to the software. The software will then continue to traverse the decision tree, eventually reaching some other point where the matrix dimensions will fall within the constraints. The matrix data will then be transferred to FPGA and the RCP will try to solve the sub-problem. These steps will be repeated until we arrive at either a negative or positive result, i.e. we will either obtain a solution or we will conclude that the problem does not have a solution. Thus the decision tree will be treated in software and in hardware in the way that is shown in Fig. 10 . 7 Discussion and related work Recently, several research groups have explored the possibility of accelerating the solution of combinatorial optimization problems with the aid of reconfigurable hardware. The best-investigated problems were the SAT problem [1,23,36,41,42] and the covering problem [24]. As we mentioned in the introduction, practically all proposed architectures apply an instance-specific approach. For example, Plessl et al. proposed an architecture for an instance-specific accelerator for the minimum covering problem [24]. The suggested architecture implements a branch-and-bound algorithm in 3-valued logic. For each problem instance a VHDL description of the respective circuit is automatically generated by a specially designed software application. The resulting VHDL code is used for synthesis and implementation of the circuit with the aid of commercially available tools. The generation of a specific FPGA configuration for each individual problem instance permits performance to be increased and provides a good utilization of available resources. The total problem solving time in this case is equal to “hardware circuit generation time”+“FPGA configuration time”+“execution time”. It should be noted that the time required to generate an instance-specific circuit is quite significant, frequently exceeding the actual execution time, and thus canceling out all the advantages of the fast hardware implementation. For example, with the accelerator developed by Plessl et al. the hardware execution time for some problem instances that were presented in [24] ranged from 1 ms to 2 s while the synthesis and implementation of the circuit required several minutes. Consequently this method can only be used efficiently for very difficult problems for which the hardware compilation and configuration time is negligible compared to the execution time. That is why all recent efforts have been focused on avoiding instance-specific placement and routing. For such purposes, special techniques are usually employed that enable the generation of the FPGA configurations to be significantly accelerated and higher clock rates to be achieved. These techniques rely on modular design styles [1] and HTs that are automatically customized for each problem instance [42]. For example, Dandalis et al. [8] proposed an application-specific mapping approach for solving graph problems. The main objective was to eliminate an excessive hardware compilation time by reducing the need for CAD tools at the mapping stage. For each problem instance an individual circuit is generated. However, the authors [8] have designed an algorithm-specific template, referred to as skeleton, which consists of modules corresponding to basic graph elements. The skeleton can be adapted to different graph instances at run-time. However, the HTs employed in reconfigurable accelerators are usually oriented towards just one problem, and only allow customization for various instances of the same problem. In order to address a different task, even one that is very similar, it is necessary to design a new circuit and to modify the software tools that are employed for automatic customization. As opposed to this approach, the RCP is domain-oriented and thus can be used for solving various combinatorial problems. It is a partially reconfigurable accelerator since only small portions of the control and functional units need to be programmed to match a certain algorithm. The total problem solving time for the RCP consists of three components: “the HT configuration time”+ “the time spent in communications between software and FPGA”+“the execution time”. If the problem is partitioned between software and hardware then the latter value includes two parts: the software execution time and the hardware execution time. Since the reconfiguration is partial, the configuration time is negligible compared to the execution time. A similar approach was followed in a cube calculus machine (CCM) proposed in [22]. The CCM is a hardware accelerator reconfigurable for specific multiple-valued cube calculus operations required by a certain algorithm. For each algorithm an appropriate structure of CCM must be instantiated. The CCM is targeted at execution of the inner loop of algorithms, i.e. a loop that performs operations on cubes. For each operation the host processor loads the respective complex instruction to the CCM and then sends the relevant data cubes to the CCM and receives back the resultant cubes. In such a model of execution, the communication between the host processor and the CCM is quite intensive and can only be acceptable for tightly coupled systems. In contrast to this, the RCP executes the complete algorithm, not just the inner loop, thereby reducing the communication overhead. Another important issue affecting any algorithm implemented in reconfigurable hardware is related to the logic capacity of the device employed, which is always limited. Thus, efficient techniques are needed to deal with the situation when a problem instance exceeds the available hardware resources. In the domain of combinatorial accelerators the following four possibilities have been explored. The first is the expansion of the logic capacity by interconnecting a number of FPGAs and partitioning the circuit between them. It should be noted that fast and efficient multi-device partitioning and routing is quite a difficult task (of course modular and scalable design styles [22,42] can alleviate it). The second method is to partition the problem into a series of configurations to be run either sequentially or in parallel. The partitioning is performed by decomposing an initial problem instance into a set of independent sub-problems [1]. Each sub-problem must satisfy the imposed hardware constraints. The main limitation of this method is that the efficiency of the decomposition greatly depends on the characteristics of the problem instance. As a result, for some problem instances the partitioning time may increase to unacceptable levels. The third method is based on a virtual hardware scheme proposed in [36] for solving the SAT problem, which relies on dividing the circuit into a series of hardware pages that are successively run being the intermediate results stored in external memory blocks. Since all the hardware pages have the same structure with only a number of registers being reconfigured, the page switching is performed very fast. The last method, described in Section 6, is based on software/hardware partitioning according to the available logic capacity of the hardware that is employed [33,34]. Of course, the efficiency of such a partitioning depends on both the problem structure and the scale of the respective implementation of the RCP. In the worst case the time spent in communications can be a significant portion of the total problem solving time. However, recent FPGAs such as Stratix from Altera and Virtex-II/Virtex-II Pro from Xilinx provide an adequate platform for full-scale implementation of the RCP and assure a more efficient software/hardware partitioning. Moreover, it is not even necessary to implement the RCP on a SRAM-based FPGA since the reconfigurability of the accelerator is limited to the number of RAM-based blocks available in the RCU and RFU. Thus the RCP can be implemented as an ASIC equipped with embedded memory blocks [22]. Nevertheless, an implementation based on an in-circuit programmable FPGA is in most cases more cost-effective since the FPGA can be used for other tasks that may be required by different applications. 8 Conclusion The paper presents the results of the design and implementation of a reconfigurable processor for problems of combinatorial optimization. It proposes an architecture for a RCP based on HTs that are composed of fixed components and reprogrammable blocks. The latter include functional and control units with dynamically modifiable behavior. The advantages of the RCP have been shown by experiments with two important combinatorial applications, the Boolean satisfiability and covering problems. Finally, we propose a computational model that allows efficient collaboration between software and reconfigurable hardware and permits the hardware capacity problem inherent to all instance-specific implementations to be partially solved. Acknowledgements The authors would like to acknowledge Ivor Horton for his valuable comments and suggestions. This work was supported by the Portuguese Foundation of Science and Technology under Grant No. FCT-PRAXIS XXI/BD/21353/99. References [1] M. Abramovici J.T. de Sousa A SAT solver using reconfigurable hardware and virtual logic Journal of Automated Reasoning 24 1–2 2000 5 36 [2] D. Abramson, A. Postula, M. Randall, FPGA based custom computing machines for irregular problems, in: Proc. of the Fourth Int. Symposium on High-Performance Computer Architecture––HPCA98, Las Vegas, NV, 1–4 February 1998 [3] Alpha Data (Online). Available from [4] P.M. Athanas H.F. Silverman Processor reconfiguration through instruction-set metamorphosis IEEE Computer 26 3 1993 11 18 [5] S. Baranov Logic Synthesis for Control Automata 1994 Kluwer Academic Publishers [6] D.A. Bell J.M. Arnold W.J. Kleinfelder Splash 2––FPGAs in a Custom Computing Machine 1996 IEEE Computer Society Press [7] T.H. Cormen C.E. Leiserson R.L. Rivest Introduction to Algorithms 1997 McGraw-Hill [8] A. Dandalis, A. Mei, V.K. Prasanna, Domain specific mapping for solving graph problems on reconfigurable devices, in: Reconfigurable Architectures Workshop––RAW ’99, April 1999 [9] C. Dick F. Harris Virtual signal processors Microprocessors and Microsystems 22 1998 135 148 [10] M.R. Garey D.S. Johnson Computers and Intractability: A Guide to the Theory of NP-Completeness 1979 W.H. Freeman and Company San Francisco [11] P. Graham B. Nelson A hardware genetic algorithm for the traveling salesman problem on Splash 2 Proc. 5th International Workshop on Field Programmable Logic and Applications 1995 Oxford England 352 361 [12] J. Gu P.W. Purdom J. Franco B.W. Wah Algorithms for the satisfiability (SAT) problem: a survey DIMACS Series in Discrete Mathematics and Theoretical Computer Science 35 1997 19 151 [13] J.O. Haenni J.L. Beuchat E. Sanchez RENCO: a reconfigurable network computer Proc. IEEE Symposium on FPGAs for Custom Computing Machines (FCCM) 1998 Napa California 288 289 [14] S. Hauck The Roles of FPGAs in Reprogrammable Systems Proceedings of the IEEE 86 4 1998 615 638 [15] S.D. Haynes J. Stone W. Luk Video image processing with the Sonic architecture IEEE Computer 2000 50 57 [16] C. Iseli, E. Sanchez, Spyder: a reconfigurable VLIW processor using FPGAs, in: Proc. of the IEEE Workshop on FPGAs for Custom Computing Machines, April 1993, pp. 17–24 [17] P. Kolinummi P. Hamalainen T. Hamalainen J. Saarinen PARNEU: general-purpose partial tree computer Microprocessors and Microsystems 24 2000 23 42 [18] D.L. Kreher D.R. Stinson Combinatorial Algorithms: Generation, Enumeration, and Search 1999 CRC Press [19] Z. Michalewicz D.B. Fogel How to Solve It: Modern Heuristics 2000 Springer-Verlag [20] G. Micheli Synthesis and Optimization of Digital Circuits 1994 McGraw-Hill, Inc [21] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: engineering an efficient SAT solver, in: Proc. of the 38th Design Automation Conference, June 2001, pp. 530–535 [22] M. Perkowski D. Foote Q. Chen A. Al-Rabadi L. Jozwiak Learning hardware using multiple-valued logic––part 2: cube calculus and architecture IEEE Micro vol. 22, no. 3 May/June 2002 IEEE Computer Society Press Los Alamitos, CA, USA 52 61 [23] M. Platzner G. Micheli Acceleration of satisfiability algorithms by reconfigurable hardware Proc. 8th Int. Workshop on Field Programmable Logic and Applications FPL’98 1998 Springer-Verlag Tallin, Estonia 69 78 [24] C. Plessl, M. Platzner, Instance-specific accelerators for minimum covering, in: Proc. 1st Int. Conf. on Engineering of Reconfigurable Systems and Algorithms, Las Vegas, USA, June 2001, pp. 85–91 [25] RC Bibliography (Online). Available from [26] E. Sanchez M. Sipper J.O. Haenni J.L. Beuchat A. Stauffer A. Perez-Uribe Static and dynamic configurable systems IEEE Transactions on Computers 48 6 1999 556 564 [27] M. Shand, J. Vuillemin, Fast implementation of RSA cryptography, in: Proc. 11th IEEE Symp. Computer Arithmetic, Canada, 1993, pp. 252–259 [28] J.M. Silva K.A. Sakallah GRASP: a search algorithm for propositional satisfiability IEEE Transations on Computers 48 5 1999 506 521 [29] I. Skliarova, A.B. Ferrari, Exploiting FPGA-based architectures and design tools for problems of reconfigurable computations, in: Proc. XIII Symposium on Integrated Circuits and System Design SBCCI’2000, Brazil, September 2000, pp. 347–352 [30] I. Skliarova, A.B. Ferrari, Development tools for problems of combinatorial optimization, in: Proc. 4th Portuguese Conference on Automatic Control––CONTROLO’2000, Portugal, October 2000, pp. 552–557 [31] I. Skliarova A.B. Ferrari Modelos matemáticos e problemas de optimização combinatória Electrónica e Telecomunicações 3 3 2001 202 208 (in Portuguese) [32] I. Skliarova, A.B. Ferrari, Synthesis of reprogrammable control unit for combinatorial processor, in: Proc. of the 4th Int. Workshop on IEEE Design and Diagnostics of Electronic Circuits and Systems––DDECS 2001, Gyor, Hungary, April 2001, pp. 179–186 [33] I. Skliarova, A.B. Ferrari, A SAT solver using software and reconfigurable hardware, in: Proc. of the Design, Automation and Test in Europe Conference DATE’2002, Paris, France, March 2002, p. 1094 [34] I. Skliarova, A.B. Ferrari, A hardware/software approach to accelerate Boolean satisfiability, in: Proc. of IEEE International Workshop on Design and Diagnostics of Electronic Circuits and Systems IEEE DDECS’2002, Brno, Czech Republic, April 2002, pp. 270–277 [35] V. Sklyarov, Synthesis and implementation of RAM-based finite state machines in FPGAs, in: Proc. of FPL’2000, Villach, Austria, August 2000, pp. 718–728 [36] J. de Sousa, J.P. Marques-Silva, M. Abramovici, A configware/software approach to SAT solving, in: Proc. of 9th IEEE Int. Symp. on Field-Programmable Custom Computing Machines, 2001 [37] J.E. Vuillemin P. Bertin D. Roncin M. Shand H.H. Touati P. Boucard Programmable active memories: reconfigurable systems come of age IEEE Transactions on VLSI Systems 4 1 1996 56 69 [38] XESS Corp. (Online). Available from [39] Xilinx, The Programmable Logic Data Book, Xilinx, San Jose, 2000 [40] A.D. Zakrevski Logical Synthesis of Cascade Networks 1981 Moscow Science (in Russian) [41] P. Zhong, M. Martonosi, P. Ashar, S. Malik, Accelerating Boolean satisfiability with configurable hardware, in: Proc. IEEE Symposium on FPGAs for Custom Computing Machines––FCCM, April 1998, pp. 186–195 [42] P. Zhong, Using Configurable Computing to Accelerate Boolean Satisfiability, Ph.D. dissertation, Department of Electrical Engineering, Princeton University, June 1999 Iouliia Skliarova received the M.Sc. degree (in Computer Engineering) from the Belorussian State University of Informatics and Radioelectronics, Minsk, Republic of Belarus, in 1998. She is currently a Ph.D. student at the Department of Electronics and Telecommunications of the University of Aveiro, Portugal. Her research interests include reconfigurable computing, application-specific architectures, computer-aided design and object-oriented programming. Ant ó nio de Brito Ferrari received Electrical Engineering degrees from Universidade do Porto, Portugal and Ecole Superieure d’Electricité, Paris, and M.Sc. and Ph.D. degrees from Brunel University, UK. Currently he is a professor of Computer Engineering at the University of Aveiro, Portugal. His main research interests are in computer architecture, computer arithmetic and reconfigurable systems. "
    },
    {
        "doc_title": "High-level design tools for FPGA-based combinatorial accelerators",
        "doc_scopus_id": "35248856040",
        "doc_doi": "10.1007/978-3-540-45234-8_99",
        "doc_eid": "2-s2.0-35248856040",
        "doc_date": "2003-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Combinatorial search",
            "High-level design"
        ],
        "doc_abstract": "Analysis of different combinatorial search algorithms has shown that they have a set of distinctive features in common. The paper suggests a number of reusable blocks that support these features and provide high-level design of combinatorial accelerators. © Springer-Verlag Berlin Heidelberg 2003.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable hardware SAT solvers: A survey of systems",
        "doc_scopus_id": "35248848429",
        "doc_doi": "10.1007/978-3-540-45234-8_46",
        "doc_eid": "2-s2.0-35248848429",
        "doc_date": "2003-01-01",
        "doc_type": "Review",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Boolean satisfiability",
            "Combinatorial optimization problems",
            "Computational system",
            "General purpose processors",
            "Programmable logic device",
            "Programming models",
            "Reconfigurable systems",
            "Research efforts"
        ],
        "doc_abstract": "By adapting to computations that are not so well supported by general-purpose processors, reconfigurable systems achieve significant increases in performance. Such computational systems use high-capacity programmable logic devices and are based on processing units customized to the requirements of a particular application. A great deal of research effort in this area is aimed at accelerating the solution of combinatorial optimization problems. Special attention was given to the Boolean satisfiability (SAT) problem resulting in a considerable number of different architectures being proposed. This paper presents the state-of-the-art in reconfigurable hardware SAT satisfiers. The analysis of existing systems has been performed according to such criteria as reconfiguration modes, the execution model, the programming model, etc. © Springer-Verlag Berlin Heidelberg 2003.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Reconfigurable systems in education",
        "doc_scopus_id": "35248844586",
        "doc_doi": "10.1007/978-3-540-45234-8_110",
        "doc_eid": "2-s2.0-35248844586",
        "doc_date": "2003-01-01",
        "doc_type": "Article",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Animated tutorials",
            "Digital system",
            "Practical projects",
            "Reconfigurable",
            "Reconfigurable systems",
            "Students' projects"
        ],
        "doc_abstract": "This paper describes methods and tools that have been used for teaching disciplines dedicated to the design of reconfigurable digital systems. It demonstrates students' projects, disseminates experience in the integration of different disciplines, and gives examples of stimulating student activity. A set of animated tutorials for students that are available on WebCT with a number of practical projects that cover a variety of topics in FPGA-based design can be seen as the most valuable contribution to the area considered. © Springer-Verlag Berlin Heidelberg 2003.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design tools and reusable libraries for FPGA-based digital circuits",
        "doc_scopus_id": "20344374529",
        "doc_doi": "10.1109/DSD.2003.1231939",
        "doc_eid": "2-s2.0-20344374529",
        "doc_date": "2003-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Application specific",
            "Design tool",
            "Digital system",
            "Hardware components",
            "Reusable library",
            "Reusable specifications",
            "Sub-circuits",
            "Touch panels"
        ],
        "doc_abstract": "© 2003 IEEE.This paper suggests tools that provide significant improvements in the design and verification of FPGA-based digital circuits. These tools include reusable specifications of hardware components (modules) that have been proposed for two types of CAD environments; Xilinx ISE 5.x and Celoxica DK1. The components can be employed to implement both application-specific blocks from the selected area (mainly from the scope of combinatorial computations) and a number of interfaces that are very useful for interaction and data exchange with devices attached to a FPGA, such as LCD and touch panels, bus controllers, etc. The designed modules can be easily integrated into any application-specific digital system and used for visualizing the results, fast data transfer, debugging of internal sub-circuits, etc. They were constructed in such a way that their functionality can be either fixed or modifiable (both statically and dynamically). The latter capability was provided with the aid of reloadable RAM-based blocks. To illustrate the capabilities of the tools suggested, four design examples are discussed. Additional materials for this paper are available in the form of a number of tutorials and projects for FPGAs that can be accessed through the Internet.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A dynamically reconfigurable accelerator for operations over Boolean and ternary vectors",
        "doc_scopus_id": "20344362539",
        "doc_doi": "10.1109/DSD.2003.1231930",
        "doc_eid": "2-s2.0-20344362539",
        "doc_date": "2003-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Discrete vector",
            "Hardware implementations",
            "Novel architecture",
            "Reconfigurable",
            "Software model",
            "Ternary vectors"
        ],
        "doc_abstract": "© 2003 IEEE.This paper suggests a novel architecture for a reconfigurable accelerator for computations over discrete vectors. The number of executed operations is limited but they can arbitrarily be chosen from a practically unlimited set of feasible operations. The software model and hardware implementations of the accelerator are discussed in detail.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "A SAT solver using software and reconfigurable hardware",
        "doc_scopus_id": "0141977506",
        "doc_doi": "10.1109/DATE.2002.998450",
        "doc_eid": "2-s2.0-0141977506",
        "doc_date": "2002-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Boolean satisfiability problems",
            "Hardware compilation",
            "SAT solvers",
            "Software approach"
        ],
        "doc_abstract": "In this paper we propose a novel approach for solving the Boolean satisfiability problem by combining software and reconfigurable hardware. The suggested technique avoids instance-specific hardware compilation and, as a result, achieves a higher performance than pure software approaches. Moreover, it permits problems that exceed the resources of the available reconfigurable hardware to be solved. © 2002 IEEE.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "FPGA-based implementation of genetic algorithm for the traveling salesman problem and its industrial application",
        "doc_scopus_id": "84918852555",
        "doc_doi": "10.1007/3-540-48035-8_9",
        "doc_eid": "2-s2.0-84918852555",
        "doc_date": "2002-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Theoretical Computer Science",
                "area_abbreviation": "MATH",
                "area_code": "2614"
            },
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            }
        ],
        "doc_keywords": [
            "Destination points",
            "Distribution systems",
            "FPGA-based implementation",
            "Hardware realization",
            "Hierarchical control",
            "Manufacturing applications",
            "Total distances",
            "Virtual controller"
        ],
        "doc_abstract": "© Springer-Verlag Berlin Heidelberg 2002.In this paper an adaptive distribution system for manufacturing applications is considered and examined. The system receives a set of various components at a source point and supplies these components to destination points. The objective is to minimize the total distance that has to be traveled. At each destination point some control algorithms have to be activated and each segment of motion between destination points has also to be controlled. The paper suggests a model for such a distribution system based on autonomous subalgorithms that can further be linked hierarchically. The links are set up during execution time (during motion) with the aid of the results obtained from solving the respective traveling salesman problem (TSP) that gives a proper tour of minimal length. The paper proposes an FPGA-based solution, which integrates a specialized virtual controller implementing hierarchical control algorithms and a hardware realization of genetic algorithm for the TSP.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Design and implementation of reconfigurable processor for problems of combinatorial computations",
        "doc_scopus_id": "0009975792",
        "doc_doi": "10.1109/DSD.2001.952250",
        "doc_eid": "2-s2.0-0009975792",
        "doc_date": "2001-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Control and Systems Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2207"
            }
        ],
        "doc_keywords": [
            "Co-processors",
            "Covering problems",
            "Design and implementations",
            "Paper analysis",
            "Reconfigurable",
            "Reconfigurable coprocessors",
            "Reconfigurable processors",
            "Satisfiability"
        ],
        "doc_abstract": "© 2001 IEEE.The paper analyses different techniques that might be employed in order to solve various problems of combinatorial optimization and argues that the best results can be achieved by the use of software, running on a general-purpose computer, together with an FPGA-based reconfigurable co-processor. It suggests architecture of combinatorial co-processor, which is based on hardware templates and consists of reconfigurable functional and control units. Finally the paper demonstrates how to utilize the co-processor for two practical applications formulated over discrete matrices that are satisfiability and covering problems.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Exploiting FPGA-based architectures and design tools for problems of reconfigurable computations",
        "doc_scopus_id": "84951727190",
        "doc_doi": "10.1109/SBCCI.2000.876053",
        "doc_eid": "2-s2.0-84951727190",
        "doc_date": "2000-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Co-processors",
            "Combinatorial problem",
            "Configurable Logic Blocks",
            "Design and implementations",
            "FPGA-based architectures",
            "General purpose processors",
            "Matrix representation",
            "Reconfigurable logic"
        ],
        "doc_abstract": "© 2000 IEEE.This paper addresses the design and implementation of a configurable \"combinatorial processor\", a computational device, which can be used for solving different combinatorial problems. These can be characterized by a set of variables having a limited number of values with a corresponding set of operations that might be applied to these variables. Different mathematical models can be used to describe such tasks. We adopted a matrix representation, which is easier to treat in digital devices. The operations on discrete matrices are unique and cannot be efficiently performed on a general-purpose processor. Although the number of such operations grows exponentially with the number of variables, to solve a particular combinatorial problem a very small number of such operations is usually required. Hence the importance of providing for the dynamic change of operations. The paper presents an approach allowing the run-time modification of combinatorial computations via reloading the RAM-based configurable logic blocks of the FPGAs.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Development system for FPGA-based digital circuits",
        "doc_scopus_id": "0033488533",
        "doc_doi": null,
        "doc_eid": "2-s2.0-0033488533",
        "doc_date": "1999-12-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Computer Science (all)",
                "area_abbreviation": "COMP",
                "area_code": "1700"
            },
            {
                "area_name": "Engineering (all)",
                "area_abbreviation": "ENGI",
                "area_code": "2200"
            }
        ],
        "doc_keywords": [
            "Dynamically reconfigurable arrays",
            "Dynamically reconfigurable hardware",
            "Logic synthesis"
        ],
        "doc_abstract": "An overview is given of some new hardware and software tools that can be used for the design of virtual circuits based on dynamically reconfigurable FPGAs. These tools provide facilities for synthesis, simulating, testing, and debugging of digital circuits based on dynamically reconfigurable hardware.",
        "available": false,
        "clean_text": ""
    },
    {
        "doc_title": "Synthesis tools and design environment for dynamically reconfigurable FPGAs",
        "doc_scopus_id": "84956868990",
        "doc_doi": "10.1109/SBCCI.1998.715408",
        "doc_eid": "2-s2.0-84956868990",
        "doc_date": "1998-01-01",
        "doc_type": "Conference Paper",
        "doc_areas": [
            {
                "area_name": "Hardware and Architecture",
                "area_abbreviation": "COMP",
                "area_code": "1708"
            },
            {
                "area_name": "Electrical and Electronic Engineering",
                "area_abbreviation": "ENGI",
                "area_code": "2208"
            }
        ],
        "doc_keywords": [
            "Automatic translation",
            "Behavioural specifications",
            "Behavioural synthesis",
            "Design environment",
            "Dynamic re-configuration",
            "Dynamically reconfigurable fpga",
            "Hardware implementations",
            "Integrated design environments"
        ],
        "doc_abstract": "© 1998 IEEE.This paper discusses a range of problems in architectural and logic synthesis of digital devices and suggests practical approaches, methods, and tools for the automatic translation of a behavioural specification into a hardware implementation using a dynamically reconfigurable FPGA of the XC6200 family. The work described in this paper covers two basic areas. Firstly, new FPGA-oriented methods for behavioural synthesis of virtual digital circuits within predefined scopes are presented Secondly, an integrated design environment for logic synthesis (IDELS) is described which has been implemented as an extension of commercially available tools. IDELS permits synthesis in accordance with the developed design flow and offers very powerful run-time debugging facilities, including support for dynamic reconfiguration.",
        "available": false,
        "clean_text": ""
    }
]